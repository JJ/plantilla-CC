
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Encode/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENCODE_LOCALE';
  package Encode::Locale;
  
  use strict;
  our $VERSION = "1.03";
  
  use base 'Exporter';
  our @EXPORT_OK = qw(
      decode_argv env
      $ENCODING_LOCALE $ENCODING_LOCALE_FS
      $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT
  );
  
  use Encode ();
  use Encode::Alias ();
  
  our $ENCODING_LOCALE;
  our $ENCODING_LOCALE_FS;
  our $ENCODING_CONSOLE_IN;
  our $ENCODING_CONSOLE_OUT;
  
  sub DEBUG () { 0 }
  
  sub _init {
      if ($^O eq "MSWin32") {
  	unless ($ENCODING_LOCALE) {
  	    # Try to obtain what the Windows ANSI code page is
  	    eval {
  		unless (defined &GetACP) {
  		    require Win32::API;
  		    Win32::API->Import('kernel32', 'int GetACP()');
  		};
  		if (defined &GetACP) {
  		    my $cp = GetACP();
  		    $ENCODING_LOCALE = "cp$cp" if $cp;
  		}
  	    };
  	}
  
  	unless ($ENCODING_CONSOLE_IN) {
  	    # If we have the Win32::Console module installed we can ask
  	    # it for the code set to use
  	    eval {
  		require Win32::Console;
  		my $cp = Win32::Console::InputCP();
  		$ENCODING_CONSOLE_IN = "cp$cp" if $cp;
  		$cp = Win32::Console::OutputCP();
  		$ENCODING_CONSOLE_OUT = "cp$cp" if $cp;
  	    };
  	    # Invoking the 'chcp' program might also work
  	    if (!$ENCODING_CONSOLE_IN && (qx(chcp) || '') =~ /^Active code page: (\d+)/) {
  		$ENCODING_CONSOLE_IN = "cp$1";
  	    }
  	}
      }
  
      unless ($ENCODING_LOCALE) {
  	eval {
  	    require I18N::Langinfo;
  	    $ENCODING_LOCALE = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  
  	    # Workaround of Encode < v2.25.  The "646" encoding  alias was
  	    # introduced in Encode-2.25, but we don't want to require that version
  	    # quite yet.  Should avoid the CPAN testers failure reported from
  	    # openbsd-4.7/perl-5.10.0 combo.
  	    $ENCODING_LOCALE = "ascii" if $ENCODING_LOCALE eq "646";
  
  	    # https://rt.cpan.org/Ticket/Display.html?id=66373
  	    $ENCODING_LOCALE = "hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8";
  	};
  	$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN;
      }
  
      if ($^O eq "darwin") {
  	$ENCODING_LOCALE_FS ||= "UTF-8";
      }
  
      # final fallback
      $ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";
      $ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;
  
      unless (Encode::find_encoding($ENCODING_LOCALE)) {
  	my $foundit;
  	if (lc($ENCODING_LOCALE) eq "gb18030") {
  	    eval {
  		require Encode::HanExtra;
  	    };
  	    if ($@) {
  		die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped";
  	    }
  	    $foundit++ if Encode::find_encoding($ENCODING_LOCALE);
  	}
  	die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped"
  	    unless $foundit;
  
      }
  
      # use Data::Dump; ddx $ENCODING_LOCALE, $ENCODING_LOCALE_FS, $ENCODING_CONSOLE_IN, $ENCODING_CONSOLE_OUT;
  }
  
  _init();
  Encode::Alias::define_alias(sub {
      no strict 'refs';
      no warnings 'once';
      return ${"ENCODING_" . uc(shift)};
  }, "locale");
  
  sub _flush_aliases {
      no strict 'refs';
      for my $a (keys %Encode::Alias::Alias) {
  	if (defined ${"ENCODING_" . uc($a)}) {
  	    delete $Encode::Alias::Alias{$a};
  	    warn "Flushed alias cache for $a" if DEBUG;
  	}
      }
  }
  
  sub reinit {
      $ENCODING_LOCALE = shift;
      $ENCODING_LOCALE_FS = shift;
      $ENCODING_CONSOLE_IN = $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT = $ENCODING_LOCALE;
      _init();
      _flush_aliases();
  }
  
  sub decode_argv {
      die if defined wantarray;
      for (@ARGV) {
  	$_ = Encode::decode(locale => $_, @_);
      }
  }
  
  sub env {
      my $k = Encode::encode(locale => shift);
      my $old = $ENV{$k};
      if (@_) {
  	my $v = shift;
  	if (defined $v) {
  	    $ENV{$k} = Encode::encode(locale => $v);
  	}
  	else {
  	    delete $ENV{$k};
  	}
      }
      return Encode::decode(locale => $old) if defined wantarray;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode::Locale - Determine the locale encoding
  
  =head1 SYNOPSIS
  
    use Encode::Locale;
    use Encode;
  
    $string = decode(locale => $bytes);
    $bytes = encode(locale => $string);
  
    if (-t) {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
  
    # Processing file names passed in as arguments
    my $uni_filename = decode(locale => $ARGV[0]);
    open(my $fh, "<", encode(locale_fs => $uni_filename))
       || die "Can't open '$uni_filename': $!";
    binmode($fh, ":encoding(locale)");
    ...
  
  =head1 DESCRIPTION
  
  In many applications it's wise to let Perl use Unicode for the strings it
  processes.  Most of the interfaces Perl has to the outside world are still byte
  based.  Programs therefore need to decode byte strings that enter the program
  from the outside and encode them again on the way out.
  
  The POSIX locale system is used to specify both the language conventions
  requested by the user and the preferred character set to consume and
  output.  The C<Encode::Locale> module looks up the charset and encoding (called
  a CODESET in the locale jargon) and arranges for the L<Encode> module to know
  this encoding under the name "locale".  It means bytes obtained from the
  environment can be converted to Unicode strings by calling C<<
  Encode::encode(locale => $bytes) >> and converted back again with C<<
  Encode::decode(locale => $string) >>.
  
  Where file systems interfaces pass file names in and out of the program we also
  need care.  The trend is for operating systems to use a fixed file encoding
  that don't actually depend on the locale; and this module determines the most
  appropriate encoding for file names. The L<Encode> module will know this
  encoding under the name "locale_fs".  For traditional Unix systems this will
  be an alias to the same encoding as "locale".
  
  For programs running in a terminal window (called a "Console" on some systems)
  the "locale" encoding is usually a good choice for what to expect as input and
  output.  Some systems allows us to query the encoding set for the terminal and
  C<Encode::Locale> will do that if available and make these encodings known
  under the C<Encode> aliases "console_in" and "console_out".  For systems where
  we can't determine the terminal encoding these will be aliased as the same
  encoding as "locale".  The advice is to use "console_in" for input known to
  come from the terminal and "console_out" for output known to go from the
  terminal.
  
  In addition to arranging for various Encode aliases the following functions and
  variables are provided:
  
  =over
  
  =item decode_argv( )
  
  =item decode_argv( Encode::FB_CROAK )
  
  This will decode the command line arguments to perl (the C<@ARGV> array) in-place.
  
  The function will by default replace characters that can't be decoded by
  "\x{FFFD}", the Unicode replacement character.
  
  Any argument provided is passed as CHECK to underlying Encode::decode() call.
  Pass the value C<Encode::FB_CROAK> to have the decoding croak if not all the
  command line arguments can be decoded.  See L<Encode/"Handling Malformed Data">
  for details on other options for CHECK.
  
  =item env( $uni_key )
  
  =item env( $uni_key => $uni_value )
  
  Interface to get/set environment variables.  Returns the current value as a
  Unicode string. The $uni_key and $uni_value arguments are expected to be
  Unicode strings as well.  Passing C<undef> as $uni_value deletes the
  environment variable named $uni_key.
  
  The returned value will have the characters that can't be decoded replaced by
  "\x{FFFD}", the Unicode replacement character.
  
  There is no interface to request alternative CHECK behavior as for
  decode_argv().  If you need that you need to call encode/decode yourself.
  For example:
  
      my $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
      my $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
  
  =item reinit( )
  
  =item reinit( $encoding )
  
  Reinitialize the encodings from the locale.  You want to call this function if
  you changed anything in the environment that might influence the locale.
  
  This function will croak if the determined encoding isn't recognized by
  the Encode module.
  
  With argument force $ENCODING_... variables to set to the given value.
  
  =item $ENCODING_LOCALE
  
  The encoding name determined to be suitable for the current locale.
  L<Encode> know this encoding as "locale".
  
  =item $ENCODING_LOCALE_FS
  
  The encoding name determined to be suiteable for file system interfaces
  involving file names.
  L<Encode> know this encoding as "locale_fs".
  
  =item $ENCODING_CONSOLE_IN
  
  =item $ENCODING_CONSOLE_OUT
  
  The encodings to be used for reading and writing output to the a console.
  L<Encode> know these encodings as "console_in" and "console_out".
  
  =back
  
  =head1 NOTES
  
  This table summarizes the mapping of the encodings set up
  by the C<Encode::Locale> module:
  
    Encode      |         |              |
    Alias       | Windows | Mac OS X     | POSIX
    ------------+---------+--------------+------------
    locale      | ANSI    | nl_langinfo  | nl_langinfo
    locale_fs   | ANSI    | UTF-8        | nl_langinfo
    console_in  | OEM     | nl_langinfo  | nl_langinfo
    console_out | OEM     | nl_langinfo  | nl_langinfo
  
  =head2 Windows
  
  Windows has basically 2 sets of APIs.  A wide API (based on passing UTF-16
  strings) and a byte based API based a character set called ANSI.  The
  regular Perl interfaces to the OS currently only uses the ANSI APIs.
  Unfortunately ANSI is not a single character set.
  
  The encoding that corresponds to ANSI varies between different editions of
  Windows.  For many western editions of Windows ANSI corresponds to CP-1252
  which is a character set similar to ISO-8859-1.  Conceptually the ANSI
  character set is a similar concept to the POSIX locale CODESET so this module
  figures out what the ANSI code page is and make this available as
  $ENCODING_LOCALE and the "locale" Encoding alias.
  
  Windows systems also operate with another byte based character set.
  It's called the OEM code page.  This is the encoding that the Console
  takes as input and output.  It's common for the OEM code page to
  differ from the ANSI code page.
  
  =head2 Mac OS X
  
  On Mac OS X the file system encoding is always UTF-8 while the locale
  can otherwise be set up as normal for POSIX systems.
  
  File names on Mac OS X will at the OS-level be converted to
  NFD-form.  A file created by passing a NFC-filename will come
  in NFD-form from readdir().  See L<Unicode::Normalize> for details
  of NFD/NFC.
  
  Actually, Apple does not follow the Unicode NFD standard since not all
  character ranges are decomposed.  The claim is that this avoids problems with
  round trip conversions from old Mac text encodings.  See L<Encode::UTF8Mac> for
  details.
  
  =head2 POSIX (Linux and other Unixes)
  
  File systems might vary in what encoding is to be used for
  filenames.  Since this module has no way to actually figure out
  what the is correct it goes with the best guess which is to
  assume filenames are encoding according to the current locale.
  Users are advised to always specify UTF-8 as the locale charset.
  
  =head1 SEE ALSO
  
  L<I18N::Langinfo>, L<Encode>
  
  =head1 AUTHOR
  
  Copyright 2010 Gisle Aas <gisle@aas.no>.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
ENCODE_LOCALE

$fatpacked{"Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.17022";
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub _throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&_throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  use Scalar::Util ();
  
  sub import {
      shift;
      my @tags = @_;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
  
      @tags = grep {
         if( $_ eq ':warndie' ) {
            Error::WarnDie->import();
            0;
         }
         else {
            1;
         }
      } @tags;
  
      Error::subs->import(@tags);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
  
      unless (@_) {
         $LAST = undef;
         return;
      }
  
      my $pkg = shift;
      return unless ref($pkg);
  
      undef $ERROR{$pkg} if defined $ERROR{$pkg};
  }
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
  
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->($err));
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(Scalar::Util::blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN, $@);
  			my $ok = eval {
  			    $@ = $err;
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = $@ || $Error::THROWN;
  				$err = $Error::ObjectifyCallback->({'text' =>$err})
  					unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
          local($Error::THROWN, $@);
  	    my $ok = eval {
  		$@ = $err;
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = $@ || $Error::THROWN;
  
  		$err = $Error::ObjectifyCallback->({'text' =>$err})
  			unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
  	local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = $@ || $Error::THROWN
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
      unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (Scalar::Util::blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  
  package Error::WarnDie;
  
  sub gen_callstack($)
  {
      my ( $start ) = @_;
  
      require Carp;
      local $Carp::CarpLevel = $start;
      my $trace = Carp::longmess("");
      # Remove try calls from the trace
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      my @callstack = split( m/\n/, $trace );
      return @callstack;
  }
  
  my $old_DIE;
  my $old_WARN;
  
  sub DEATH
  {
      my ( $e ) = @_;
  
      local $SIG{__DIE__} = $old_DIE if( defined $old_DIE );
  
      die @_ if $^S;
  
      my ( $etype, $message, $location, @callstack );
      if ( ref($e) && $e->isa( "Error" ) ) {
          $etype = "exception of type " . ref( $e );
          $message = $e->text;
          $location = $e->file . ":" . $e->line;
          @callstack = split( m/\n/, $e->stacktrace );
      }
      else {
          # Don't apply subsequent layer of message formatting
          die $e if( $e =~ m/^\nUnhandled perl error caught at toplevel:\n\n/ );
          $etype = "perl error";
          my $stackdepth = 0;
          while( caller( $stackdepth ) =~ m/^Error(?:$|::)/ ) {
              $stackdepth++
          }
  
          @callstack = gen_callstack( $stackdepth + 1 );
  
          $message = "$e";
          chomp $message;
  
          if ( $message =~ s/ at (.*?) line (\d+)\.$// ) {
              $location = $1 . ":" . $2;
          }
          else {
              my @caller = caller( $stackdepth );
              $location = $caller[1] . ":" . $caller[2];
          }
      }
  
      shift @callstack;
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      die "\nUnhandled $etype caught at toplevel:\n\n  $message\n\nThrown from: $location\n\nFull stack trace:\n\n$callstack\n";
  }
  
  sub TAXES
  {
      my ( $message ) = @_;
  
      local $SIG{__WARN__} = $old_WARN if( defined $old_WARN );
  
      $message =~ s/ at .*? line \d+\.$//;
      chomp $message;
  
      my @callstack = gen_callstack( 1 );
      my $location = shift @callstack;
  
      # $location already starts in a leading space
      $message .= $location;
  
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      warn "$message:\n$callstack";
  }
  
  sub import
  {
      $old_DIE  = $SIG{__DIE__};
      $old_WARN = $SIG{__WARN__};
  
      $SIG{__DIE__}  = \&DEATH;
      $SIG{__WARN__} = \&TAXES;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 WARNING
  
  Using the "Error" module is B<no longer recommended> due to the black-magical
  nature of its syntactic sugar, which often tends to break. Its maintainers
  have stopped actively writing code that uses it, and discourage people
  from doing so. See the "SEE ALSO" section below for better recommendations.
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
  
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found. The error will also be available in C<$@>.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed. The error will also be available in C<$@>.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 COMPATIBILITY
  
  L<Moose> exports a keyword called C<with> which clashes with Error's. This
  example returns a prototype mismatch error:
  
      package MyTest;
  
      use warnings;
      use Moose;
      use Error qw(:try);
  
  (Thanks to C<maik.hentsche@amd.com> for the report.).
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to it's constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item Error->new()
  
  See the Error::Simple documentation.
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =item $err->associate($obj)
  
  Associates an error with an object to allow error propagation. I.e:
  
      $ber->encode(...) or
          return Error->prior($ber)->associate($ldap);
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =head2 Error::Simple
  
  This class can be used to hold simple error strings and values. It's
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this information will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overridden by the user.
  
  It accepts a single argument which is a hash reference to named parameters.
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =cut
  
  =head1 MESSAGE HANDLERS
  
  C<Error> also provides handlers to extend the output of the C<warn()> perl
  function, and to handle the printing of a thrown C<Error> that is not caught
  or otherwise handled. These are not installed by default, but are requested
  using the C<:warndie> tag in the C<use> line.
  
   use Error qw( :warndie );
  
  These new error handlers are installed in C<$SIG{__WARN__}> and
  C<$SIG{__DIE__}>. If these handlers are already defined when the tag is
  imported, the old values are stored, and used during the new code. Thus, to
  arrange for custom handling of warnings and errors, you will need to perform
  something like the following:
  
   BEGIN {
     $SIG{__WARN__} = sub {
       print STDERR "My special warning handler: $_[0]"
     };
   }
  
   use Error qw( :warndie );
  
  Note that setting C<$SIG{__WARN__}> after the C<:warndie> tag has been
  imported will overwrite the handler that C<Error> provides. If this cannot be
  avoided, then the tag can be explicitly C<import>ed later
  
   use Error;
  
   $SIG{__WARN__} = ...;
  
   import Error qw( :warndie );
  
  =head2 EXAMPLE
  
  The C<__DIE__> handler turns messages such as
  
   Can't call method "foo" on an undefined value at examples/warndie.pl line 16.
  
  into
  
   Unhandled perl error caught at toplevel:
  
     Can't call method "foo" on an undefined value
  
   Thrown from: examples/warndie.pl:16
  
   Full stack trace:
  
           main::inner('undef') called at examples/warndie.pl line 20
           main::outer('undef') called at examples/warndie.pl line 23
  
  =cut
  
  =head1 SEE ALSO
  
  See L<Exception::Class> for a different module providing Object-Oriented
  exception handling, along with a convenient syntax for declaring hierarchies
  for them. It doesn't provide Error's syntactic sugar of C<try { ... }>,
  C<catch { ... }>, etc. which may be a good thing or a bad thing based
  on what you want. (Because Error's syntactic sugar tends to break.)
  
  L<Error::Exception> aims to combine L<Error> and L<Exception::Class>
  "with correct stringification".
  
  L<TryCatch> and L<Try::Tiny> are similar in concept to Error.pm only providing
  a syntax that hopefully breaks less.
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  C<:warndie> handlers added by Paul Evans <leonerd@leonerd.org.uk>
  
  =head1 MAINTAINER
  
  Shlomi Fish, L<http://www.shlomifish.org/> .
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8  Graham Barr. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
ERROR

$fatpacked{"Error/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_SIMPLE';
  # Error/Simple.pm
  #
  # Copyright (c) 2006 Shlomi Fish <shlomif@shlomifish.org>.
  # This file is free software; you can redistribute it and/or
  # modify it under the terms of the MIT/X11 license (whereas the licence
  # of the Error distribution as a whole is the GPLv1+ and the Artistic
  # licence).
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  use Error;
  
  1;
  __END__
  
  =head1 NAME
  
  Error::Simple - the simple error sub-class of Error
  
  =head1 SYNOPSIS
  
      use base 'Error::Simple';
  
  =head1 DESCRIPTION
  
  The only purpose of this module is to allow one to say:
  
      use base 'Error::Simple';
  
  and the only thing it does is "use" Error.pm. Refer to the documentation
  of L<Error> for more information about Error::Simple.
  
  =head1 METHODS
  
  =head2 Error::Simple->new($text [, $value])
  
  Constructs an Error::Simple with the text C<$text> and the optional value
  C<$value>.
  
  =head2 $err->stringify()
  
  Error::Simple overloads this method.
  
  =head1 KNOWN BUGS
  
  None.
  
  =head1 AUTHORS
  
  Shlomi Fish ( L<http://www.shlomifish.org/> )
  
  =head1 SEE ALSO
  
  L<Error>
  
ERROR_SIMPLE

$fatpacked{"File/Slurper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURPER';
  package File::Slurper;
  $File::Slurper::VERSION = '0.009';
  use strict;
  use warnings;
  
  use Carp 'croak';
  use Exporter 5.57 'import';
  
  use Encode qw(:fallbacks);
  use PerlIO::encoding;
  
  our @EXPORT_OK = qw/read_binary read_text read_lines write_binary write_text read_dir/;
  
  sub read_binary {
  	my $filename = shift;
  
  	# This logic is a bit ugly, but gives a significant speed boost
  	# because slurpy readline is not optimized for non-buffered usage
  	open my $fh, '<:unix', $filename or croak "Couldn't open $filename: $!";
  	if (my $size = -s $fh) {
  		my $buf;
  		my ($pos, $read) = 0;
  		do {
  			defined($read = read $fh, ${$buf}, $size - $pos, $pos) or croak "Couldn't read $filename: $!";
  			$pos += $read;
  		} while ($read && $pos < $size);
  		return ${$buf};
  	}
  	else {
  		return do { local $/; <$fh> };
  	}
  }
  
  use constant {
  	CRLF_DEFAULT => $^O eq 'MSWin32',
  	HAS_UTF8_STRICT => scalar do { local $@; eval { require PerlIO::utf8_strict } },
  };
  
  sub _text_layers {
  	my ($encoding, $crlf) = @_;
  	$crlf = CRLF_DEFAULT if $crlf && $crlf eq 'auto';
  
  	if ($encoding =~ /^(latin|iso-8859-)1$/i) {
  		return $crlf ? ':unix:crlf' : ':raw';
  	}
  	elsif (HAS_UTF8_STRICT && $encoding =~ /^utf-?8\b/i) {
  		return $crlf ? ':unix:utf8_strict:crlf' : ':unix:utf8_strict';
  	}
  	else {
  		# non-ascii compatible encodings such as UTF-16 need encoding before crlf
  		return $crlf ? ":raw:encoding($encoding):crlf" : ":raw:encoding($encoding)";
  	}
  }
  
  sub read_text {
  	my ($filename, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  	return read_binary($filename) if $layer eq ':raw';
  
  	local $PerlIO::encoding::fallback = FB_CROAK;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return do { local $/; <$fh> };
  }
  
  sub write_text {
  	my ($filename, undef, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = FB_CROAK;
  	open my $fh, ">$layer", $filename or croak "Couldn't open $filename: $!";
  	print $fh $_[1] or croak "Couldn't write to $filename: $!";
  	close $fh or croak "Couldn't write to $filename: $!";
  	return;
  }
  
  sub write_binary {
  	return write_text(@_[0,1], 'latin-1');
  }
  
  sub read_lines {
  	my ($filename, $encoding, $crlf, $skip_chomp) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = FB_CROAK;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return <$fh> if $skip_chomp;
  	my @buf = <$fh>;
  	close $fh;
  	chomp @buf;
  	return @buf;
  }
  
  sub read_dir {
  	my ($dirname) = @_;
  	opendir my ($dir), $dirname or croak "Could not open $dirname: $!";
  	return grep { not m/ \A \.\.? \z /x } readdir $dir;
  }
  
  1;
  
  # ABSTRACT: A simple, sane and efficient module to slurp a file
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Slurper - A simple, sane and efficient module to slurp a file
  
  =head1 VERSION
  
  version 0.009
  
  =head1 SYNOPSIS
  
   use File::Slurper 'read_text';
   my $content = read_text($filename);
  
  =head1 DESCRIPTION
  
  This module provides functions for fast and correct slurping and spewing. All functions are optionally exported.
  
  =head1 FUNCTIONS
  
  =head2 read_text($filename, $encoding, $crlf)
  
  Reads file C<$filename> into a scalar and decodes it from C<$encoding> (which defaults to UTF-8). If C<$crlf> is true, crlf translation is performed. The default for this argument is off. The special value C<'auto'> will set it to a platform specific default value.
  
  =head2 read_binary($filename)
  
  Reads file C<$filename> into a scalar without any decoding or transformation.
  
  =head2 read_lines($filename, $encoding, $crlf, $skip_chomp)
  
  Reads file C<$filename> into a list/array line-by-line, after decoding from C<$encoding>, optional crlf translation and chomping.
  
  =head2 write_text($filename, $content, $encoding, $crlf)
  
  Writes C<$content> to file C<$filename>, encoding it to C<$encoding> (which defaults to UTF-8). It can also take a C<crlf> argument that works exactly as in read_text.
  
  =head2 write_binary($filename, $content)
  
  Writes C<$content> to file C<$filename> as binary data.
  
  =head2 read_dir($dirname)
  
  Open C<dirname> and return all entries except C<.> and C<..>.
  
  =head1 RATIONALE
  
  This module tries to make it as easy as possible to read and write files correctly and fast. The most correct way of doing this is not always obvious (e.g. L<#83126|https://rt.cpan.org/Public/Bug/Display.html?id=83126>), and just as often the most obvious correct way is not the fastest correct way. This module hides away all such complications behind an easy intuitive interface.
  
  =head1 DEPENDENCIES
  
  This module has an optional dependency on L<PerlIO::utf8_strict|PerlIO::utf8_strict>. Installing this will make UTF-8 encoded IO significantly faster, but should not otherwise affect the operation of this module. This may change into a dependency on the related Unicode::UTF8 in the future.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Path::Tiny|Path::Tiny>
  
  A minimalistic abstraction handling not only IO but also paths.
  
  =item * L<IO::All|IO::All>
  
  An attempt to expose as many IO related features as possible via a single API.
  
  =item * L<File::Slurp|File::Slurp>
  
  This is previous generation file slurping module. It has a number of issues, as described L<here|http://blogs.perl.org/users/leon_timmermans/2015/08/fileslurp-is-broken-and-wrong.html>
  
  =item * L<File::Slurp::Tiny|File::Slurp::Tiny>
  
  This was my previous attempt at a better file slurping module. It's mostly (but not entirely) a drop-in replacement for File::Slurp, which is both a feature (easy conversion) and a bug (interface issues).
  
  =back
  
  =head1 TODO
  
  =over 4
  
  =item * C<open_text>/C<open_binary>?
  
  =item * C<drain_handle>?
  
  =back
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_SLURPER

$fatpacked{"Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT';
  =head1 NAME
  
  Git - Perl interface to the Git version control system
  
  =cut
  
  
  package Git;
  
  use 5.008;
  use strict;
  
  
  BEGIN {
  
  our ($VERSION, @ISA, @EXPORT, @EXPORT_OK);
  
  # Totally unstable API.
  $VERSION = '0.42';
  # pulled from github, commit 217f2767cbcb562872437eed4dec62e00846d90c
  
  
  =head1 SYNOPSIS
  
    use Git;
  
    my $version = Git::command_oneline('version');
  
    git_cmd_try { Git::command_noisy('update-server-info') }
                '%s failed w/ code %d';
  
    my $repo = Git->repository (Directory => '/srv/git/cogito.git');
  
  
    my @revs = $repo->command('rev-list', '--since=last monday', '--all');
  
    my ($fh, $c) = $repo->command_output_pipe('rev-list', '--since=last monday', '--all');
    my $lastrev = <$fh>; chomp $lastrev;
    $repo->command_close_pipe($fh, $c);
  
    my $lastrev = $repo->command_oneline( [ 'rev-list', '--all' ],
                                          STDERR => 0 );
  
    my $sha1 = $repo->hash_and_insert_object('file.txt');
    my $tempfile = tempfile();
    my $size = $repo->cat_blob($sha1, $tempfile);
  
  =cut
  
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(git_cmd_try);
  
  # Methods which can be called as standalone functions as well:
  @EXPORT_OK = qw(command command_oneline command_noisy
                  command_output_pipe command_input_pipe command_close_pipe
                  command_bidi_pipe command_close_bidi_pipe
                  version exec_path html_path hash_object git_cmd_try
                  remote_refs prompt
                  get_tz_offset get_record
                  credential credential_read credential_write
                  temp_acquire temp_is_locked temp_release temp_reset temp_path
                  unquote_path);
  
  
  =head1 DESCRIPTION
  
  [MAINTAINER NOTE: This is Git.pm, plus the other files in the perl/Git directory,
  from github's git/git, which is a mirror of the git source.  I (cpan msouth, or
  current maintainer) update the VERSION string (necessary on CPAN because of another
  CPAN distribution that confused the CPAN toolchain about which was the actual
  official Git.pm), add this explanatory paragraph, and use Dist::Zilla to package
  and release on CPAN.  The only reason that I know of that you would need this is
  if you are using something like Git::Hooks and you are using a perlbrewed (or
  otherwise separate) perl from the one git is using on your system (e.g. if you
  have a dev perl that’s separate from system perl, and git uses the system perl.
  Then the Git.pm gets installed in the system lib and you have no way of getting
  it from CPAN, so your code--that uses modules that depend on Git.pm--doesn’t work).
  I try to keep this up to date, so that if you do pull this from CPAN it will be,
  hopefully, identical in functionality to the Git.pm and Git/*.pm from the git
  distribution.  If that is not the case, contact me and I'll look into it.]
  
  This module provides Perl scripts easy way to interface the Git version control
  system. The modules have an easy and well-tested way to call arbitrary Git
  commands; in the future, the interface will also provide specialized methods
  for doing easily operations which are not totally trivial to do over
  the generic command interface.
  
  While some commands can be executed outside of any context (e.g. 'version'
  or 'init'), most operations require a repository context, which in practice
  means getting an instance of the Git object using the repository() constructor.
  (In the future, we will also get a new_repository() constructor.) All commands
  called as methods of the object are then executed in the context of the
  repository.
  
  Part of the "repository state" is also information about path to the attached
  working copy (unless you work with a bare repository). You can also navigate
  inside of the working copy using the C<wc_chdir()> method. (Note that
  the repository object is self-contained and will not change working directory
  of your process.)
  
  TODO: In the future, we might also do
  
  	my $remoterepo = $repo->remote_repository (Name => 'cogito', Branch => 'master');
  	$remoterepo ||= Git->remote_repository ('http://git.or.cz/cogito.git/');
  	my @refs = $remoterepo->refs();
  
  Currently, the module merely wraps calls to external Git tools. In the future,
  it will provide a much faster way to interact with Git by linking directly
  to libgit. This should be completely opaque to the user, though (performance
  increase notwithstanding).
  
  =cut
  
  
  use Carp qw(carp croak); # but croak is bad - throw instead
  use Error qw(:try);
  use Cwd qw(abs_path cwd);
  use IPC::Open2 qw(open2);
  use Fcntl qw(SEEK_SET SEEK_CUR);
  use Time::Local qw(timegm);
  }
  
  
  =head1 CONSTRUCTORS
  
  =over 4
  
  =item repository ( OPTIONS )
  
  =item repository ( DIRECTORY )
  
  =item repository ()
  
  Construct a new repository object.
  C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
  Possible options are:
  
  B<Repository> - Path to the Git repository.
  
  B<WorkingCopy> - Path to the associated working copy; not strictly required
  as many commands will happily crunch on a bare repository.
  
  B<WorkingSubdir> - Subdirectory in the working copy to work inside.
  Just left undefined if you do not want to limit the scope of operations.
  
  B<Directory> - Path to the Git working directory in its usual setup.
  The C<.git> directory is searched in the directory and all the parent
  directories; if found, C<WorkingCopy> is set to the directory containing
  it and C<Repository> to the C<.git> directory itself. If no C<.git>
  directory was found, the C<Directory> is assumed to be a bare repository,
  C<Repository> is set to point at it and C<WorkingCopy> is left undefined.
  If the C<$GIT_DIR> environment variable is set, things behave as expected
  as well.
  
  You should not use both C<Directory> and either of C<Repository> and
  C<WorkingCopy> - the results of that are undefined.
  
  Alternatively, a directory path may be passed as a single scalar argument
  to the constructor; it is equivalent to setting only the C<Directory> option
  field.
  
  Calling the constructor with no options whatsoever is equivalent to
  calling it with C<< Directory => '.' >>. In general, if you are building
  a standard porcelain command, simply doing C<< Git->repository() >> should
  do the right thing and setup the object to reflect exactly where the user
  is right now.
  
  =cut
  
  sub repository {
  	my $class = shift;
  	my @args = @_;
  	my %opts = ();
  	my $self;
  
  	if (defined $args[0]) {
  		if ($#args % 2 != 1) {
  			# Not a hash.
  			$#args == 0 or throw Error::Simple("bad usage");
  			%opts = ( Directory => $args[0] );
  		} else {
  			%opts = @args;
  		}
  	}
  
  	if (not defined $opts{Repository} and not defined $opts{WorkingCopy}
  		and not defined $opts{Directory}) {
  		$opts{Directory} = '.';
  	}
  
  	if (defined $opts{Directory}) {
  		-d $opts{Directory} or throw Error::Simple("Directory not found: $opts{Directory} $!");
  
  		my $search = Git->repository(WorkingCopy => $opts{Directory});
  		my $dir;
  		try {
  			$dir = $search->command_oneline(['rev-parse', '--git-dir'],
  			                                STDERR => 0);
  		} catch Git::Error::Command with {
  			$dir = undef;
  		};
  
  		if ($dir) {
  			_verify_require();
  			File::Spec->file_name_is_absolute($dir) or $dir = $opts{Directory} . '/' . $dir;
  			$opts{Repository} = abs_path($dir);
  
  			# If --git-dir went ok, this shouldn't die either.
  			my $prefix = $search->command_oneline('rev-parse', '--show-prefix');
  			$dir = abs_path($opts{Directory}) . '/';
  			if ($prefix) {
  				if (substr($dir, -length($prefix)) ne $prefix) {
  					throw Error::Simple("rev-parse confused me - $dir does not have trailing $prefix");
  				}
  				substr($dir, -length($prefix)) = '';
  			}
  			$opts{WorkingCopy} = $dir;
  			$opts{WorkingSubdir} = $prefix;
  
  		} else {
  			# A bare repository? Let's see...
  			$dir = $opts{Directory};
  
  			unless (-d "$dir/refs" and -d "$dir/objects" and -e "$dir/HEAD") {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  			my $search = Git->repository(Repository => $dir);
  			try {
  				$search->command('symbolic-ref', 'HEAD');
  			} catch Git::Error::Command with {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  
  			$opts{Repository} = abs_path($dir);
  		}
  
  		delete $opts{Directory};
  	}
  
  	$self = { opts => \%opts };
  	bless $self, $class;
  }
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item command ( COMMAND [, ARGUMENTS... ] )
  
  =item command ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given Git C<COMMAND> (specify it without the 'git-'
  prefix), optionally with the specified extra C<ARGUMENTS>.
  
  The second more elaborate form can be used if you want to further adjust
  the command execution. Currently, only one option is supported:
  
  B<STDERR> - How to deal with the command's error output. By default (C<undef>)
  it is delivered to the caller's C<STDERR>. A false value (0 or '') will cause
  it to be thrown away. If you want to process it, you can get it in a filehandle
  you specify, but you must be extremely careful; if the error output is not
  very short and you want to read it in the same process as where you called
  C<command()>, you are set up for a nice deadlock!
  
  The method can be called without any instance or on a specified Git repository
  (in that case the command will be run in the repository context).
  
  In scalar context, it returns all the command output in a single string
  (verbatim).
  
  In array context, it returns an array containing lines printed to the
  command's stdout (without trailing newlines).
  
  In both cases, the command's stdin and stderr are the same as the caller's.
  
  =cut
  
  sub command {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	if (not defined wantarray) {
  		# Nothing to pepper the possible exception with.
  		_cmd_close($ctx, $fh);
  
  	} elsif (not wantarray) {
  		local $/;
  		my $text = <$fh>;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			# Pepper with the output:
  			my $E = shift;
  			$E->{'-outputref'} = \$text;
  			throw $E;
  		};
  		return $text;
  
  	} else {
  		my @lines = <$fh>;
  		defined and chomp for @lines;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			my $E = shift;
  			$E->{'-outputref'} = \@lines;
  			throw $E;
  		};
  		return @lines;
  	}
  }
  
  
  =item command_oneline ( COMMAND [, ARGUMENTS... ] )
  
  =item command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but always return a scalar string containing the first line
  of the command's standard output.
  
  =cut
  
  sub command_oneline {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	my $line = <$fh>;
  	defined $line and chomp $line;
  	try {
  		_cmd_close($ctx, $fh);
  	} catch Git::Error::Command with {
  		# Pepper with the output:
  		my $E = shift;
  		$E->{'-outputref'} = \$line;
  		throw $E;
  	};
  	return $line;
  }
  
  
  =item command_output_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but return a pipe filehandle from which the command output can be
  read.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_output_pipe {
  	_command_common_pipe('-|', @_);
  }
  
  
  =item command_input_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return an input pipe filehandle instead; the command output
  is not captured.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_input_pipe {
  	_command_common_pipe('|-', @_);
  }
  
  
  =item command_close_pipe ( PIPE [, CTX ] )
  
  Close the C<PIPE> as returned from C<command_*_pipe()>, checking
  whether the command finished successfully. The optional C<CTX> argument
  is required if you want to see the command name in the error message,
  and it is the second value returned by C<command_*_pipe()> when
  called in array context. The call idiom is:
  
  	my ($fh, $ctx) = $r->command_output_pipe('status');
  	while (<$fh>) { ... }
  	$r->command_close_pipe($fh, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  =cut
  
  sub command_close_pipe {
  	my ($self, $fh, $ctx) = _maybe_self(@_);
  	$ctx ||= '<unknown>';
  	_cmd_close($ctx, $fh);
  }
  
  =item command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return both an input pipe filehandle and an output pipe filehandle.
  
  The function will return C<($pid, $pipe_in, $pipe_out, $ctx)>.
  See C<command_close_bidi_pipe()> for details.
  
  =cut
  
  sub command_bidi_pipe {
  	my ($pid, $in, $out);
  	my ($self) = _maybe_self(@_);
  	local %ENV = %ENV;
  	my $cwd_save = undef;
  	if ($self) {
  		shift;
  		$cwd_save = cwd();
  		_setup_git_cmd_env($self);
  	}
  	$pid = open2($in, $out, 'git', @_);
  	chdir($cwd_save) if $cwd_save;
  	return ($pid, $in, $out, join(' ', @_));
  }
  
  =item command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )
  
  Close the C<PIPE_IN> and C<PIPE_OUT> as returned from C<command_bidi_pipe()>,
  checking whether the command finished successfully. The optional C<CTX>
  argument is required if you want to see the command name in the error message,
  and it is the fourth value returned by C<command_bidi_pipe()>.  The call idiom
  is:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, $out, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  C<PIPE_IN> and C<PIPE_OUT> may be C<undef> if they have been closed prior to
  calling this function.  This may be useful in a query-response type of
  commands where caller first writes a query and later reads response, eg:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	close $out;
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, undef, $ctx);
  
  This idiom may prevent potential dead locks caused by data sent to the output
  pipe not being flushed and thus not reaching the executed command.
  
  =cut
  
  sub command_close_bidi_pipe {
  	local $?;
  	my ($self, $pid, $in, $out, $ctx) = _maybe_self(@_);
  	_cmd_close($ctx, (grep { defined } ($in, $out)));
  	waitpid $pid, 0;
  	if ($? >> 8) {
  		throw Git::Error::Command($ctx, $? >>8);
  	}
  }
  
  
  =item command_noisy ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command() does but do not
  capture the command output - the standard output is not redirected and goes
  to the standard output of the caller application.
  
  While the method is called command_noisy(), you might want to as well use
  it for the most silent Git commands which you know will never pollute your
  stdout but you want to avoid the overhead of the pipe setup when calling them.
  
  The function returns only after the command has finished running.
  
  =cut
  
  sub command_noisy {
  	my ($self, $cmd, @args) = _maybe_self(@_);
  	_check_valid_cmd($cmd);
  
  	my $pid = fork;
  	if (not defined $pid) {
  		throw Error::Simple("fork failed: $!");
  	} elsif ($pid == 0) {
  		_cmd_exec($self, $cmd, @args);
  	}
  	if (waitpid($pid, 0) > 0 and $?>>8 != 0) {
  		throw Git::Error::Command(join(' ', $cmd, @args), $? >> 8);
  	}
  }
  
  
  =item version ()
  
  Return the Git version in use.
  
  =cut
  
  sub version {
  	my $verstr = command_oneline('--version');
  	$verstr =~ s/^git version //;
  	$verstr;
  }
  
  
  =item exec_path ()
  
  Return path to the Git sub-command executables (the same as
  C<git --exec-path>). Useful mostly only internally.
  
  =cut
  
  sub exec_path { command_oneline('--exec-path') }
  
  
  =item html_path ()
  
  Return path to the Git html documentation (the same as
  C<git --html-path>). Useful mostly only internally.
  
  =cut
  
  sub html_path { command_oneline('--html-path') }
  
  
  =item get_tz_offset ( TIME )
  
  Return the time zone offset from GMT in the form +/-HHMM where HH is
  the number of hours from GMT and MM is the number of minutes.  This is
  the equivalent of what strftime("%z", ...) would provide on a GNU
  platform.
  
  If TIME is not supplied, the current local time is used.
  
  =cut
  
  sub get_tz_offset {
  	# some systems don't handle or mishandle %z, so be creative.
  	my $t = shift || time;
  	my $gm = timegm(localtime($t));
  	my $sign = qw( + + - )[ $gm <=> $t ];
  	return sprintf("%s%02d%02d", $sign, (gmtime(abs($t - $gm)))[2,1]);
  }
  
  =item get_record ( FILEHANDLE, INPUT_RECORD_SEPARATOR )
  
  Read one record from FILEHANDLE delimited by INPUT_RECORD_SEPARATOR,
  removing any trailing INPUT_RECORD_SEPARATOR.
  
  =cut
  
  sub get_record {
  	my ($fh, $rs) = @_;
  	local $/ = $rs;
  	my $rec = <$fh>;
  	chomp $rec if defined $rs;
  	$rec;
  }
  
  =item prompt ( PROMPT , ISPASSWORD  )
  
  Query user C<PROMPT> and return answer from user.
  
  Honours GIT_ASKPASS and SSH_ASKPASS environment variables for querying
  the user. If no *_ASKPASS variable is set or an error occoured,
  the terminal is tried as a fallback.
  If C<ISPASSWORD> is set and true, the terminal disables echo.
  
  =cut
  
  sub prompt {
  	my ($prompt, $isPassword) = @_;
  	my $ret;
  	if (exists $ENV{'GIT_ASKPASS'}) {
  		$ret = _prompt($ENV{'GIT_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret && exists $ENV{'SSH_ASKPASS'}) {
  		$ret = _prompt($ENV{'SSH_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret) {
  		print STDERR $prompt;
  		STDERR->flush;
  		if (defined $isPassword && $isPassword) {
  			require Term::ReadKey;
  			Term::ReadKey::ReadMode('noecho');
  			$ret = '';
  			while (defined(my $key = Term::ReadKey::ReadKey(0))) {
  				last if $key =~ /[\012\015]/; # \n\r
  				$ret .= $key;
  			}
  			Term::ReadKey::ReadMode('restore');
  			print STDERR "\n";
  			STDERR->flush;
  		} else {
  			chomp($ret = <STDIN>);
  		}
  	}
  	return $ret;
  }
  
  sub _prompt {
  	my ($askpass, $prompt) = @_;
  	return unless length $askpass;
  	$prompt =~ s/\n/ /g;
  	my $ret;
  	open my $fh, "-|", $askpass, $prompt or return;
  	$ret = <$fh>;
  	$ret =~ s/[\015\012]//g; # strip \r\n, chomp does not work on all systems (i.e. windows) as expected
  	close ($fh);
  	return $ret;
  }
  
  =item repo_path ()
  
  Return path to the git repository. Must be called on a repository instance.
  
  =cut
  
  sub repo_path { $_[0]->{opts}->{Repository} }
  
  
  =item wc_path ()
  
  Return path to the working copy. Must be called on a repository instance.
  
  =cut
  
  sub wc_path { $_[0]->{opts}->{WorkingCopy} }
  
  
  =item wc_subdir ()
  
  Return path to the subdirectory inside of a working copy. Must be called
  on a repository instance.
  
  =cut
  
  sub wc_subdir { $_[0]->{opts}->{WorkingSubdir} ||= '' }
  
  
  =item wc_chdir ( SUBDIR )
  
  Change the working copy subdirectory to work within. The C<SUBDIR> is
  relative to the working copy root directory (not the current subdirectory).
  Must be called on a repository instance attached to a working copy
  and the directory must exist.
  
  =cut
  
  sub wc_chdir {
  	my ($self, $subdir) = @_;
  	$self->wc_path()
  		or throw Error::Simple("bare repository");
  
  	-d $self->wc_path().'/'.$subdir
  		or throw Error::Simple("subdir not found: $subdir $!");
  	# Of course we will not "hold" the subdirectory so anyone
  	# can delete it now and we will never know. But at least we tried.
  
  	$self->{opts}->{WorkingSubdir} = $subdir;
  }
  
  
  =item config ( VARIABLE )
  
  Retrieve the configuration C<VARIABLE> in the same manner as C<config>
  does. In scalar context requires the variable to be set only one time
  (exception is thrown otherwise), in array context returns allows the
  variable to be set multiple times and returns all the values.
  
  =cut
  
  sub config {
  	return _config_common({}, @_);
  }
  
  
  =item config_bool ( VARIABLE )
  
  Retrieve the bool configuration C<VARIABLE>. The return value
  is usable as a boolean in perl (and C<undef> if it's not defined,
  of course).
  
  =cut
  
  sub config_bool {
  	my $val = scalar _config_common({'kind' => '--bool'}, @_);
  
  	# Do not rewrite this as return (defined $val && $val eq 'true')
  	# as some callers do care what kind of falsehood they receive.
  	if (!defined $val) {
  		return undef;
  	} else {
  		return $val eq 'true';
  	}
  }
  
  
  =item config_path ( VARIABLE )
  
  Retrieve the path configuration C<VARIABLE>. The return value
  is an expanded path or C<undef> if it's not defined.
  
  =cut
  
  sub config_path {
  	return _config_common({'kind' => '--path'}, @_);
  }
  
  
  =item config_int ( VARIABLE )
  
  Retrieve the integer configuration C<VARIABLE>. The return value
  is simple decimal number.  An optional value suffix of 'k', 'm',
  or 'g' in the config file will cause the value to be multiplied
  by 1024, 1048576 (1024^2), or 1073741824 (1024^3) prior to output.
  It would return C<undef> if configuration variable is not defined.
  
  =cut
  
  sub config_int {
  	return scalar _config_common({'kind' => '--int'}, @_);
  }
  
  # Common subroutine to implement bulk of what the config* family of methods
  # do. This currently wraps command('config') so it is not so fast.
  sub _config_common {
  	my ($opts) = shift @_;
  	my ($self, $var) = _maybe_self(@_);
  
  	try {
  		my @cmd = ('config', $opts->{'kind'} ? $opts->{'kind'} : ());
  		unshift @cmd, $self if $self;
  		if (wantarray) {
  			return command(@cmd, '--get-all', $var);
  		} else {
  			return command_oneline(@cmd, '--get', $var);
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		if ($E->value() == 1) {
  			# Key not found.
  			return;
  		} else {
  			throw $E;
  		}
  	};
  }
  
  =item get_colorbool ( NAME )
  
  Finds if color should be used for NAMEd operation from the configuration,
  and returns boolean (true for "use color", false for "do not use color").
  
  =cut
  
  sub get_colorbool {
  	my ($self, $var) = @_;
  	my $stdout_to_tty = (-t STDOUT) ? "true" : "false";
  	my $use_color = $self->command_oneline('config', '--get-colorbool',
  					       $var, $stdout_to_tty);
  	return ($use_color eq 'true');
  }
  
  =item get_color ( SLOT, COLOR )
  
  Finds color for SLOT from the configuration, while defaulting to COLOR,
  and returns the ANSI color escape sequence:
  
  	print $repo->get_color("color.interactive.prompt", "underline blue white");
  	print "some text";
  	print $repo->get_color("", "normal");
  
  =cut
  
  sub get_color {
  	my ($self, $slot, $default) = @_;
  	my $color = $self->command_oneline('config', '--get-color', $slot, $default);
  	if (!defined $color) {
  		$color = "";
  	}
  	return $color;
  }
  
  =item remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )
  
  This function returns a hashref of refs stored in a given remote repository.
  The hash is in the format C<refname =\> hash>. For tags, the C<refname> entry
  contains the tag object while a C<refname^{}> entry gives the tagged objects.
  
  C<REPOSITORY> has the same meaning as the appropriate C<git-ls-remote>
  argument; either a URL or a remote name (if called on a repository instance).
  C<GROUPS> is an optional arrayref that can contain 'tags' to return all the
  tags and/or 'heads' to return all the heads. C<REFGLOB> is an optional array
  of strings containing a shell-like glob to further limit the refs returned in
  the hash; the meaning is again the same as the appropriate C<git-ls-remote>
  argument.
  
  This function may or may not be called on a repository instance. In the former
  case, remote names as defined in the repository are recognized as repository
  specifiers.
  
  =cut
  
  sub remote_refs {
  	my ($self, $repo, $groups, $refglobs) = _maybe_self(@_);
  	my @args;
  	if (ref $groups eq 'ARRAY') {
  		foreach (@$groups) {
  			if ($_ eq 'heads') {
  				push (@args, '--heads');
  			} elsif ($_ eq 'tags') {
  				push (@args, '--tags');
  			} else {
  				# Ignore unknown groups for future
  				# compatibility
  			}
  		}
  	}
  	push (@args, $repo);
  	if (ref $refglobs eq 'ARRAY') {
  		push (@args, @$refglobs);
  	}
  
  	my @self = $self ? ($self) : (); # Ultra trickery
  	my ($fh, $ctx) = Git::command_output_pipe(@self, 'ls-remote', @args);
  	my %refs;
  	while (<$fh>) {
  		chomp;
  		my ($hash, $ref) = split(/\t/, $_, 2);
  		$refs{$ref} = $hash;
  	}
  	Git::command_close_pipe(@self, $fh, $ctx);
  	return \%refs;
  }
  
  
  =item ident ( TYPE | IDENTSTR )
  
  =item ident_person ( TYPE | IDENTSTR | IDENTARRAY )
  
  This suite of functions retrieves and parses ident information, as stored
  in the commit and tag objects or produced by C<var GIT_type_IDENT> (thus
  C<TYPE> can be either I<author> or I<committer>; case is insignificant).
  
  The C<ident> method retrieves the ident information from C<git var>
  and either returns it as a scalar string or as an array with the fields parsed.
  Alternatively, it can take a prepared ident string (e.g. from the commit
  object) and just parse it.
  
  C<ident_person> returns the person part of the ident - name and email;
  it can take the same arguments as C<ident> or the array returned by C<ident>.
  
  The synopsis is like:
  
  	my ($name, $email, $time_tz) = ident('author');
  	"$name <$email>" eq ident_person('author');
  	"$name <$email>" eq ident_person($name);
  	$time_tz =~ /^\d+ [+-]\d{4}$/;
  
  =cut
  
  sub ident {
  	my ($self, $type) = _maybe_self(@_);
  	my $identstr;
  	if (lc $type eq lc 'committer' or lc $type eq lc 'author') {
  		my @cmd = ('var', 'GIT_'.uc($type).'_IDENT');
  		unshift @cmd, $self if $self;
  		$identstr = command_oneline(@cmd);
  	} else {
  		$identstr = $type;
  	}
  	if (wantarray) {
  		return $identstr =~ /^(.*) <(.*)> (\d+ [+-]\d{4})$/;
  	} else {
  		return $identstr;
  	}
  }
  
  sub ident_person {
  	my ($self, @ident) = _maybe_self(@_);
  	$#ident == 0 and @ident = $self ? $self->ident($ident[0]) : ident($ident[0]);
  	return "$ident[0] <$ident[1]>";
  }
  
  =item parse_mailboxes
  
  Return an array of mailboxes extracted from a string.
  
  =cut
  
  # Very close to Mail::Address's parser, but we still have minor
  # differences in some cases (see t9000 for examples).
  sub parse_mailboxes {
  	my $re_comment = qr/\((?:[^)]*)\)/;
  	my $re_quote = qr/"(?:[^\"\\]|\\.)*"/;
  	my $re_word = qr/(?:[^]["\s()<>:;@\\,.]|\\.)+/;
  
  	# divide the string in tokens of the above form
  	my $re_token = qr/(?:$re_quote|$re_word|$re_comment|\S)/;
  	my @tokens = map { $_ =~ /\s*($re_token)\s*/g } @_;
  	my $end_of_addr_seen = 0;
  
  	# add a delimiter to simplify treatment for the last mailbox
  	push @tokens, ",";
  
  	my (@addr_list, @phrase, @address, @comment, @buffer) = ();
  	foreach my $token (@tokens) {
  		if ($token =~ /^[,;]$/) {
  			# if buffer still contains undeterminated strings
  			# append it at the end of @address or @phrase
  			if ($end_of_addr_seen) {
  				push @phrase, @buffer;
  			} else {
  				push @address, @buffer;
  			}
  
  			my $str_phrase = join ' ', @phrase;
  			my $str_address = join '', @address;
  			my $str_comment = join ' ', @comment;
  
  			# quote are necessary if phrase contains
  			# special characters
  			if ($str_phrase =~ /[][()<>:;@\\,.\000-\037\177]/) {
  				$str_phrase =~ s/(^|[^\\])"/$1/g;
  				$str_phrase = qq["$str_phrase"];
  			}
  
  			# add "<>" around the address if necessary
  			if ($str_address ne "" && $str_phrase ne "") {
  				$str_address = qq[<$str_address>];
  			}
  
  			my $str_mailbox = "$str_phrase $str_address $str_comment";
  			$str_mailbox =~ s/^\s*|\s*$//g;
  			push @addr_list, $str_mailbox if ($str_mailbox);
  
  			@phrase = @address = @comment = @buffer = ();
  			$end_of_addr_seen = 0;
  		} elsif ($token =~ /^\(/) {
  			push @comment, $token;
  		} elsif ($token eq "<") {
  			push @phrase, (splice @address), (splice @buffer);
  		} elsif ($token eq ">") {
  			$end_of_addr_seen = 1;
  			push @address, (splice @buffer);
  		} elsif ($token eq "@" && !$end_of_addr_seen) {
  			push @address, (splice @buffer), "@";
  		} else {
  			push @buffer, $token;
  		}
  	}
  
  	return @addr_list;
  }
  
  =item hash_object ( TYPE, FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> considering it is
  of the C<TYPE> object type (C<blob>, C<commit>, C<tree>).
  
  The method can be called without any instance or on a specified Git repository,
  it makes zero difference.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_object {
  	my ($self, $type, $file) = _maybe_self(@_);
  	command_oneline('hash-object', '-t', $type, $file);
  }
  
  
  =item hash_and_insert_object ( FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> and add the object to the
  object database.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_and_insert_object {
  	my ($self, $filename) = @_;
  
  	carp "Bad filename \"$filename\"" if $filename =~ /[\r\n]/;
  
  	$self->_open_hash_and_insert_object_if_needed();
  	my ($in, $out) = ($self->{hash_object_in}, $self->{hash_object_out});
  
  	unless (print $out $filename, "\n") {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	chomp(my $hash = <$in>);
  	unless (defined($hash)) {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("in pipe went bad");
  	}
  
  	return $hash;
  }
  
  sub _open_hash_and_insert_object_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{hash_object_pid});
  
  	($self->{hash_object_pid}, $self->{hash_object_in},
  	 $self->{hash_object_out}, $self->{hash_object_ctx}) =
  		$self->command_bidi_pipe(qw(hash-object -w --stdin-paths --no-filters));
  }
  
  sub _close_hash_and_insert_object {
  	my ($self) = @_;
  
  	return unless defined($self->{hash_object_pid});
  
  	my @vars = map { 'hash_object_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  =item cat_blob ( SHA1, FILEHANDLE )
  
  Prints the contents of the blob identified by C<SHA1> to C<FILEHANDLE> and
  returns the number of bytes printed.
  
  =cut
  
  sub cat_blob {
  	my ($self, $sha1, $fh) = @_;
  
  	$self->_open_cat_blob_if_needed();
  	my ($in, $out) = ($self->{cat_blob_in}, $self->{cat_blob_out});
  
  	unless (print $out $sha1, "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	my $description = <$in>;
  	if ($description =~ / missing$/) {
  		carp "$sha1 doesn't exist in the repository";
  		return -1;
  	}
  
  	if ($description !~ /^[0-9a-fA-F]{40} \S+ (\d+)$/) {
  		carp "Unexpected result returned from git cat-file";
  		return -1;
  	}
  
  	my $size = $1;
  
  	my $blob;
  	my $bytesLeft = $size;
  
  	while (1) {
  		last unless $bytesLeft;
  
  		my $bytesToRead = $bytesLeft < 1024 ? $bytesLeft : 1024;
  		my $read = read($in, $blob, $bytesToRead);
  		unless (defined($read)) {
  			$self->_close_cat_blob();
  			throw Error::Simple("in pipe went bad");
  		}
  		unless (print $fh $blob) {
  			$self->_close_cat_blob();
  			throw Error::Simple("couldn't write to passed in filehandle");
  		}
  		$bytesLeft -= $read;
  	}
  
  	# Skip past the trailing newline.
  	my $newline;
  	my $read = read($in, $newline, 1);
  	unless (defined($read)) {
  		$self->_close_cat_blob();
  		throw Error::Simple("in pipe went bad");
  	}
  	unless ($read == 1 && $newline eq "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("didn't find newline after blob");
  	}
  
  	return $size;
  }
  
  sub _open_cat_blob_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{cat_blob_pid});
  
  	($self->{cat_blob_pid}, $self->{cat_blob_in},
  	 $self->{cat_blob_out}, $self->{cat_blob_ctx}) =
  		$self->command_bidi_pipe(qw(cat-file --batch));
  }
  
  sub _close_cat_blob {
  	my ($self) = @_;
  
  	return unless defined($self->{cat_blob_pid});
  
  	my @vars = map { 'cat_blob_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  
  =item credential_read( FILEHANDLE )
  
  Reads credential key-value pairs from C<FILEHANDLE>.  Reading stops at EOF or
  when an empty line is encountered.  Each line must be of the form C<key=value>
  with a non-empty key.  Function returns hash with all read values.  Any white
  space (other than new-line character) is preserved.
  
  =cut
  
  sub credential_read {
  	my ($self, $reader) = _maybe_self(@_);
  	my %credential;
  	while (<$reader>) {
  		chomp;
  		if ($_ eq '') {
  			last;
  		} elsif (!/^([^=]+)=(.*)$/) {
  			throw Error::Simple("unable to parse git credential data:\n$_");
  		}
  		$credential{$1} = $2;
  	}
  	return %credential;
  }
  
  =item credential_write( FILEHANDLE, CREDENTIAL_HASHREF )
  
  Writes credential key-value pairs from hash referenced by
  C<CREDENTIAL_HASHREF> to C<FILEHANDLE>.  Keys and values cannot contain
  new-lines or NUL bytes characters, and key cannot contain equal signs nor be
  empty (if they do Error::Simple is thrown).  Any white space is preserved.  If
  value for a key is C<undef>, it will be skipped.
  
  If C<'url'> key exists it will be written first.  (All the other key-value
  pairs are written in sorted order but you should not depend on that).  Once
  all lines are written, an empty line is printed.
  
  =cut
  
  sub credential_write {
  	my ($self, $writer, $credential) = _maybe_self(@_);
  	my ($key, $value);
  
  	# Check if $credential is valid prior to writing anything
  	while (($key, $value) = each %$credential) {
  		if (!defined $key || !length $key) {
  			throw Error::Simple("credential key empty or undefined");
  		} elsif ($key =~ /[=\n\0]/) {
  			throw Error::Simple("credential key contains invalid characters: $key");
  		} elsif (defined $value && $value =~ /[\n\0]/) {
  			throw Error::Simple("credential value for key=$key contains invalid characters: $value");
  		}
  	}
  
  	for $key (sort {
  		# url overwrites other fields, so it must come first
  		return -1 if $a eq 'url';
  		return  1 if $b eq 'url';
  		return $a cmp $b;
  	} keys %$credential) {
  		if (defined $credential->{$key}) {
  			print $writer $key, '=', $credential->{$key}, "\n";
  		}
  	}
  	print $writer "\n";
  }
  
  sub _credential_run {
  	my ($self, $credential, $op) = _maybe_self(@_);
  	my ($pid, $reader, $writer, $ctx) = command_bidi_pipe('credential', $op);
  
  	credential_write $writer, $credential;
  	close $writer;
  
  	if ($op eq "fill") {
  		%$credential = credential_read $reader;
  	}
  	if (<$reader>) {
  		throw Error::Simple("unexpected output from git credential $op response:\n$_\n");
  	}
  
  	command_close_bidi_pipe($pid, $reader, undef, $ctx);
  }
  
  =item credential( CREDENTIAL_HASHREF [, OPERATION ] )
  
  =item credential( CREDENTIAL_HASHREF, CODE )
  
  Executes C<git credential> for a given set of credentials and specified
  operation.  In both forms C<CREDENTIAL_HASHREF> needs to be a reference to
  a hash which stores credentials.  Under certain conditions the hash can
  change.
  
  In the first form, C<OPERATION> can be C<'fill'>, C<'approve'> or C<'reject'>,
  and function will execute corresponding C<git credential> sub-command.  If
  it's omitted C<'fill'> is assumed.  In case of C<'fill'> the values stored in
  C<CREDENTIAL_HASHREF> will be changed to the ones returned by the C<git
  credential fill> command.  The usual usage would look something like:
  
  	my %cred = (
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	);
  	Git::credential \%cred;
  	if (try_to_authenticate($cred{'username'}, $cred{'password'})) {
  		Git::credential \%cred, 'approve';
  		... do more stuff ...
  	} else {
  		Git::credential \%cred, 'reject';
  	}
  
  In the second form, C<CODE> needs to be a reference to a subroutine.  The
  function will execute C<git credential fill> to fill the provided credential
  hash, then call C<CODE> with C<CREDENTIAL_HASHREF> as the sole argument.  If
  C<CODE>'s return value is defined, the function will execute C<git credential
  approve> (if return value yields true) or C<git credential reject> (if return
  value is false).  If the return value is undef, nothing at all is executed;
  this is useful, for example, if the credential could neither be verified nor
  rejected due to an unrelated network error.  The return value is the same as
  what C<CODE> returns.  With this form, the usage might look as follows:
  
  	if (Git::credential {
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	}, sub {
  		my $cred = shift;
  		return !!try_to_authenticate($cred->{'username'},
  		                             $cred->{'password'});
  	}) {
  		... do more stuff ...
  	}
  
  =cut
  
  sub credential {
  	my ($self, $credential, $op_or_code) = (_maybe_self(@_), 'fill');
  
  	if ('CODE' eq ref $op_or_code) {
  		_credential_run $credential, 'fill';
  		my $ret = $op_or_code->($credential);
  		if (defined $ret) {
  			_credential_run $credential, $ret ? 'approve' : 'reject';
  		}
  		return $ret;
  	} else {
  		_credential_run $credential, $op_or_code;
  	}
  }
  
  { # %TEMP_* Lexical Context
  
  my (%TEMP_FILEMAP, %TEMP_FILES);
  
  =item temp_acquire ( NAME )
  
  Attempts to retrieve the temporary file mapped to the string C<NAME>. If an
  associated temp file has not been created this session or was closed, it is
  created, cached, and set for autoflush and binmode.
  
  Internally locks the file mapped to C<NAME>. This lock must be released with
  C<temp_release()> when the temp file is no longer needed. Subsequent attempts
  to retrieve temporary files mapped to the same C<NAME> while still locked will
  cause an error. This locking mechanism provides a weak guarantee and is not
  threadsafe. It does provide some error checking to help prevent temp file refs
  writing over one another.
  
  In general, the L<File::Handle> returned should not be closed by consumers as
  it defeats the purpose of this caching mechanism. If you need to close the temp
  file handle, then you should use L<File::Temp> or another temp file faculty
  directly. If a handle is closed and then requested again, then a warning will
  issue.
  
  =cut
  
  sub temp_acquire {
  	my $temp_fd = _temp_cache(@_);
  
  	$TEMP_FILES{$temp_fd}{locked} = 1;
  	$temp_fd;
  }
  
  =item temp_is_locked ( NAME )
  
  Returns true if the internal lock created by a previous C<temp_acquire()>
  call with C<NAME> is still in effect.
  
  When temp_acquire is called on a C<NAME>, it internally locks the temporary
  file mapped to C<NAME>.  That lock will not be released until C<temp_release()>
  is called with either the original C<NAME> or the L<File::Handle> that was
  returned from the original call to temp_acquire.
  
  Subsequent attempts to call C<temp_acquire()> with the same C<NAME> will fail
  unless there has been an intervening C<temp_release()> call for that C<NAME>
  (or its corresponding L<File::Handle> that was returned by the original
  C<temp_acquire()> call).
  
  If true is returned by C<temp_is_locked()> for a C<NAME>, an attempt to
  C<temp_acquire()> the same C<NAME> will cause an error unless
  C<temp_release> is first called on that C<NAME> (or its corresponding
  L<File::Handle> that was returned by the original C<temp_acquire()> call).
  
  =cut
  
  sub temp_is_locked {
  	my ($self, $name) = _maybe_self(@_);
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  
  	defined $$temp_fd && $$temp_fd->opened && $TEMP_FILES{$$temp_fd}{locked};
  }
  
  =item temp_release ( NAME )
  
  =item temp_release ( FILEHANDLE )
  
  Releases a lock acquired through C<temp_acquire()>. Can be called either with
  the C<NAME> mapping used when acquiring the temp file or with the C<FILEHANDLE>
  referencing a locked temp file.
  
  Warns if an attempt is made to release a file that is not locked.
  
  The temp file will be truncated before being released. This can help to reduce
  disk I/O where the system is smart enough to detect the truncation while data
  is in the output buffers. Beware that after the temp file is released and
  truncated, any operations on that file may fail miserably until it is
  re-acquired. All contents are lost between each release and acquire mapped to
  the same string.
  
  =cut
  
  sub temp_release {
  	my ($self, $temp_fd, $trunc) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILES{$temp_fd};
  	}
  	unless ($TEMP_FILES{$temp_fd}{locked}) {
  		carp "Attempt to release temp file '",
  			$temp_fd, "' that has not been locked";
  	}
  	temp_reset($temp_fd) if $trunc and $temp_fd->opened;
  
  	$TEMP_FILES{$temp_fd}{locked} = 0;
  	undef;
  }
  
  sub _temp_cache {
  	my ($self, $name) = _maybe_self(@_);
  
  	_verify_require();
  
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  	if (defined $$temp_fd and $$temp_fd->opened) {
  		if ($TEMP_FILES{$$temp_fd}{locked}) {
  			throw Error::Simple("Temp file with moniker '" .
  				$name . "' already in use");
  		}
  	} else {
  		if (defined $$temp_fd) {
  			# then we're here because of a closed handle.
  			carp "Temp file '", $name,
  				"' was closed. Opening replacement.";
  		}
  		my $fname;
  
  		my $tmpdir;
  		if (defined $self) {
  			$tmpdir = $self->repo_path();
  		}
  
  		my $n = $name;
  		$n =~ s/\W/_/g; # no strange chars
  
  		($$temp_fd, $fname) = File::Temp::tempfile(
  			"Git_${n}_XXXXXX", UNLINK => 1, DIR => $tmpdir,
  			) or throw Error::Simple("couldn't open new temp file");
  
  		$$temp_fd->autoflush;
  		binmode $$temp_fd;
  		$TEMP_FILES{$$temp_fd}{fname} = $fname;
  	}
  	$$temp_fd;
  }
  
  sub _verify_require {
  	eval { require File::Temp; require File::Spec; };
  	$@ and throw Error::Simple($@);
  }
  
  =item temp_reset ( FILEHANDLE )
  
  Truncates and resets the position of the C<FILEHANDLE>.
  
  =cut
  
  sub temp_reset {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	truncate $temp_fd, 0
  		or throw Error::Simple("couldn't truncate file");
  	sysseek($temp_fd, 0, SEEK_SET) and seek($temp_fd, 0, SEEK_SET)
  		or throw Error::Simple("couldn't seek to beginning of file");
  	sysseek($temp_fd, 0, SEEK_CUR) == 0 and tell($temp_fd) == 0
  		or throw Error::Simple("expected file position to be reset");
  }
  
  =item temp_path ( NAME )
  
  =item temp_path ( FILEHANDLE )
  
  Returns the filename associated with the given tempfile.
  
  =cut
  
  sub temp_path {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILEMAP{$temp_fd};
  	}
  	$TEMP_FILES{$temp_fd}{fname};
  }
  
  sub END {
  	unlink values %TEMP_FILEMAP if %TEMP_FILEMAP;
  }
  
  } # %TEMP_* Lexical Context
  
  =item prefix_lines ( PREFIX, STRING [, STRING... ])
  
  Prefixes lines in C<STRING> with C<PREFIX>.
  
  =cut
  
  sub prefix_lines {
  	my $prefix = shift;
  	my $string = join("\n", @_);
  	$string =~ s/^/$prefix/mg;
  	return $string;
  }
  
  =item unquote_path ( PATH )
  
  Unquote a quoted path containing c-escapes as returned by ls-files etc.
  when not using -z or when parsing the output of diff -u.
  
  =cut
  
  {
  	my %cquote_map = (
  		"a" => chr(7),
  		"b" => chr(8),
  		"t" => chr(9),
  		"n" => chr(10),
  		"v" => chr(11),
  		"f" => chr(12),
  		"r" => chr(13),
  		"\\" => "\\",
  		"\042" => "\042",
  	);
  
  	sub unquote_path {
  		local ($_) = @_;
  		my ($retval, $remainder);
  		if (!/^\042(.*)\042$/) {
  			return $_;
  		}
  		($_, $retval) = ($1, "");
  		while (/^([^\\]*)\\(.*)$/) {
  			$remainder = $2;
  			$retval .= $1;
  			for ($remainder) {
  				if (/^([0-3][0-7][0-7])(.*)$/) {
  					$retval .= chr(oct($1));
  					$_ = $2;
  					last;
  				}
  				if (/^([\\\042abtnvfr])(.*)$/) {
  					$retval .= $cquote_map{$1};
  					$_ = $2;
  					last;
  				}
  				# This is malformed
  				throw Error::Simple("invalid quoted path $_[0]");
  			}
  			$_ = $remainder;
  		}
  		$retval .= $_;
  		return $retval;
  	}
  }
  
  =item get_comment_line_char ( )
  
  Gets the core.commentchar configuration value.
  The value falls-back to '#' if core.commentchar is set to 'auto'.
  
  =cut
  
  sub get_comment_line_char {
  	my $comment_line_char = config("core.commentchar") || '#';
  	$comment_line_char = '#' if ($comment_line_char eq 'auto');
  	$comment_line_char = '#' if (length($comment_line_char) != 1);
  	return $comment_line_char;
  }
  
  =item comment_lines ( STRING [, STRING... ])
  
  Comments lines following core.commentchar configuration.
  
  =cut
  
  sub comment_lines {
  	my $comment_line_char = get_comment_line_char;
  	return prefix_lines("$comment_line_char ", @_);
  }
  
  =back
  
  =head1 ERROR HANDLING
  
  All functions are supposed to throw Perl exceptions in case of errors.
  See the L<Error> module on how to catch those. Most exceptions are mere
  L<Error::Simple> instances.
  
  However, the C<command()>, C<command_oneline()> and C<command_noisy()>
  functions suite can throw C<Git::Error::Command> exceptions as well: those are
  thrown when the external command returns an error code and contain the error
  code as well as access to the captured command's output. The exception class
  provides the usual C<stringify> and C<value> (command's exit code) methods and
  in addition also a C<cmd_output> method that returns either an array or a
  string with the captured command output (depending on the original function
  call context; C<command_noisy()> returns C<undef>) and $<cmdline> which
  returns the command and its arguments (but without proper quoting).
  
  Note that the C<command_*_pipe()> functions cannot throw this exception since
  it has no idea whether the command failed or not. You will only find out
  at the time you C<close> the pipe; if you want to have that automated,
  use C<command_close_pipe()>, which can throw the exception.
  
  =cut
  
  {
  	package Git::Error::Command;
  
  	@Git::Error::Command::ISA = qw(Error);
  
  	sub new {
  		my $self = shift;
  		my $cmdline = '' . shift;
  		my $value = 0 + shift;
  		my $outputref = shift;
  		my(@args) = ();
  
  		local $Error::Depth = $Error::Depth + 1;
  
  		push(@args, '-cmdline', $cmdline);
  		push(@args, '-value', $value);
  		push(@args, '-outputref', $outputref);
  
  		$self->SUPER::new(-text => 'command returned error', @args);
  	}
  
  	sub stringify {
  		my $self = shift;
  		my $text = $self->SUPER::stringify;
  		$self->cmdline() . ': ' . $text . ': ' . $self->value() . "\n";
  	}
  
  	sub cmdline {
  		my $self = shift;
  		$self->{'-cmdline'};
  	}
  
  	sub cmd_output {
  		my $self = shift;
  		my $ref = $self->{'-outputref'};
  		defined $ref or undef;
  		if (ref $ref eq 'ARRAY') {
  			return @$ref;
  		} else { # SCALAR
  			return $$ref;
  		}
  	}
  }
  
  =over 4
  
  =item git_cmd_try { CODE } ERRMSG
  
  This magical statement will automatically catch any C<Git::Error::Command>
  exceptions thrown by C<CODE> and make your program die with C<ERRMSG>
  on its lips; the message will have %s substituted for the command line
  and %d for the exit status. This statement is useful mostly for producing
  more user-friendly error messages.
  
  In case of no exception caught the statement returns C<CODE>'s return value.
  
  Note that this is the only auto-exported function.
  
  =cut
  
  sub git_cmd_try(&$) {
  	my ($code, $errmsg) = @_;
  	my @result;
  	my $err;
  	my $array = wantarray;
  	try {
  		if ($array) {
  			@result = &$code;
  		} else {
  			$result[0] = &$code;
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		$err = $errmsg;
  		$err =~ s/\%s/$E->cmdline()/ge;
  		$err =~ s/\%d/$E->value()/ge;
  		# We can't croak here since Error.pm would mangle
  		# that to Error::Simple.
  	};
  	$err and croak $err;
  	return $array ? @result : $result[0];
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2006 by Petr Baudis E<lt>pasky@suse.czE<gt>.
  
  This module is free software; it may be used, copied, modified
  and distributed under the terms of the GNU General Public Licence,
  either version 2, or (at your option) any later version.
  
  =cut
  
  
  # Take raw method argument list and return ($obj, @args) in case
  # the method was called upon an instance and (undef, @args) if
  # it was called directly.
  sub _maybe_self {
  	UNIVERSAL::isa($_[0], 'Git') ? @_ : (undef, @_);
  }
  
  # Check if the command id is something reasonable.
  sub _check_valid_cmd {
  	my ($cmd) = @_;
  	$cmd =~ /^[a-z0-9A-Z_-]+$/ or throw Error::Simple("bad command: $cmd");
  }
  
  # Common backend for the pipe creators.
  sub _command_common_pipe {
  	my $direction = shift;
  	my ($self, @p) = _maybe_self(@_);
  	my (%opts, $cmd, @args);
  	if (ref $p[0]) {
  		($cmd, @args) = @{shift @p};
  		%opts = ref $p[0] ? %{$p[0]} : @p;
  	} else {
  		($cmd, @args) = @p;
  	}
  	_check_valid_cmd($cmd);
  
  	my $fh;
  	if ($^O eq 'MSWin32') {
  		# ActiveState Perl
  		#defined $opts{STDERR} and
  		#	warn 'ignoring STDERR option - running w/ ActiveState';
  		$direction eq '-|' or
  			die 'input pipe for ActiveState not implemented';
  		# the strange construction with *ACPIPE is just to
  		# explain the tie below that we want to bind to
  		# a handle class, not scalar. It is not known if
  		# it is something specific to ActiveState Perl or
  		# just a Perl quirk.
  		tie (*ACPIPE, 'Git::activestate_pipe', $cmd, @args);
  		$fh = *ACPIPE;
  
  	} else {
  		my $pid = open($fh, $direction);
  		if (not defined $pid) {
  			throw Error::Simple("open failed: $!");
  		} elsif ($pid == 0) {
  			if ($opts{STDERR}) {
  				open (STDERR, '>&', $opts{STDERR})
  					or die "dup failed: $!";
  			} elsif (defined $opts{STDERR}) {
  				open (STDERR, '>', '/dev/null')
  					or die "opening /dev/null failed: $!";
  			}
  			_cmd_exec($self, $cmd, @args);
  		}
  	}
  	return wantarray ? ($fh, join(' ', $cmd, @args)) : $fh;
  }
  
  # When already in the subprocess, set up the appropriate state
  # for the given repository and execute the git command.
  sub _cmd_exec {
  	my ($self, @args) = @_;
  	_setup_git_cmd_env($self);
  	_execv_git_cmd(@args);
  	die qq[exec "@args" failed: $!];
  }
  
  # set up the appropriate state for git command
  sub _setup_git_cmd_env {
  	my $self = shift;
  	if ($self) {
  		$self->repo_path() and $ENV{'GIT_DIR'} = $self->repo_path();
  		$self->repo_path() and $self->wc_path()
  			and $ENV{'GIT_WORK_TREE'} = $self->wc_path();
  		$self->wc_path() and chdir($self->wc_path());
  		$self->wc_subdir() and chdir($self->wc_subdir());
  	}
  }
  
  # Execute the given Git command ($_[0]) with arguments ($_[1..])
  # by searching for it at proper places.
  sub _execv_git_cmd { exec('git', @_); }
  
  # Close pipe to a subprocess.
  sub _cmd_close {
  	my $ctx = shift @_;
  	foreach my $fh (@_) {
  		if (close $fh) {
  			# nop
  		} elsif ($!) {
  			# It's just close, no point in fatalities
  			carp "error closing pipe: $!";
  		} elsif ($? >> 8) {
  			# The caller should pepper this.
  			throw Git::Error::Command($ctx, $? >> 8);
  		}
  		# else we might e.g. closed a live stream; the command
  		# dying of SIGPIPE would drive us here.
  	}
  }
  
  
  sub DESTROY {
  	my ($self) = @_;
  	$self->_close_hash_and_insert_object();
  	$self->_close_cat_blob();
  }
  
  
  # Pipe implementation for ActiveState Perl.
  
  package Git::activestate_pipe;
  use strict;
  
  sub TIEHANDLE {
  	my ($class, @params) = @_;
  	# FIXME: This is probably horrible idea and the thing will explode
  	# at the moment you give it arguments that require some quoting,
  	# but I have no ActiveState clue... --pasky
  	# Let's just hope ActiveState Perl does at least the quoting
  	# correctly.
  	my @data = qx{git @params};
  	bless { i => 0, data => \@data }, $class;
  }
  
  sub READLINE {
  	my $self = shift;
  	if ($self->{i} >= scalar @{$self->{data}}) {
  		return undef;
  	}
  	my $i = $self->{i};
  	if (wantarray) {
  		$self->{i} = $#{$self->{'data'}} + 1;
  		return splice(@{$self->{'data'}}, $i);
  	}
  	$self->{i} = $i + 1;
  	return $self->{'data'}->[ $i ];
  }
  
  sub CLOSE {
  	my $self = shift;
  	delete $self->{data};
  	delete $self->{i};
  }
  
  sub EOF {
  	my $self = shift;
  	return ($self->{i} >= scalar @{$self->{data}});
  }
  
  
  1; # Famous last words
GIT

$fatpacked{"Git/I18N.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_I18N';
  package Git::I18N;
  use 5.008;
  use strict;
  use warnings;
  BEGIN {
  	require Exporter;
  	if ($] < 5.008003) {
  		*import = \&Exporter::import;
  	} else {
  		# Exporter 5.57 which supports this invocation was
  		# released with perl 5.8.3
  		Exporter->import('import');
  	}
  }
  
  our @EXPORT = qw(__ __n N__);
  our @EXPORT_OK = @EXPORT;
  
  sub __bootstrap_locale_messages {
  	our $TEXTDOMAIN = 'git';
  	our $TEXTDOMAINDIR = $ENV{GIT_TEXTDOMAINDIR} || '++LOCALEDIR++';
  
  	require POSIX;
  	POSIX->import(qw(setlocale));
  	# Non-core prerequisite module
  	require Locale::Messages;
  	Locale::Messages->import(qw(:locale_h :libintl_h));
  
  	setlocale(LC_MESSAGES(), '');
  	setlocale(LC_CTYPE(), '');
  	textdomain($TEXTDOMAIN);
  	bindtextdomain($TEXTDOMAIN => $TEXTDOMAINDIR);
  
  	return;
  }
  
  BEGIN
  {
  	# Used by our test script to see if it should test fallbacks or
  	# not.
  	our $__HAS_LIBRARY = 1;
  
  	local $@;
  	eval {
  		__bootstrap_locale_messages();
  		*__ = \&Locale::Messages::gettext;
  		*__n = \&Locale::Messages::ngettext;
  		1;
  	} or do {
  		# Tell test.pl that we couldn't load the gettext library.
  		$Git::I18N::__HAS_LIBRARY = 0;
  
  		# Just a fall-through no-op
  		*__ = sub ($) { $_[0] };
  		*__n = sub ($$$) { $_[2] == 1 ? $_[0] : $_[1] };
  	};
  
  	sub N__($) { return shift; }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Git::I18N - Perl interface to Git's Gettext localizations
  
  =head1 SYNOPSIS
  
  	use Git::I18N;
  
  	print __("Welcome to Git!\n");
  
  	printf __("The following error occurred: %s\n"), $error;
  
  	printf __n("committed %d file\n", "committed %d files\n", $files), $files;
  
  
  =head1 DESCRIPTION
  
  Git's internal Perl interface to gettext via L<Locale::Messages>. If
  L<Locale::Messages> can't be loaded (it's not a core module) we
  provide stub passthrough fallbacks.
  
  This is a distilled interface to gettext, see C<info '(gettext)Perl'>
  for the full interface. This module implements only a small part of
  it.
  
  =head1 FUNCTIONS
  
  =head2 __($)
  
  L<Locale::Messages>'s gettext function if all goes well, otherwise our
  passthrough fallback function.
  
  =head2 __n($$$)
  
  L<Locale::Messages>'s ngettext function or passthrough fallback function.
  
  =head2 N__($)
  
  No-operation that only returns its argument. Use this if you want xgettext to
  extract the text to the pot template but do not want to trigger retrival of the
  translation at run time.
  
  =head1 AUTHOR
  
  E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avarab@gmail.com>
  
  =head1 COPYRIGHT
  
  Copyright 2010 E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avarab@gmail.com>
  
  =cut
GIT_I18N

$fatpacked{"Git/IndexInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_INDEXINFO';
  package Git::IndexInfo;
  use strict;
  use warnings;
  use Git qw/command_input_pipe command_close_pipe/;
  
  sub new {
  	my ($class) = @_;
  	my ($gui, $ctx) = command_input_pipe(qw/update-index -z --index-info/);
  	bless { gui => $gui, ctx => $ctx, nr => 0}, $class;
  }
  
  sub remove {
  	my ($self, $path) = @_;
  	if (print { $self->{gui} } '0 ', 0 x 40, "\t", $path, "\0") {
  		return ++$self->{nr};
  	}
  	undef;
  }
  
  sub update {
  	my ($self, $mode, $hash, $path) = @_;
  	if (print { $self->{gui} } $mode, ' ', $hash, "\t", $path, "\0") {
  		return ++$self->{nr};
  	}
  	undef;
  }
  
  sub DESTROY {
  	my ($self) = @_;
  	command_close_pipe($self->{gui}, $self->{ctx});
  }
  
  1;
GIT_INDEXINFO

$fatpacked{"Git/SVN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN';
  package Git::SVN;
  use strict;
  use warnings;
  use Fcntl qw/:DEFAULT :seek/;
  use constant rev_map_fmt => 'NH40';
  use vars qw/$_no_metadata
              $_repack $_repack_flags $_use_svm_props $_head
              $_use_svnsync_props $no_reuse_existing
  	    $_use_log_author $_add_author_from $_localtime/;
  use Carp qw/croak/;
  use File::Path qw/mkpath/;
  use IPC::Open3;
  use Memoize;  # core since 5.8.0, Jul 2002
  use POSIX qw(:signal_h);
  use Time::Local;
  
  use Git qw(
      command
      command_oneline
      command_noisy
      command_output_pipe
      command_close_pipe
      get_tz_offset
  );
  use Git::SVN::Utils qw(
  	fatal
  	can_compress
  	join_paths
  	canonicalize_path
  	canonicalize_url
  	add_path_to_url
  );
  
  my $memo_backend;
  our $_follow_parent  = 1;
  our $_minimize_url   = 'unset';
  our $default_repo_id = 'svn';
  our $default_ref_id  = $ENV{GIT_SVN_ID} || 'git-svn';
  
  my ($_gc_nr, $_gc_period);
  
  # properties that we do not log:
  my %SKIP_PROP;
  BEGIN {
  	%SKIP_PROP = map { $_ => 1 } qw/svn:wc:ra_dav:version-url
  	                                svn:special svn:executable
  	                                svn:entry:committed-rev
  	                                svn:entry:last-author
  	                                svn:entry:uuid
  	                                svn:entry:committed-date/;
  
  	# some options are read globally, but can be overridden locally
  	# per [svn-remote "..."] section.  Command-line options will *NOT*
  	# override options set in an [svn-remote "..."] section
  	no strict 'refs';
  	for my $option (qw/follow_parent no_metadata use_svm_props
  			   use_svnsync_props/) {
  		my $key = $option;
  		$key =~ tr/_//d;
  		my $prop = "-$option";
  		*$option = sub {
  			my ($self) = @_;
  			return $self->{$prop} if exists $self->{$prop};
  			my $k = "svn-remote.$self->{repo_id}.$key";
  			eval { command_oneline(qw/config --get/, $k) };
  			if ($@) {
  				$self->{$prop} = ${"Git::SVN::_$option"};
  			} else {
  				my $v = command_oneline(qw/config --bool/,$k);
  				$self->{$prop} = $v eq 'false' ? 0 : 1;
  			}
  			return $self->{$prop};
  		}
  	}
  }
  
  
  my (%LOCKFILES, %INDEX_FILES);
  END {
  	unlink keys %LOCKFILES if %LOCKFILES;
  	unlink keys %INDEX_FILES if %INDEX_FILES;
  }
  
  sub resolve_local_globs {
  	my ($url, $fetch, $glob_spec) = @_;
  	return unless defined $glob_spec;
  	my $ref = $glob_spec->{ref};
  	my $path = $glob_spec->{path};
  	foreach (command(qw#for-each-ref --format=%(refname) refs/#)) {
  		next unless m#^$ref->{regex}$#;
  		my $p = $1;
  		my $pathname = desanitize_refname($path->full_path($p));
  		my $refname = desanitize_refname($ref->full_path($p));
  		if (my $existing = $fetch->{$pathname}) {
  			if ($existing ne $refname) {
  				die "Refspec conflict:\n",
  				    "existing: $existing\n",
  				    " globbed: $refname\n";
  			}
  			my $u = (::cmt_metadata("$refname"))[0];
  			if (!defined($u)) {
  				warn
  "W: $refname: no associated commit metadata from SVN, skipping\n";
  				next;
  			}
  			$u =~ s!^\Q$url\E(/|$)!! or die
  			  "$refname: '$url' not found in '$u'\n";
  			if ($pathname ne $u) {
  				warn "W: Refspec glob conflict ",
  				     "(ref: $refname):\n",
  				     "expected path: $pathname\n",
  				     "    real path: $u\n",
  				     "Continuing ahead with $u\n";
  				next;
  			}
  		} else {
  			$fetch->{$pathname} = $refname;
  		}
  	}
  }
  
  sub parse_revision_argument {
  	my ($base, $head) = @_;
  	if (!defined $::_revision || $::_revision eq 'BASE:HEAD') {
  		return ($base, $head);
  	}
  	return ($1, $2) if ($::_revision =~ /^(\d+):(\d+)$/);
  	return ($::_revision, $::_revision) if ($::_revision =~ /^\d+$/);
  	return ($head, $head) if ($::_revision eq 'HEAD');
  	return ($base, $1) if ($::_revision =~ /^BASE:(\d+)$/);
  	return ($1, $head) if ($::_revision =~ /^(\d+):HEAD$/);
  	die "revision argument: $::_revision not understood by git-svn\n";
  }
  
  sub fetch_all {
  	my ($repo_id, $remotes) = @_;
  	if (ref $repo_id) {
  		my $gs = $repo_id;
  		$repo_id = undef;
  		$repo_id = $gs->{repo_id};
  	}
  	$remotes ||= read_all_remotes();
  	my $remote = $remotes->{$repo_id} or
  	             die "[svn-remote \"$repo_id\"] unknown\n";
  	my $fetch = $remote->{fetch};
  	my $url = $remote->{url} or die "svn-remote.$repo_id.url not defined\n";
  	my (@gs, @globs);
  	my $ra = Git::SVN::Ra->new($url);
  	my $uuid = $ra->get_uuid;
  	my $head = $ra->get_latest_revnum;
  
  	# ignore errors, $head revision may not even exist anymore
  	eval { $ra->get_log("", $head, 0, 1, 0, 1, sub { $head = $_[1] }) };
  	warn "W: $@\n" if $@;
  
  	my $base = defined $fetch ? $head : 0;
  
  	# read the max revs for wildcard expansion (branches/*, tags/*)
  	foreach my $t (qw/branches tags/) {
  		defined $remote->{$t} or next;
  		push @globs, @{$remote->{$t}};
  
  		my $max_rev = eval { tmp_config(qw/--int --get/,
  		                         "svn-remote.$repo_id.${t}-maxRev") };
  		if (defined $max_rev && ($max_rev < $base)) {
  			$base = $max_rev;
  		} elsif (!defined $max_rev) {
  			$base = 0;
  		}
  	}
  
  	if ($fetch) {
  		foreach my $p (sort keys %$fetch) {
  			my $gs = Git::SVN->new($fetch->{$p}, $repo_id, $p);
  			my $lr = $gs->rev_map_max;
  			if (defined $lr) {
  				$base = $lr if ($lr < $base);
  			}
  			push @gs, $gs;
  		}
  	}
  
  	($base, $head) = parse_revision_argument($base, $head);
  	$ra->gs_fetch_loop_common($base, $head, \@gs, \@globs);
  }
  
  sub read_all_remotes {
  	my $r = {};
  	my $use_svm_props = eval { command_oneline(qw/config --bool
  	    svn.useSvmProps/) };
  	$use_svm_props = $use_svm_props eq 'true' if $use_svm_props;
  	my $svn_refspec = qr{\s*(.*?)\s*:\s*(.+?)\s*};
  	foreach (grep { s/^svn-remote\.// } command(qw/config -l/)) {
  		if (m!^(.+)\.fetch=$svn_refspec$!) {
  			my ($remote, $local_ref, $remote_ref) = ($1, $2, $3);
  			die("svn-remote.$remote: remote ref '$remote_ref' "
  			    . "must start with 'refs/'\n")
  				unless $remote_ref =~ m{^refs/};
  			$local_ref = uri_decode($local_ref);
  			$r->{$remote}->{fetch}->{$local_ref} = $remote_ref;
  			$r->{$remote}->{svm} = {} if $use_svm_props;
  		} elsif (m!^(.+)\.usesvmprops=\s*(.*)\s*$!) {
  			$r->{$1}->{svm} = {};
  		} elsif (m!^(.+)\.url=\s*(.*)\s*$!) {
  			$r->{$1}->{url} = canonicalize_url($2);
  		} elsif (m!^(.+)\.pushurl=\s*(.*)\s*$!) {
  			$r->{$1}->{pushurl} = canonicalize_url($2);
  		} elsif (m!^(.+)\.ignore-refs=\s*(.*)\s*$!) {
  			$r->{$1}->{ignore_refs_regex} = $2;
  		} elsif (m!^(.+)\.(branches|tags)=$svn_refspec$!) {
  			my ($remote, $t, $local_ref, $remote_ref) =
  			                                     ($1, $2, $3, $4);
  			die("svn-remote.$remote: remote ref '$remote_ref' ($t) "
  			    . "must start with 'refs/'\n")
  				unless $remote_ref =~ m{^refs/};
  			$local_ref = uri_decode($local_ref);
  
  			require Git::SVN::GlobSpec;
  			my $rs = {
  			    t => $t,
  			    remote => $remote,
  			    path => Git::SVN::GlobSpec->new($local_ref, 1),
  			    ref => Git::SVN::GlobSpec->new($remote_ref, 0) };
  			if (length($rs->{ref}->{right}) != 0) {
  				die "The '*' glob character must be the last ",
  				    "character of '$remote_ref'\n";
  			}
  			push @{ $r->{$remote}->{$t} }, $rs;
  		}
  	}
  
  	map {
  		if (defined $r->{$_}->{svm}) {
  			my $svm;
  			eval {
  				my $section = "svn-remote.$_";
  				$svm = {
  					source => tmp_config('--get',
  					    "$section.svm-source"),
  					replace => tmp_config('--get',
  					    "$section.svm-replace"),
  				}
  			};
  			$r->{$_}->{svm} = $svm;
  		}
  	} keys %$r;
  
  	foreach my $remote (keys %$r) {
  		foreach ( grep { defined $_ }
  			  map { $r->{$remote}->{$_} } qw(branches tags) ) {
  			foreach my $rs ( @$_ ) {
  				$rs->{ignore_refs_regex} =
  				    $r->{$remote}->{ignore_refs_regex};
  			}
  		}
  	}
  
  	$r;
  }
  
  sub init_vars {
  	$_gc_nr = $_gc_period = 1000;
  	if (defined $_repack || defined $_repack_flags) {
  	       warn "Repack options are obsolete; they have no effect.\n";
  	}
  }
  
  sub verify_remotes_sanity {
  	return unless -d $ENV{GIT_DIR};
  	my %seen;
  	foreach (command(qw/config -l/)) {
  		if (m!^svn-remote\.(?:.+)\.fetch=.*:refs/remotes/(\S+)\s*$!) {
  			if ($seen{$1}) {
  				die "Remote ref refs/remote/$1 is tracked by",
  				    "\n  \"$_\"\nand\n  \"$seen{$1}\"\n",
  				    "Please resolve this ambiguity in ",
  				    "your git configuration file before ",
  				    "continuing\n";
  			}
  			$seen{$1} = $_;
  		}
  	}
  }
  
  sub find_existing_remote {
  	my ($url, $remotes) = @_;
  	return undef if $no_reuse_existing;
  	my $existing;
  	foreach my $repo_id (keys %$remotes) {
  		my $u = $remotes->{$repo_id}->{url} or next;
  		next if $u ne $url;
  		$existing = $repo_id;
  		last;
  	}
  	$existing;
  }
  
  sub init_remote_config {
  	my ($self, $url, $no_write) = @_;
  	$url = canonicalize_url($url);
  	my $r = read_all_remotes();
  	my $existing = find_existing_remote($url, $r);
  	if ($existing) {
  		unless ($no_write) {
  			print STDERR "Using existing ",
  				     "[svn-remote \"$existing\"]\n";
  		}
  		$self->{repo_id} = $existing;
  	} elsif ($_minimize_url) {
  		my $min_url = Git::SVN::Ra->new($url)->minimize_url;
  		$existing = find_existing_remote($min_url, $r);
  		if ($existing) {
  			unless ($no_write) {
  				print STDERR "Using existing ",
  					     "[svn-remote \"$existing\"]\n";
  			}
  			$self->{repo_id} = $existing;
  		}
  		if ($min_url ne $url) {
  			unless ($no_write) {
  				print STDERR "Using higher level of URL: ",
  					     "$url => $min_url\n";
  			}
  			my $old_path = $self->path;
  			$url =~ s!^\Q$min_url\E(/|$)!!;
  			$url = join_paths($url, $old_path);
  			$self->path($url);
  			$url = $min_url;
  		}
  	}
  	my $orig_url;
  	if (!$existing) {
  		# verify that we aren't overwriting anything:
  		$orig_url = eval {
  			command_oneline('config', '--get',
  					"svn-remote.$self->{repo_id}.url")
  		};
  		if ($orig_url && ($orig_url ne $url)) {
  			die "svn-remote.$self->{repo_id}.url already set: ",
  			    "$orig_url\nwanted to set to: $url\n";
  		}
  	}
  	my ($xrepo_id, $xpath) = find_ref($self->refname);
  	if (!$no_write && defined $xpath) {
  		die "svn-remote.$xrepo_id.fetch already set to track ",
  		    "$xpath:", $self->refname, "\n";
  	}
  	unless ($no_write) {
  		command_noisy('config',
  			      "svn-remote.$self->{repo_id}.url", $url);
  		my $path = $self->path;
  		$path =~ s{^/}{};
  		$path =~ s{%([0-9A-F]{2})}{chr hex($1)}ieg;
  		$self->path($path);
  		command_noisy('config', '--add',
  			      "svn-remote.$self->{repo_id}.fetch",
  			      $self->path.":".$self->refname);
  	}
  	$self->url($url);
  }
  
  sub find_by_url { # repos_root and, path are optional
  	my ($class, $full_url, $repos_root, $path) = @_;
  
  	$full_url = canonicalize_url($full_url);
  
  	return undef unless defined $full_url;
  	remove_username($full_url);
  	remove_username($repos_root) if defined $repos_root;
  	my $remotes = read_all_remotes();
  	if (defined $full_url && defined $repos_root && !defined $path) {
  		$path = $full_url;
  		$path =~ s#^\Q$repos_root\E(?:/|$)##;
  	}
  	foreach my $repo_id (keys %$remotes) {
  		my $u = $remotes->{$repo_id}->{url} or next;
  		remove_username($u);
  		next if defined $repos_root && $repos_root ne $u;
  
  		my $fetch = $remotes->{$repo_id}->{fetch} || {};
  		foreach my $t (qw/branches tags/) {
  			foreach my $globspec (@{$remotes->{$repo_id}->{$t}}) {
  				resolve_local_globs($u, $fetch, $globspec);
  			}
  		}
  		my $p = $path;
  		my $rwr = rewrite_root({repo_id => $repo_id});
  		my $svm = $remotes->{$repo_id}->{svm}
  			if defined $remotes->{$repo_id}->{svm};
  		unless (defined $p) {
  			$p = $full_url;
  			my $z = $u;
  			my $prefix = '';
  			if ($rwr) {
  				$z = $rwr;
  				remove_username($z);
  			} elsif (defined $svm) {
  				$z = $svm->{source};
  				$prefix = $svm->{replace};
  				$prefix =~ s#^\Q$u\E(?:/|$)##;
  				$prefix =~ s#/$##;
  			}
  			$p =~ s#^\Q$z\E(?:/|$)#$prefix# or next;
  		}
  
  		# remote fetch paths are not URI escaped.  Decode ours
  		# so they match
  		$p = uri_decode($p);
  
  		foreach my $f (keys %$fetch) {
  			next if $f ne $p;
  			return Git::SVN->new($fetch->{$f}, $repo_id, $f);
  		}
  	}
  	undef;
  }
  
  sub init {
  	my ($class, $url, $path, $repo_id, $ref_id, $no_write) = @_;
  	my $self = _new($class, $repo_id, $ref_id, $path);
  	if (defined $url) {
  		$self->init_remote_config($url, $no_write);
  	}
  	$self;
  }
  
  sub find_ref {
  	my ($ref_id) = @_;
  	foreach (command(qw/config -l/)) {
  		next unless m!^svn-remote\.(.+)\.fetch=
  		              \s*(.*?)\s*:\s*(.+?)\s*$!x;
  		my ($repo_id, $path, $ref) = ($1, $2, $3);
  		if ($ref eq $ref_id) {
  			$path = '' if ($path =~ m#^\./?#);
  			return ($repo_id, $path);
  		}
  	}
  	(undef, undef, undef);
  }
  
  sub new {
  	my ($class, $ref_id, $repo_id, $path) = @_;
  	if (defined $ref_id && !defined $repo_id && !defined $path) {
  		($repo_id, $path) = find_ref($ref_id);
  		if (!defined $repo_id) {
  			die "Could not find a \"svn-remote.*.fetch\" key ",
  			    "in the repository configuration matching: ",
  			    "$ref_id\n";
  		}
  	}
  	my $self = _new($class, $repo_id, $ref_id, $path);
  	if (!defined $self->path || !length $self->path) {
  		my $fetch = command_oneline('config', '--get',
  		                            "svn-remote.$repo_id.fetch",
  		                            ":$ref_id\$") or
  		     die "Failed to read \"svn-remote.$repo_id.fetch\" ",
  		         "\":$ref_id\$\" in config\n";
  		my($path) = split(/\s*:\s*/, $fetch);
  		$self->path($path);
  	}
  	{
  		my $path = $self->path;
  		$path =~ s{\A/}{};
  		$path =~ s{/\z}{};
  		$self->path($path);
  	}
  	my $url = command_oneline('config', '--get',
  	                          "svn-remote.$repo_id.url") or
                    die "Failed to read \"svn-remote.$repo_id.url\" in config\n";
  	$self->url($url);
  	$self->{pushurl} = eval { command_oneline('config', '--get',
  	                          "svn-remote.$repo_id.pushurl") };
  	$self->rebuild;
  	$self;
  }
  
  sub refname {
  	my ($refname) = $_[0]->{ref_id} ;
  
  	# It cannot end with a slash /, we'll throw up on this because
  	# SVN can't have directories with a slash in their name, either:
  	if ($refname =~ m{/$}) {
  		die "ref: '$refname' ends with a trailing slash; this is ",
  		    "not permitted by git or Subversion\n";
  	}
  
  	# It cannot have ASCII control character space, tilde ~, caret ^,
  	# colon :, question-mark ?, asterisk *, space, or open bracket [
  	# anywhere.
  	#
  	# Additionally, % must be escaped because it is used for escaping
  	# and we want our escaped refname to be reversible
  	$refname =~ s{([ \%~\^:\?\*\[\t\\])}{sprintf('%%%02X',ord($1))}eg;
  
  	# no slash-separated component can begin with a dot .
  	# /.* becomes /%2E*
  	$refname =~ s{/\.}{/%2E}g;
  
  	# It cannot have two consecutive dots .. anywhere
  	# .. becomes %2E%2E
  	$refname =~ s{\.\.}{%2E%2E}g;
  
  	# trailing dots and .lock are not allowed
  	# .$ becomes %2E and .lock becomes %2Elock
  	$refname =~ s{\.(?=$|lock$)}{%2E};
  
  	# the sequence @{ is used to access the reflog
  	# @{ becomes %40{
  	$refname =~ s{\@\{}{%40\{}g;
  
  	return $refname;
  }
  
  sub desanitize_refname {
  	my ($refname) = @_;
  	$refname =~ s{%(?:([0-9A-F]{2}))}{chr hex($1)}eg;
  	return $refname;
  }
  
  sub svm_uuid {
  	my ($self) = @_;
  	return $self->{svm}->{uuid} if $self->svm;
  	$self->ra;
  	unless ($self->{svm}) {
  		die "SVM UUID not cached, and reading remotely failed\n";
  	}
  	$self->{svm}->{uuid};
  }
  
  sub svm {
  	my ($self) = @_;
  	return $self->{svm} if $self->{svm};
  	my $svm;
  	# see if we have it in our config, first:
  	eval {
  		my $section = "svn-remote.$self->{repo_id}";
  		$svm = {
  		  source => tmp_config('--get', "$section.svm-source"),
  		  uuid => tmp_config('--get', "$section.svm-uuid"),
  		  replace => tmp_config('--get', "$section.svm-replace"),
  		}
  	};
  	if ($svm && $svm->{source} && $svm->{uuid} && $svm->{replace}) {
  		$self->{svm} = $svm;
  	}
  	$self->{svm};
  }
  
  sub _set_svm_vars {
  	my ($self, $ra) = @_;
  	return $ra if $self->svm;
  
  	my @err = ( "useSvmProps set, but failed to read SVM properties\n",
  		    "(svm:source, svm:uuid) ",
  		    "from the following URLs:\n" );
  	sub read_svm_props {
  		my ($self, $ra, $path, $r) = @_;
  		my $props = ($ra->get_dir($path, $r))[2];
  		my $src = $props->{'svm:source'};
  		my $uuid = $props->{'svm:uuid'};
  		return undef if (!$src || !$uuid);
  
  		chomp($src, $uuid);
  
  		$uuid =~ m{^[0-9a-f\-]{30,}$}i
  		    or die "doesn't look right - svm:uuid is '$uuid'\n";
  
  		# the '!' is used to mark the repos_root!/relative/path
  		$src =~ s{/?!/?}{/};
  		$src =~ s{/+$}{}; # no trailing slashes please
  		# username is of no interest
  		$src =~ s{(^[a-z\+]*://)[^/@]*@}{$1};
  
  		my $replace = add_path_to_url($ra->url, $path);
  
  		my $section = "svn-remote.$self->{repo_id}";
  		tmp_config("$section.svm-source", $src);
  		tmp_config("$section.svm-replace", $replace);
  		tmp_config("$section.svm-uuid", $uuid);
  		$self->{svm} = {
  			source => $src,
  			uuid => $uuid,
  			replace => $replace
  		};
  	}
  
  	my $r = $ra->get_latest_revnum;
  	my $path = $self->path;
  	my %tried;
  	while (length $path) {
  		my $try = add_path_to_url($self->url, $path);
  		unless ($tried{$try}) {
  			return $ra if $self->read_svm_props($ra, $path, $r);
  			$tried{$try} = 1;
  		}
  		$path =~ s#/?[^/]+$##;
  	}
  	die "Path: '$path' should be ''\n" if $path ne '';
  	return $ra if $self->read_svm_props($ra, $path, $r);
  	$tried{ add_path_to_url($self->url, $path) } = 1;
  
  	if ($ra->{repos_root} eq $self->url) {
  		die @err, (map { "  $_\n" } keys %tried), "\n";
  	}
  
  	# nope, make sure we're connected to the repository root:
  	my $ok;
  	my @tried_b;
  	$path = $ra->{svn_path};
  	$ra = Git::SVN::Ra->new($ra->{repos_root});
  	while (length $path) {
  		my $try = add_path_to_url($ra->url, $path);
  		unless ($tried{$try}) {
  			$ok = $self->read_svm_props($ra, $path, $r);
  			last if $ok;
  			$tried{$try} = 1;
  		}
  		$path =~ s#/?[^/]+$##;
  	}
  	die "Path: '$path' should be ''\n" if $path ne '';
  	$ok ||= $self->read_svm_props($ra, $path, $r);
  	$tried{ add_path_to_url($ra->url, $path) } = 1;
  	if (!$ok) {
  		die @err, (map { "  $_\n" } keys %tried), "\n";
  	}
  	Git::SVN::Ra->new($self->url);
  }
  
  sub svnsync {
  	my ($self) = @_;
  	return $self->{svnsync} if $self->{svnsync};
  
  	if ($self->no_metadata) {
  		die "Can't have both 'noMetadata' and ",
  		    "'useSvnsyncProps' options set!\n";
  	}
  	if ($self->rewrite_root) {
  		die "Can't have both 'useSvnsyncProps' and 'rewriteRoot' ",
  		    "options set!\n";
  	}
  	if ($self->rewrite_uuid) {
  		die "Can't have both 'useSvnsyncProps' and 'rewriteUUID' ",
  		    "options set!\n";
  	}
  
  	my $svnsync;
  	# see if we have it in our config, first:
  	eval {
  		my $section = "svn-remote.$self->{repo_id}";
  
  		my $url = tmp_config('--get', "$section.svnsync-url");
  		($url) = ($url =~ m{^([a-z\+]+://\S+)$}) or
  		   die "doesn't look right - svn:sync-from-url is '$url'\n";
  
  		my $uuid = tmp_config('--get', "$section.svnsync-uuid");
  		($uuid) = ($uuid =~ m{^([0-9a-f\-]{30,})$}i) or
  		   die "doesn't look right - svn:sync-from-uuid is '$uuid'\n";
  
  		$svnsync = { url => $url, uuid => $uuid }
  	};
  	if ($svnsync && $svnsync->{url} && $svnsync->{uuid}) {
  		return $self->{svnsync} = $svnsync;
  	}
  
  	my $err = "useSvnsyncProps set, but failed to read " .
  	          "svnsync property: svn:sync-from-";
  	my $rp = $self->ra->rev_proplist(0);
  
  	my $url = $rp->{'svn:sync-from-url'} or die $err . "url\n";
  	($url) = ($url =~ m{^([a-z\+]+://\S+)$}) or
  	           die "doesn't look right - svn:sync-from-url is '$url'\n";
  
  	my $uuid = $rp->{'svn:sync-from-uuid'} or die $err . "uuid\n";
  	($uuid) = ($uuid =~ m{^([0-9a-f\-]{30,})$}i) or
  	           die "doesn't look right - svn:sync-from-uuid is '$uuid'\n";
  
  	my $section = "svn-remote.$self->{repo_id}";
  	tmp_config('--add', "$section.svnsync-uuid", $uuid);
  	tmp_config('--add', "$section.svnsync-url", $url);
  	return $self->{svnsync} = { url => $url, uuid => $uuid };
  }
  
  # this allows us to memoize our SVN::Ra UUID locally and avoid a
  # remote lookup (useful for 'git svn log').
  sub ra_uuid {
  	my ($self) = @_;
  	unless ($self->{ra_uuid}) {
  		my $key = "svn-remote.$self->{repo_id}.uuid";
  		my $uuid = eval { tmp_config('--get', $key) };
  		if (!$@ && $uuid && $uuid =~ /^([a-f\d\-]{30,})$/i) {
  			$self->{ra_uuid} = $uuid;
  		} else {
  			die "ra_uuid called without URL\n" unless $self->url;
  			$self->{ra_uuid} = $self->ra->get_uuid;
  			tmp_config('--add', $key, $self->{ra_uuid});
  		}
  	}
  	$self->{ra_uuid};
  }
  
  sub _set_repos_root {
  	my ($self, $repos_root) = @_;
  	my $k = "svn-remote.$self->{repo_id}.reposRoot";
  	$repos_root ||= $self->ra->{repos_root};
  	tmp_config($k, $repos_root);
  	$repos_root;
  }
  
  sub repos_root {
  	my ($self) = @_;
  	my $k = "svn-remote.$self->{repo_id}.reposRoot";
  	eval { tmp_config('--get', $k) } || $self->_set_repos_root;
  }
  
  sub ra {
  	my ($self) = shift;
  	my $ra = Git::SVN::Ra->new($self->url);
  	$self->_set_repos_root($ra->{repos_root});
  	if ($self->use_svm_props && !$self->{svm}) {
  		if ($self->no_metadata) {
  			die "Can't have both 'noMetadata' and ",
  			    "'useSvmProps' options set!\n";
  		} elsif ($self->use_svnsync_props) {
  			die "Can't have both 'useSvnsyncProps' and ",
  			    "'useSvmProps' options set!\n";
  		}
  		$ra = $self->_set_svm_vars($ra);
  		$self->{-want_revprops} = 1;
  	}
  	$ra;
  }
  
  # prop_walk(PATH, REV, SUB)
  # -------------------------
  # Recursively traverse PATH at revision REV and invoke SUB for each
  # directory that contains a SVN property.  SUB will be invoked as
  # follows:  &SUB(gs, path, props);  where `gs' is this instance of
  # Git::SVN, `path' the path to the directory where the properties
  # `props' were found.  The `path' will be relative to point of checkout,
  # that is, if url://repo/trunk is the current Git branch, and that
  # directory contains a sub-directory `d', SUB will be invoked with `/d/'
  # as `path' (note the trailing `/').
  sub prop_walk {
  	my ($self, $path, $rev, $sub) = @_;
  
  	$path =~ s#^/##;
  	my ($dirent, undef, $props) = $self->ra->get_dir($path, $rev);
  	$path =~ s#^/*#/#g;
  	my $p = $path;
  	# Strip the irrelevant part of the path.
  	$p =~ s#^/+\Q@{[$self->path]}\E(/|$)#/#;
  	# Ensure the path is terminated by a `/'.
  	$p =~ s#/*$#/#;
  
  	# The properties contain all the internal SVN stuff nobody
  	# (usually) cares about.
  	my $interesting_props = 0;
  	foreach (keys %{$props}) {
  		# If it doesn't start with `svn:', it must be a
  		# user-defined property.
  		++$interesting_props and next if $_ !~ /^svn:/;
  		# FIXME: Fragile, if SVN adds new public properties,
  		# this needs to be updated.
  		++$interesting_props if /^svn:(?:ignore|keywords|executable
  		                                 |eol-style|mime-type
  						 |externals|needs-lock)$/x;
  	}
  	&$sub($self, $p, $props) if $interesting_props;
  
  	foreach (sort keys %$dirent) {
  		next if $dirent->{$_}->{kind} != $SVN::Node::dir;
  		$self->prop_walk($self->path . $p . $_, $rev, $sub);
  	}
  }
  
  sub last_rev { ($_[0]->last_rev_commit)[0] }
  sub last_commit { ($_[0]->last_rev_commit)[1] }
  
  # returns the newest SVN revision number and newest commit SHA1
  sub last_rev_commit {
  	my ($self) = @_;
  	if (defined $self->{last_rev} && defined $self->{last_commit}) {
  		return ($self->{last_rev}, $self->{last_commit});
  	}
  	my $c = ::verify_ref($self->refname.'^0');
  	if ($c && !$self->use_svm_props && !$self->no_metadata) {
  		my $rev = (::cmt_metadata($c))[1];
  		if (defined $rev) {
  			($self->{last_rev}, $self->{last_commit}) = ($rev, $c);
  			return ($rev, $c);
  		}
  	}
  	my $map_path = $self->map_path;
  	unless (-e $map_path) {
  		($self->{last_rev}, $self->{last_commit}) = (undef, undef);
  		return (undef, undef);
  	}
  	my ($rev, $commit) = $self->rev_map_max(1);
  	($self->{last_rev}, $self->{last_commit}) = ($rev, $commit);
  	return ($rev, $commit);
  }
  
  sub get_fetch_range {
  	my ($self, $min, $max) = @_;
  	$max ||= $self->ra->get_latest_revnum;
  	$min ||= $self->rev_map_max;
  	(++$min, $max);
  }
  
  sub svn_dir {
  	command_oneline(qw(rev-parse --git-path svn));
  }
  
  sub tmp_config {
  	my (@args) = @_;
  	my $svn_dir = svn_dir();
  	my $old_def_config = "$svn_dir/config";
  	my $config = "$svn_dir/.metadata";
  	if (! -f $config && -f $old_def_config) {
  		rename $old_def_config, $config or
  		       die "Failed rename $old_def_config => $config: $!\n";
  	}
  	my $old_config = $ENV{GIT_CONFIG};
  	$ENV{GIT_CONFIG} = $config;
  	$@ = undef;
  	my @ret = eval {
  		unless (-f $config) {
  			mkfile($config);
  			open my $fh, '>', $config or
  			    die "Can't open $config: $!\n";
  			print $fh "; This file is used internally by ",
  			          "git-svn\n" or die
  				  "Couldn't write to $config: $!\n";
  			print $fh "; You should not have to edit it\n" or
  			      die "Couldn't write to $config: $!\n";
  			close $fh or die "Couldn't close $config: $!\n";
  		}
  		command('config', @args);
  	};
  	my $err = $@;
  	if (defined $old_config) {
  		$ENV{GIT_CONFIG} = $old_config;
  	} else {
  		delete $ENV{GIT_CONFIG};
  	}
  	die $err if $err;
  	wantarray ? @ret : $ret[0];
  }
  
  sub tmp_index_do {
  	my ($self, $sub) = @_;
  	my $old_index = $ENV{GIT_INDEX_FILE};
  	$ENV{GIT_INDEX_FILE} = $self->{index};
  	$@ = undef;
  	my @ret = eval {
  		my ($dir, $base) = ($self->{index} =~ m#^(.*?)/?([^/]+)$#);
  		mkpath([$dir]) unless -d $dir;
  		&$sub;
  	};
  	my $err = $@;
  	if (defined $old_index) {
  		$ENV{GIT_INDEX_FILE} = $old_index;
  	} else {
  		delete $ENV{GIT_INDEX_FILE};
  	}
  	die $err if $err;
  	wantarray ? @ret : $ret[0];
  }
  
  sub assert_index_clean {
  	my ($self, $treeish) = @_;
  
  	$self->tmp_index_do(sub {
  		command_noisy('read-tree', $treeish) unless -e $self->{index};
  		my $x = command_oneline('write-tree');
  		my ($y) = (command(qw/cat-file commit/, $treeish) =~
  		           /^tree ($::sha1)/mo);
  		return if $y eq $x;
  
  		warn "Index mismatch: $y != $x\nrereading $treeish\n";
  		unlink $self->{index} or die "unlink $self->{index}: $!\n";
  		command_noisy('read-tree', $treeish);
  		$x = command_oneline('write-tree');
  		if ($y ne $x) {
  			fatal "trees ($treeish) $y != $x\n",
  			      "Something is seriously wrong...";
  		}
  	});
  }
  
  sub get_commit_parents {
  	my ($self, $log_entry) = @_;
  	my (%seen, @ret, @tmp);
  	# legacy support for 'set-tree'; this is only used by set_tree_cb:
  	if (my $ip = $self->{inject_parents}) {
  		if (my $commit = delete $ip->{$log_entry->{revision}}) {
  			push @tmp, $commit;
  		}
  	}
  	if (my $cur = ::verify_ref($self->refname.'^0')) {
  		push @tmp, $cur;
  	}
  	if (my $ipd = $self->{inject_parents_dcommit}) {
  		if (my $commit = delete $ipd->{$log_entry->{revision}}) {
  			push @tmp, @$commit;
  		}
  	}
  	push @tmp, $_ foreach (@{$log_entry->{parents}}, @tmp);
  	while (my $p = shift @tmp) {
  		next if $seen{$p};
  		$seen{$p} = 1;
  		push @ret, $p;
  	}
  	@ret;
  }
  
  sub rewrite_root {
  	my ($self) = @_;
  	return $self->{-rewrite_root} if exists $self->{-rewrite_root};
  	my $k = "svn-remote.$self->{repo_id}.rewriteRoot";
  	my $rwr = eval { command_oneline(qw/config --get/, $k) };
  	if ($rwr) {
  		$rwr =~ s#/+$##;
  		if ($rwr !~ m#^[a-z\+]+://#) {
  			die "$rwr is not a valid URL (key: $k)\n";
  		}
  	}
  	$self->{-rewrite_root} = $rwr;
  }
  
  sub rewrite_uuid {
  	my ($self) = @_;
  	return $self->{-rewrite_uuid} if exists $self->{-rewrite_uuid};
  	my $k = "svn-remote.$self->{repo_id}.rewriteUUID";
  	my $rwid = eval { command_oneline(qw/config --get/, $k) };
  	if ($rwid) {
  		$rwid =~ s#/+$##;
  		if ($rwid !~ m#^[a-f0-9]{8}-(?:[a-f0-9]{4}-){3}[a-f0-9]{12}$#) {
  			die "$rwid is not a valid UUID (key: $k)\n";
  		}
  	}
  	$self->{-rewrite_uuid} = $rwid;
  }
  
  sub metadata_url {
  	my ($self) = @_;
  	my $url = $self->rewrite_root || $self->url;
  	return canonicalize_url( add_path_to_url( $url, $self->path ) );
  }
  
  sub full_url {
  	my ($self) = @_;
  	return canonicalize_url( add_path_to_url( $self->url, $self->path ) );
  }
  
  sub full_pushurl {
  	my ($self) = @_;
  	if ($self->{pushurl}) {
  		return canonicalize_url( add_path_to_url( $self->{pushurl}, $self->path ) );
  	} else {
  		return $self->full_url;
  	}
  }
  
  sub set_commit_header_env {
  	my ($log_entry) = @_;
  	my %env;
  	foreach my $ned (qw/NAME EMAIL DATE/) {
  		foreach my $ac (qw/AUTHOR COMMITTER/) {
  			$env{"GIT_${ac}_${ned}"} = $ENV{"GIT_${ac}_${ned}"};
  		}
  	}
  
  	$ENV{GIT_AUTHOR_NAME} = $log_entry->{name};
  	$ENV{GIT_AUTHOR_EMAIL} = $log_entry->{email};
  	$ENV{GIT_AUTHOR_DATE} = $ENV{GIT_COMMITTER_DATE} = $log_entry->{date};
  
  	$ENV{GIT_COMMITTER_NAME} = (defined $log_entry->{commit_name})
  						? $log_entry->{commit_name}
  						: $log_entry->{name};
  	$ENV{GIT_COMMITTER_EMAIL} = (defined $log_entry->{commit_email})
  						? $log_entry->{commit_email}
  						: $log_entry->{email};
  	\%env;
  }
  
  sub restore_commit_header_env {
  	my ($env) = @_;
  	foreach my $ned (qw/NAME EMAIL DATE/) {
  		foreach my $ac (qw/AUTHOR COMMITTER/) {
  			my $k = "GIT_${ac}_${ned}";
  			if (defined $env->{$k}) {
  				$ENV{$k} = $env->{$k};
  			} else {
  				delete $ENV{$k};
  			}
  		}
  	}
  }
  
  sub gc {
  	command_noisy('gc', '--auto');
  };
  
  sub do_git_commit {
  	my ($self, $log_entry) = @_;
  	my $lr = $self->last_rev;
  	if (defined $lr && $lr >= $log_entry->{revision}) {
  		die "Last fetched revision of ", $self->refname,
  		    " was r$lr, but we are about to fetch: ",
  		    "r$log_entry->{revision}!\n";
  	}
  	if (my $c = $self->rev_map_get($log_entry->{revision})) {
  		croak "$log_entry->{revision} = $c already exists! ",
  		      "Why are we refetching it?\n";
  	}
  	my $old_env = set_commit_header_env($log_entry);
  	my $tree = $log_entry->{tree};
  	if (!defined $tree) {
  		$tree = $self->tmp_index_do(sub {
  		                            command_oneline('write-tree') });
  	}
  	die "Tree is not a valid sha1: $tree\n" if $tree !~ /^$::sha1$/o;
  
  	my @exec = ('git', 'commit-tree', $tree);
  	foreach ($self->get_commit_parents($log_entry)) {
  		push @exec, '-p', $_;
  	}
  	defined(my $pid = open3(my $msg_fh, my $out_fh, '>&STDERR', @exec))
  	                                                           or croak $!;
  	binmode $msg_fh;
  
  	# we always get UTF-8 from SVN, but we may want our commits in
  	# a different encoding.
  	if (my $enc = Git::config('i18n.commitencoding')) {
  		require Encode;
  		Encode::from_to($log_entry->{log}, 'UTF-8', $enc);
  	}
  	print $msg_fh $log_entry->{log} or croak $!;
  	restore_commit_header_env($old_env);
  	unless ($self->no_metadata) {
  		print $msg_fh "\ngit-svn-id: $log_entry->{metadata}\n"
  		              or croak $!;
  	}
  	$msg_fh->flush == 0 or croak $!;
  	close $msg_fh or croak $!;
  	chomp(my $commit = do { local $/; <$out_fh> });
  	close $out_fh or croak $!;
  	waitpid $pid, 0;
  	croak $? if $?;
  	if ($commit !~ /^$::sha1$/o) {
  		die "Failed to commit, invalid sha1: $commit\n";
  	}
  
  	$self->rev_map_set($log_entry->{revision}, $commit, 1);
  
  	$self->{last_rev} = $log_entry->{revision};
  	$self->{last_commit} = $commit;
  	print "r$log_entry->{revision}" unless $::_q > 1;
  	if (defined $log_entry->{svm_revision}) {
  		 print " (\@$log_entry->{svm_revision})" unless $::_q > 1;
  		 $self->rev_map_set($log_entry->{svm_revision}, $commit,
  		                   0, $self->svm_uuid);
  	}
  	print " = $commit ($self->{ref_id})\n" unless $::_q > 1;
  	if (--$_gc_nr == 0) {
  		$_gc_nr = $_gc_period;
  		gc();
  	}
  	return $commit;
  }
  
  sub match_paths {
  	my ($self, $paths, $r) = @_;
  	return 1 if $self->path eq '';
  	if (my $path = $paths->{"/".$self->path}) {
  		return ($path->{action} eq 'D') ? 0 : 1;
  	}
  	$self->{path_regex} ||= qr{^/\Q@{[$self->path]}\E/};
  	if (grep /$self->{path_regex}/, keys %$paths) {
  		return 1;
  	}
  	my $c = '';
  	foreach (split m#/#, $self->path) {
  		$c .= "/$_";
  		next unless ($paths->{$c} &&
  		             ($paths->{$c}->{action} =~ /^[AR]$/));
  		if ($self->ra->check_path($self->path, $r) ==
  		    $SVN::Node::dir) {
  			return 1;
  		}
  	}
  	return 0;
  }
  
  sub find_parent_branch {
  	my ($self, $paths, $rev) = @_;
  	return undef unless $self->follow_parent;
  	unless (defined $paths) {
  		my $err_handler = $SVN::Error::handler;
  		$SVN::Error::handler = \&Git::SVN::Ra::skip_unknown_revs;
  		$self->ra->get_log([$self->path], $rev, $rev, 0, 1, 1,
  				   sub { $paths = $_[0] });
  		$SVN::Error::handler = $err_handler;
  	}
  	return undef unless defined $paths;
  
  	# look for a parent from another branch:
  	my @b_path_components = split m#/#, $self->path;
  	my @a_path_components;
  	my $i;
  	while (@b_path_components) {
  		$i = $paths->{'/'.join('/', @b_path_components)};
  		last if $i && defined $i->{copyfrom_path};
  		unshift(@a_path_components, pop(@b_path_components));
  	}
  	return undef unless defined $i && defined $i->{copyfrom_path};
  	my $branch_from = $i->{copyfrom_path};
  	if (@a_path_components) {
  		print STDERR "branch_from: $branch_from => ";
  		$branch_from .= '/'.join('/', @a_path_components);
  		print STDERR $branch_from, "\n";
  	}
  	my $r = $i->{copyfrom_rev};
  	my $repos_root = $self->ra->{repos_root};
  	my $url = $self->ra->url;
  	my $new_url = canonicalize_url( add_path_to_url( $url, $branch_from ) );
  	print STDERR  "Found possible branch point: ",
  	              "$new_url => ", $self->full_url, ", $r\n"
  	              unless $::_q > 1;
  	$branch_from =~ s#^/##;
  	my $gs = $self->other_gs($new_url, $url,
  		                 $branch_from, $r, $self->{ref_id});
  	my ($r0, $parent) = $gs->find_rev_before($r, 1);
  	{
  		my ($base, $head);
  		if (!defined $r0 || !defined $parent) {
  			($base, $head) = parse_revision_argument(0, $r);
  		} else {
  			if ($r0 < $r) {
  				$gs->ra->get_log([$gs->path], $r0 + 1, $r, 1,
  					0, 1, sub { $base = $_[1] - 1 });
  			}
  		}
  		if (defined $base && $base <= $r) {
  			$gs->fetch($base, $r);
  		}
  		($r0, $parent) = $gs->find_rev_before($r, 1);
  	}
  	if (defined $r0 && defined $parent) {
  		print STDERR "Found branch parent: ($self->{ref_id}) $parent\n"
  		             unless $::_q > 1;
  		my $ed;
  		if ($self->ra->can_do_switch) {
  			$self->assert_index_clean($parent);
  			print STDERR "Following parent with do_switch\n"
  			             unless $::_q > 1;
  			# do_switch works with svn/trunk >= r22312, but that
  			# is not included with SVN 1.4.3 (the latest version
  			# at the moment), so we can't rely on it
  			$self->{last_rev} = $r0;
  			$self->{last_commit} = $parent;
  			$ed = Git::SVN::Fetcher->new($self, $gs->path);
  			$gs->ra->gs_do_switch($r0, $rev, $gs,
  					      $self->full_url, $ed)
  			  or die "SVN connection failed somewhere...\n";
  		} elsif ($self->ra->trees_match($new_url, $r0,
  			                        $self->full_url, $rev)) {
  			print STDERR "Trees match:\n",
  			             "  $new_url\@$r0\n",
  			             "  ${\$self->full_url}\@$rev\n",
  			             "Following parent with no changes\n"
  			             unless $::_q > 1;
  			$self->tmp_index_do(sub {
  			    command_noisy('read-tree', $parent);
  			});
  			$self->{last_commit} = $parent;
  		} else {
  			print STDERR "Following parent with do_update\n"
  			             unless $::_q > 1;
  			$ed = Git::SVN::Fetcher->new($self);
  			$self->ra->gs_do_update($rev, $rev, $self, $ed)
  			  or die "SVN connection failed somewhere...\n";
  		}
  		print STDERR "Successfully followed parent\n" unless $::_q > 1;
  		return $self->make_log_entry($rev, [$parent], $ed, $r0, $branch_from);
  	}
  	return undef;
  }
  
  sub do_fetch {
  	my ($self, $paths, $rev) = @_;
  	my $ed;
  	my ($last_rev, @parents);
  	if (my $lc = $self->last_commit) {
  		# we can have a branch that was deleted, then re-added
  		# under the same name but copied from another path, in
  		# which case we'll have multiple parents (we don't
  		# want to break the original ref or lose copypath info):
  		if (my $log_entry = $self->find_parent_branch($paths, $rev)) {
  			push @{$log_entry->{parents}}, $lc;
  			return $log_entry;
  		}
  		$ed = Git::SVN::Fetcher->new($self);
  		$last_rev = $self->{last_rev};
  		$ed->{c} = $lc;
  		@parents = ($lc);
  	} else {
  		$last_rev = $rev;
  		if (my $log_entry = $self->find_parent_branch($paths, $rev)) {
  			return $log_entry;
  		}
  		$ed = Git::SVN::Fetcher->new($self);
  	}
  	unless ($self->ra->gs_do_update($last_rev, $rev, $self, $ed)) {
  		die "SVN connection failed somewhere...\n";
  	}
  	$self->make_log_entry($rev, \@parents, $ed, $last_rev, $self->path);
  }
  
  sub mkemptydirs {
  	my ($self, $r) = @_;
  
  	# add/remove/collect a paths table
  	#
  	# Paths are split into a tree of nodes, stored as a hash of hashes.
  	#
  	# Each node contains a 'path' entry for the path (if any) associated
  	# with that node and a 'children' entry for any nodes under that
  	# location.
  	#
  	# Removing a path requires a hash lookup for each component then
  	# dropping that node (and anything under it), which is substantially
  	# faster than a grep slice into a single hash of paths for large
  	# numbers of paths.
  	#
  	# For a large (200K) number of empty_dir directives this reduces
  	# scanning time to 3 seconds vs 10 minutes for grep+delete on a single
  	# hash of paths.
  	sub add_path {
  		my ($paths_table, $path) = @_;
  		my $node_ref;
  
  		foreach my $x (split('/', $path)) {
  			if (!exists($paths_table->{$x})) {
  				$paths_table->{$x} = { children => {} };
  			}
  
  			$node_ref = $paths_table->{$x};
  			$paths_table = $paths_table->{$x}->{children};
  		}
  
  		$node_ref->{path} = $path;
  	}
  
  	sub remove_path {
  		my ($paths_table, $path) = @_;
  		my $nodes_ref;
  		my $node_name;
  
  		foreach my $x (split('/', $path)) {
  			if (!exists($paths_table->{$x})) {
  				return;
  			}
  
  			$nodes_ref = $paths_table;
  			$node_name = $x;
  
  			$paths_table = $paths_table->{$x}->{children};
  		}
  
  		delete($nodes_ref->{$node_name});
  	}
  
  	sub collect_paths {
  		my ($paths_table, $paths_ref) = @_;
  
  		foreach my $v (values %$paths_table) {
  			my $p = $v->{path};
  			my $c = $v->{children};
  
  			collect_paths($c, $paths_ref);
  
  			if (defined($p)) {
  				push(@$paths_ref, $p);
  			}
  		}
  	}
  
  	sub scan {
  		my ($r, $paths_table, $line) = @_;
  		if (defined $r && $line =~ /^r(\d+)$/) {
  			return 0 if $1 > $r;
  		} elsif ($line =~ /^  \+empty_dir: (.+)$/) {
  			add_path($paths_table, $1);
  		} elsif ($line =~ /^  \-empty_dir: (.+)$/) {
  			remove_path($paths_table, $1);
  		}
  		1; # continue
  	};
  
  	my @empty_dirs;
  	my %paths_table;
  
  	my $gz_file = "$self->{dir}/unhandled.log.gz";
  	if (-f $gz_file) {
  		if (!can_compress()) {
  			warn "Compress::Zlib could not be found; ",
  			     "empty directories in $gz_file will not be read\n";
  		} else {
  			my $gz = Compress::Zlib::gzopen($gz_file, "rb") or
  				die "Unable to open $gz_file: $!\n";
  			my $line;
  			while ($gz->gzreadline($line) > 0) {
  				scan($r, \%paths_table, $line) or last;
  			}
  			$gz->gzclose;
  		}
  	}
  
  	if (open my $fh, '<', "$self->{dir}/unhandled.log") {
  		binmode $fh or croak "binmode: $!";
  		while (<$fh>) {
  			scan($r, \%paths_table, $_) or last;
  		}
  		close $fh;
  	}
  
  	collect_paths(\%paths_table, \@empty_dirs);
  	my $strip = qr/\A\Q@{[$self->path]}\E(?:\/|$)/;
  	foreach my $d (sort @empty_dirs) {
  		$d = uri_decode($d);
  		$d =~ s/$strip//;
  		next unless length($d);
  		next if -d $d;
  		if (-e $d) {
  			warn "$d exists but is not a directory\n";
  		} else {
  			print "creating empty directory: $d\n";
  			mkpath([$d]);
  		}
  	}
  }
  
  sub get_untracked {
  	my ($self, $ed) = @_;
  	my @out;
  	my $h = $ed->{empty};
  	foreach (sort keys %$h) {
  		my $act = $h->{$_} ? '+empty_dir' : '-empty_dir';
  		push @out, "  $act: " . uri_encode($_);
  		warn "W: $act: $_\n";
  	}
  	foreach my $t (qw/dir_prop file_prop/) {
  		$h = $ed->{$t} or next;
  		foreach my $path (sort keys %$h) {
  			my $ppath = $path eq '' ? '.' : $path;
  			foreach my $prop (sort keys %{$h->{$path}}) {
  				next if $SKIP_PROP{$prop};
  				my $v = $h->{$path}->{$prop};
  				my $t_ppath_prop = "$t: " .
  				                    uri_encode($ppath) . ' ' .
  				                    uri_encode($prop);
  				if (defined $v) {
  					push @out, "  +$t_ppath_prop " .
  					           uri_encode($v);
  				} else {
  					push @out, "  -$t_ppath_prop";
  				}
  			}
  		}
  	}
  	foreach my $t (qw/absent_file absent_directory/) {
  		$h = $ed->{$t} or next;
  		foreach my $parent (sort keys %$h) {
  			foreach my $path (sort @{$h->{$parent}}) {
  				push @out, "  $t: " .
  				           uri_encode("$parent/$path");
  				warn "W: $t: $parent/$path ",
  				     "Insufficient permissions?\n";
  			}
  		}
  	}
  	\@out;
  }
  
  # parse_svn_date(DATE)
  # --------------------
  # Given a date (in UTC) from Subversion, return a string in the format
  # "<TZ Offset> <local date/time>" that Git will use.
  #
  # By default the parsed date will be in UTC; if $Git::SVN::_localtime
  # is true we'll convert it to the local timezone instead.
  sub parse_svn_date {
  	my $date = shift || return '+0000 1970-01-01 00:00:00';
  	my ($Y,$m,$d,$H,$M,$S) = ($date =~ /^(\d{4})\-(\d\d)\-(\d\d)T
  	                                    (\d\d?)\:(\d\d)\:(\d\d)\.\d*Z$/x) or
  	                                 croak "Unable to parse date: $date\n";
  	my $parsed_date;    # Set next.
  
  	if ($Git::SVN::_localtime) {
  		# Translate the Subversion datetime to an epoch time.
  		# Begin by switching ourselves to $date's timezone, UTC.
  		my $old_env_TZ = $ENV{TZ};
  		$ENV{TZ} = 'UTC';
  
  		my $epoch_in_UTC =
  		    Time::Local::timelocal($S, $M, $H, $d, $m - 1, $Y - 1900);
  
  		# Determine our local timezone (including DST) at the
  		# time of $epoch_in_UTC.  $Git::SVN::Log::TZ stored the
  		# value of TZ, if any, at the time we were run.
  		if (defined $Git::SVN::Log::TZ) {
  			$ENV{TZ} = $Git::SVN::Log::TZ;
  		} else {
  			delete $ENV{TZ};
  		}
  
  		my $our_TZ = get_tz_offset($epoch_in_UTC);
  
  		# This converts $epoch_in_UTC into our local timezone.
  		my ($sec, $min, $hour, $mday, $mon, $year,
  		    $wday, $yday, $isdst) = localtime($epoch_in_UTC);
  
  		$parsed_date = sprintf('%s %04d-%02d-%02d %02d:%02d:%02d',
  				       $our_TZ, $year + 1900, $mon + 1,
  				       $mday, $hour, $min, $sec);
  
  		# Reset us to the timezone in effect when we entered
  		# this routine.
  		if (defined $old_env_TZ) {
  			$ENV{TZ} = $old_env_TZ;
  		} else {
  			delete $ENV{TZ};
  		}
  	} else {
  		$parsed_date = "+0000 $Y-$m-$d $H:$M:$S";
  	}
  
  	return $parsed_date;
  }
  
  sub other_gs {
  	my ($self, $new_url, $url,
  	    $branch_from, $r, $old_ref_id) = @_;
  	my $gs = Git::SVN->find_by_url($new_url, $url, $branch_from);
  	unless ($gs) {
  		my $ref_id = $old_ref_id;
  		$ref_id =~ s/\@\d+-*$//;
  		$ref_id .= "\@$r";
  		# just grow a tail if we're not unique enough :x
  		$ref_id .= '-' while find_ref($ref_id);
  		my ($u, $p, $repo_id) = ($new_url, '', $ref_id);
  		if ($u =~ s#^\Q$url\E(/|$)##) {
  			$p = $u;
  			$u = $url;
  			$repo_id = $self->{repo_id};
  		}
  		while (1) {
  			# It is possible to tag two different subdirectories at
  			# the same revision.  If the url for an existing ref
  			# does not match, we must either find a ref with a
  			# matching url or create a new ref by growing a tail.
  			$gs = Git::SVN->init($u, $p, $repo_id, $ref_id, 1);
  			my (undef, $max_commit) = $gs->rev_map_max(1);
  			last if (!$max_commit);
  			my ($url) = ::cmt_metadata($max_commit);
  			last if ($url eq $gs->metadata_url);
  			$ref_id .= '-';
  		}
  		print STDERR "Initializing parent: $ref_id\n" unless $::_q > 1;
  	}
  	$gs
  }
  
  sub call_authors_prog {
  	my ($orig_author) = @_;
  	$orig_author = command_oneline('rev-parse', '--sq-quote', $orig_author);
  	my $author = `$::_authors_prog $orig_author`;
  	if ($? != 0) {
  		die "$::_authors_prog failed with exit code $?\n"
  	}
  	if ($author =~ /^\s*(.+?)\s*<(.*)>\s*$/) {
  		my ($name, $email) = ($1, $2);
  		$email = undef if length $2 == 0;
  		return [$name, $email];
  	} else {
  		die "Author: $orig_author: $::_authors_prog returned "
  			. "invalid author format: $author\n";
  	}
  }
  
  sub check_author {
  	my ($author) = @_;
  	if (!defined $author || length $author == 0) {
  		$author = '(no author)';
  	}
  	if (!defined $::users{$author}) {
  		if (defined $::_authors_prog) {
  			$::users{$author} = call_authors_prog($author);
  		} elsif (defined $::_authors) {
  			die "Author: $author not defined in $::_authors file\n";
  		}
  	}
  	$author;
  }
  
  sub find_extra_svk_parents {
  	my ($self, $tickets, $parents) = @_;
  	# aha!  svk:merge property changed...
  	my @tickets = split "\n", $tickets;
  	my @known_parents;
  	for my $ticket ( @tickets ) {
  		my ($uuid, $path, $rev) = split /:/, $ticket;
  		if ( $uuid eq $self->ra_uuid ) {
  			my $repos_root = $self->url;
  			my $branch_from = $path;
  			$branch_from =~ s{^/}{};
  			my $gs = $self->other_gs(add_path_to_url( $repos_root, $branch_from ),
  			                         $repos_root,
  			                         $branch_from,
  			                         $rev,
  			                         $self->{ref_id});
  			if ( my $commit = $gs->rev_map_get($rev, $uuid) ) {
  				# wahey!  we found it, but it might be
  				# an old one (!)
  				push @known_parents, [ $rev, $commit ];
  			}
  		}
  	}
  	# Ordering matters; highest-numbered commit merge tickets
  	# first, as they may account for later merge ticket additions
  	# or changes.
  	@known_parents = map {$_->[1]} sort {$b->[0] <=> $a->[0]} @known_parents;
  	for my $parent ( @known_parents ) {
  		my @cmd = ('rev-list', $parent, map { "^$_" } @$parents );
  		my ($msg_fh, $ctx) = command_output_pipe(@cmd);
  		my $new;
  		while ( <$msg_fh> ) {
  			$new=1;last;
  		}
  		command_close_pipe($msg_fh, $ctx);
  		if ( $new ) {
  			print STDERR
  			    "Found merge parent (svk:merge ticket): $parent\n";
  			push @$parents, $parent;
  		}
  	}
  }
  
  sub lookup_svn_merge {
  	my $uuid = shift;
  	my $url = shift;
  	my $source = shift;
  	my $revs = shift;
  
  	my $path = $source;
  	$path =~ s{^/}{};
  	my $gs = Git::SVN->find_by_url($url.$source, $url, $path);
  	if ( !$gs ) {
  		warn "Couldn't find revmap for $url$source\n";
  		return;
  	}
  	my @ranges = split ",", $revs;
  	my ($tip, $tip_commit);
  	my @merged_commit_ranges;
  	# find the tip
  	for my $range ( @ranges ) {
  		if ($range =~ /[*]$/) {
  			warn "W: Ignoring partial merge in svn:mergeinfo "
  				."dirprop: $source:$range\n";
  			next;
  		}
  		my ($bottom, $top) = split "-", $range;
  		$top ||= $bottom;
  		my $bottom_commit = $gs->find_rev_after( $bottom, 1, $top );
  		my $top_commit = $gs->find_rev_before( $top, 1, $bottom );
  
  		unless ($top_commit and $bottom_commit) {
  			warn "W: unknown path/rev in svn:mergeinfo "
  				."dirprop: $source:$range\n";
  			next;
  		}
  
  		if (scalar(command('rev-parse', "$bottom_commit^@"))) {
  			push @merged_commit_ranges,
  			     "$bottom_commit^..$top_commit";
  		} else {
  			push @merged_commit_ranges, "$top_commit";
  		}
  
  		if ( !defined $tip or $top > $tip ) {
  			$tip = $top;
  			$tip_commit = $top_commit;
  		}
  	}
  	return ($tip_commit, @merged_commit_ranges);
  }
  
  sub _rev_list {
  	my ($msg_fh, $ctx) = command_output_pipe(
  		"rev-list", @_,
  	       );
  	my @rv;
  	while ( <$msg_fh> ) {
  		chomp;
  		push @rv, $_;
  	}
  	command_close_pipe($msg_fh, $ctx);
  	@rv;
  }
  
  sub check_cherry_pick2 {
  	my $base = shift;
  	my $tip = shift;
  	my $parents = shift;
  	my @ranges = @_;
  	my %commits = map { $_ => 1 }
  		_rev_list("--no-merges", $tip, "--not", $base, @$parents, "--");
  	for my $range ( @ranges ) {
  		delete @commits{_rev_list($range, "--")};
  	}
  	for my $commit (keys %commits) {
  		if (has_no_changes($commit)) {
  			delete $commits{$commit};
  		}
  	}
  	my @k = (keys %commits);
  	return (scalar @k, $k[0]);
  }
  
  sub has_no_changes {
  	my $commit = shift;
  
  	my @revs = split / /, command_oneline(
  		qw(rev-list --parents -1 -m), $commit);
  
  	# Commits with no parents, e.g. the start of a partial branch,
  	# have changes by definition.
  	return 1 if (@revs < 2);
  
  	# Commits with multiple parents, e.g a merge, have no changes
  	# by definition.
  	return 0 if (@revs > 2);
  
  	return (command_oneline("rev-parse", "$commit^{tree}") eq
  		command_oneline("rev-parse", "$commit~1^{tree}"));
  }
  
  sub tie_for_persistent_memoization {
  	my $hash = shift;
  	my $path = shift;
  
  	unless ($memo_backend) {
  		if (eval { require Git::SVN::Memoize::YAML; 1}) {
  			$memo_backend = 1;
  		} else {
  			require Memoize::Storable;
  			$memo_backend = -1;
  		}
  	}
  
  	if ($memo_backend > 0) {
  		tie %$hash => 'Git::SVN::Memoize::YAML', "$path.yaml";
  	} else {
  		# first verify that any existing file can actually be loaded
  		# (it may have been saved by an incompatible version)
  		my $db = "$path.db";
  		if (-e $db) {
  			use Storable qw(retrieve);
  
  			if (!eval { retrieve($db); 1 }) {
  				unlink $db or die "unlink $db failed: $!";
  			}
  		}
  		tie %$hash => 'Memoize::Storable', $db, 'nstore';
  	}
  }
  
  # The GIT_DIR environment variable is not always set until after the command
  # line arguments are processed, so we can't memoize in a BEGIN block.
  {
  	my $memoized = 0;
  
  	sub memoize_svn_mergeinfo_functions {
  		return if $memoized;
  		$memoized = 1;
  
  		my $cache_path = svn_dir() . '/.caches/';
  		mkpath([$cache_path]) unless -d $cache_path;
  
  		my %lookup_svn_merge_cache;
  		my %check_cherry_pick2_cache;
  		my %has_no_changes_cache;
  
  		tie_for_persistent_memoization(\%lookup_svn_merge_cache,
  		    "$cache_path/lookup_svn_merge");
  		memoize 'lookup_svn_merge',
  			SCALAR_CACHE => 'FAULT',
  			LIST_CACHE => ['HASH' => \%lookup_svn_merge_cache],
  		;
  
  		tie_for_persistent_memoization(\%check_cherry_pick2_cache,
  		    "$cache_path/check_cherry_pick2");
  		memoize 'check_cherry_pick2',
  			SCALAR_CACHE => 'FAULT',
  			LIST_CACHE => ['HASH' => \%check_cherry_pick2_cache],
  		;
  
  		tie_for_persistent_memoization(\%has_no_changes_cache,
  		    "$cache_path/has_no_changes");
  		memoize 'has_no_changes',
  			SCALAR_CACHE => ['HASH' => \%has_no_changes_cache],
  			LIST_CACHE => 'FAULT',
  		;
  	}
  
  	sub unmemoize_svn_mergeinfo_functions {
  		return if not $memoized;
  		$memoized = 0;
  
  		Memoize::unmemoize 'lookup_svn_merge';
  		Memoize::unmemoize 'check_cherry_pick2';
  		Memoize::unmemoize 'has_no_changes';
  	}
  
  	sub clear_memoized_mergeinfo_caches {
  		die "Only call this method in non-memoized context" if ($memoized);
  
  		my $cache_path = svn_dir() . '/.caches/';
  		return unless -d $cache_path;
  
  		for my $cache_file (("$cache_path/lookup_svn_merge",
  				     "$cache_path/check_cherry_pick", # old
  				     "$cache_path/check_cherry_pick2",
  				     "$cache_path/has_no_changes")) {
  			for my $suffix (qw(yaml db)) {
  				my $file = "$cache_file.$suffix";
  				next unless -e $file;
  				unlink($file) or die "unlink($file) failed: $!\n";
  			}
  		}
  	}
  
  
  	Memoize::memoize 'Git::SVN::repos_root';
  }
  
  END {
  	# Force cache writeout explicitly instead of waiting for
  	# global destruction to avoid segfault in Storable:
  	# http://rt.cpan.org/Public/Bug/Display.html?id=36087
  	unmemoize_svn_mergeinfo_functions();
  }
  
  sub parents_exclude {
  	my $parents = shift;
  	my @commits = @_;
  	return unless @commits;
  
  	my @excluded;
  	my $excluded;
  	do {
  		my @cmd = ('rev-list', "-1", @commits, "--not", @$parents );
  		$excluded = command_oneline(@cmd);
  		if ( $excluded ) {
  			my @new;
  			my $found;
  			for my $commit ( @commits ) {
  				if ( $commit eq $excluded ) {
  					push @excluded, $commit;
  					$found++;
  				}
  				else {
  					push @new, $commit;
  				}
  			}
  			die "saw commit '$excluded' in rev-list output, "
  				."but we didn't ask for that commit (wanted: @commits --not @$parents)"
  					unless $found;
  			@commits = @new;
  		}
  	}
  		while ($excluded and @commits);
  
  	return @excluded;
  }
  
  # Compute what's new in svn:mergeinfo.
  sub mergeinfo_changes {
  	my ($self, $old_path, $old_rev, $path, $rev, $mergeinfo_prop) = @_;
  	my %minfo = map {split ":", $_ } split "\n", $mergeinfo_prop;
  	my $old_minfo = {};
  
  	my $ra = $self->ra;
  	# Give up if $old_path isn't in the repo.
  	# This is probably a merge on a subtree.
  	if ($ra->check_path($old_path, $old_rev) != $SVN::Node::dir) {
  		warn "W: ignoring svn:mergeinfo on $old_path, ",
  			"directory didn't exist in r$old_rev\n";
  		return {};
  	}
  	my (undef, undef, $props) = $ra->get_dir($old_path, $old_rev);
  	if (defined $props->{"svn:mergeinfo"}) {
  		my %omi = map {split ":", $_ } split "\n",
  			$props->{"svn:mergeinfo"};
  		$old_minfo = \%omi;
  	}
  
  	my %changes = ();
  	foreach my $p (keys %minfo) {
  		my $a = $old_minfo->{$p} || "";
  		my $b = $minfo{$p};
  		# Omit merged branches whose ranges lists are unchanged.
  		next if $a eq $b;
  		# Remove any common range list prefix.
  		($a ^ $b) =~ /^[\0]*/;
  		my $common_prefix = rindex $b, ",", $+[0] - 1;
  		$changes{$p} = substr $b, $common_prefix + 1;
  	}
  	print STDERR "Checking svn:mergeinfo changes since r$old_rev: ",
  		scalar(keys %minfo), " sources, ",
  		scalar(keys %changes), " changed\n";
  
  	return \%changes;
  }
  
  # note: this function should only be called if the various dirprops
  # have actually changed
  sub find_extra_svn_parents {
  	my ($self, $mergeinfo, $parents) = @_;
  	# aha!  svk:merge property changed...
  
  	memoize_svn_mergeinfo_functions();
  
  	# We first search for merged tips which are not in our
  	# history.  Then, we figure out which git revisions are in
  	# that tip, but not this revision.  If all of those revisions
  	# are now marked as merge, we can add the tip as a parent.
  	my @merges = sort keys %$mergeinfo;
  	my @merge_tips;
  	my $url = $self->url;
  	my $uuid = $self->ra_uuid;
  	my @all_ranges;
  	for my $merge ( @merges ) {
  		my ($tip_commit, @ranges) =
  			lookup_svn_merge( $uuid, $url,
  					  $merge, $mergeinfo->{$merge} );
  		unless (!$tip_commit or
  				grep { $_ eq $tip_commit } @$parents ) {
  			push @merge_tips, $tip_commit;
  			push @all_ranges, @ranges;
  		} else {
  			push @merge_tips, undef;
  		}
  	}
  
  	my %excluded = map { $_ => 1 }
  		parents_exclude($parents, grep { defined } @merge_tips);
  
  	# check merge tips for new parents
  	my @new_parents;
  	for my $merge_tip ( @merge_tips ) {
  		my $merge = shift @merges;
  		next unless $merge_tip and $excluded{$merge_tip};
  		my $spec = "$merge:$mergeinfo->{$merge}";
  
  		# check out 'new' tips
  		my $merge_base;
  		eval {
  			$merge_base = command_oneline(
  				"merge-base",
  				@$parents, $merge_tip,
  			);
  		};
  		if ($@) {
  			die "An error occurred during merge-base"
  				unless $@->isa("Git::Error::Command");
  
  			warn "W: Cannot find common ancestor between ".
  			     "@$parents and $merge_tip. Ignoring merge info.\n";
  			next;
  		}
  
  		# double check that there are no missing non-merge commits
  		my ($ninc, $ifirst) = check_cherry_pick2(
  			$merge_base, $merge_tip,
  			$parents,
  			@all_ranges,
  		       );
  
  		if ($ninc) {
  			warn "W: svn cherry-pick ignored ($spec) - missing " .
  				"$ninc commit(s) (eg $ifirst)\n";
  		} else {
  			warn "Found merge parent ($spec): ", $merge_tip, "\n";
  			push @new_parents, $merge_tip;
  		}
  	}
  
  	# cater for merges which merge commits from multiple branches
  	if ( @new_parents > 1 ) {
  		for ( my $i = 0; $i <= $#new_parents; $i++ ) {
  			for ( my $j = 0; $j <= $#new_parents; $j++ ) {
  				next if $i == $j;
  				next unless $new_parents[$i];
  				next unless $new_parents[$j];
  				my $revs = command_oneline(
  					"rev-list", "-1",
  					"$new_parents[$i]..$new_parents[$j]",
  				       );
  				if ( !$revs ) {
  					undef($new_parents[$j]);
  				}
  			}
  		}
  	}
  	push @$parents, grep { defined } @new_parents;
  }
  
  sub make_log_entry {
  	my ($self, $rev, $parents, $ed, $parent_rev, $parent_path) = @_;
  	my $untracked = $self->get_untracked($ed);
  
  	my @parents = @$parents;
  	my $props = $ed->{dir_prop}{$self->path};
  	if ($self->follow_parent) {
  		my $tickets = $props->{"svk:merge"};
  		if ($tickets) {
  			$self->find_extra_svk_parents($tickets, \@parents);
  		}
  
  		my $mergeinfo_prop = $props->{"svn:mergeinfo"};
  		if ($mergeinfo_prop) {
  			my $mi_changes = $self->mergeinfo_changes(
  						$parent_path,
  						$parent_rev,
  						$self->path,
  						$rev,
  						$mergeinfo_prop);
  			$self->find_extra_svn_parents($mi_changes, \@parents);
  		}
  	}
  
  	open my $un, '>>', "$self->{dir}/unhandled.log" or croak $!;
  	print $un "r$rev\n" or croak $!;
  	print $un $_, "\n" foreach @$untracked;
  	my %log_entry = ( parents => \@parents, revision => $rev,
  	                  log => '');
  
  	my $headrev;
  	my $logged = delete $self->{logged_rev_props};
  	if (!$logged || $self->{-want_revprops}) {
  		my $rp = $self->ra->rev_proplist($rev);
  		foreach (sort keys %$rp) {
  			my $v = $rp->{$_};
  			if (/^svn:(author|date|log)$/) {
  				$log_entry{$1} = $v;
  			} elsif ($_ eq 'svm:headrev') {
  				$headrev = $v;
  			} else {
  				print $un "  rev_prop: ", uri_encode($_), ' ',
  					  uri_encode($v), "\n";
  			}
  		}
  	} else {
  		map { $log_entry{$_} = $logged->{$_} } keys %$logged;
  	}
  	close $un or croak $!;
  
  	$log_entry{date} = parse_svn_date($log_entry{date});
  	$log_entry{log} .= "\n";
  	my $author = $log_entry{author} = check_author($log_entry{author});
  	my ($name, $email) = defined $::users{$author} ? @{$::users{$author}}
  						       : ($author, undef);
  
  	my ($commit_name, $commit_email) = ($name, $email);
  	if ($_use_log_author) {
  		my $name_field;
  		if ($log_entry{log} =~ /From:\s+(.*\S)\s*\n/i) {
  			$name_field = $1;
  		} elsif ($log_entry{log} =~ /Signed-off-by:\s+(.*\S)\s*\n/i) {
  			$name_field = $1;
  		}
  		if (!defined $name_field) {
  			if (!defined $email) {
  				$email = $name;
  			}
  		} elsif ($name_field =~ /(.*?)\s+<(.*)>/) {
  			($name, $email) = ($1, $2);
  		} elsif ($name_field =~ /(.*)@/) {
  			($name, $email) = ($1, $name_field);
  		} else {
  			($name, $email) = ($name_field, $name_field);
  		}
  	}
  	if (defined $headrev && $self->use_svm_props) {
  		if ($self->rewrite_root) {
  			die "Can't have both 'useSvmProps' and 'rewriteRoot' ",
  			    "options set!\n";
  		}
  		if ($self->rewrite_uuid) {
  			die "Can't have both 'useSvmProps' and 'rewriteUUID' ",
  			    "options set!\n";
  		}
  		my ($uuid, $r) = $headrev =~ m{^([a-f\d\-]{30,}):(\d+)$}i;
  		# we don't want "SVM: initializing mirror for junk" ...
  		return undef if $r == 0;
  		my $svm = $self->svm;
  		if ($uuid ne $svm->{uuid}) {
  			die "UUID mismatch on SVM path:\n",
  			    "expected: $svm->{uuid}\n",
  			    "     got: $uuid\n";
  		}
  		my $full_url = $self->full_url;
  		$full_url =~ s#^\Q$svm->{replace}\E(/|$)#$svm->{source}$1# or
  		             die "Failed to replace '$svm->{replace}' with ",
  		                 "'$svm->{source}' in $full_url\n";
  		# throw away username for storing in records
  		remove_username($full_url);
  		$log_entry{metadata} = "$full_url\@$r $uuid";
  		$log_entry{svm_revision} = $r;
  		$email ||= "$author\@$uuid";
  		$commit_email ||= "$author\@$uuid";
  	} elsif ($self->use_svnsync_props) {
  		my $full_url = canonicalize_url(
  			add_path_to_url( $self->svnsync->{url}, $self->path )
  		);
  		remove_username($full_url);
  		my $uuid = $self->svnsync->{uuid};
  		$log_entry{metadata} = "$full_url\@$rev $uuid";
  		$email ||= "$author\@$uuid";
  		$commit_email ||= "$author\@$uuid";
  	} else {
  		my $url = $self->metadata_url;
  		remove_username($url);
  		my $uuid = $self->rewrite_uuid || $self->ra->get_uuid;
  		$log_entry{metadata} = "$url\@$rev " . $uuid;
  		$email ||= "$author\@" . $uuid;
  		$commit_email ||= "$author\@" . $uuid;
  	}
  	$log_entry{name} = $name;
  	$log_entry{email} = $email;
  	$log_entry{commit_name} = $commit_name;
  	$log_entry{commit_email} = $commit_email;
  	\%log_entry;
  }
  
  sub fetch {
  	my ($self, $min_rev, $max_rev, @parents) = @_;
  	my ($last_rev, $last_commit) = $self->last_rev_commit;
  	my ($base, $head) = $self->get_fetch_range($min_rev, $max_rev);
  	$self->ra->gs_fetch_loop_common($base, $head, [$self]);
  }
  
  sub set_tree_cb {
  	my ($self, $log_entry, $tree, $rev, $date, $author) = @_;
  	$self->{inject_parents} = { $rev => $tree };
  	$self->fetch(undef, undef);
  }
  
  sub set_tree {
  	my ($self, $tree) = (shift, shift);
  	my $log_entry = ::get_commit_entry($tree);
  	unless ($self->{last_rev}) {
  		fatal("Must have an existing revision to commit");
  	}
  	my %ed_opts = ( r => $self->{last_rev},
  	                log => $log_entry->{log},
  	                ra => $self->ra,
  	                tree_a => $self->{last_commit},
  	                tree_b => $tree,
  	                editor_cb => sub {
  			       $self->set_tree_cb($log_entry, $tree, @_) },
  	                svn_path => $self->path );
  	if (!Git::SVN::Editor->new(\%ed_opts)->apply_diff) {
  		print "No changes\nr$self->{last_rev} = $tree\n";
  	}
  }
  
  sub rebuild_from_rev_db {
  	my ($self, $path) = @_;
  	my $r = -1;
  	open my $fh, '<', $path or croak "open: $!";
  	binmode $fh or croak "binmode: $!";
  	while (<$fh>) {
  		length($_) == 41 or croak "inconsistent size in ($_) != 41";
  		chomp($_);
  		++$r;
  		next if $_ eq ('0' x 40);
  		$self->rev_map_set($r, $_);
  		print "r$r = $_\n";
  	}
  	close $fh or croak "close: $!";
  	unlink $path or croak "unlink: $!";
  }
  
  #define a global associate map to record rebuild status
  my %rebuild_status;
  #define a global associate map to record rebuild verify status
  my %rebuild_verify_status;
  
  sub rebuild {
  	my ($self) = @_;
  	my $map_path = $self->map_path;
  	my $partial = (-e $map_path && ! -z $map_path);
  	my $verify_key = $self->refname.'^0';
  	if (!$rebuild_verify_status{$verify_key}) {
  		my $verify_result = ::verify_ref($verify_key);
  		if ($verify_result) {
  			$rebuild_verify_status{$verify_key} = 1;
  		}
  	}
  	if (!$rebuild_verify_status{$verify_key}) {
  		return;
  	}
  	if (!$partial && ($self->use_svm_props || $self->no_metadata)) {
  		my $rev_db = $self->rev_db_path;
  		$self->rebuild_from_rev_db($rev_db);
  		if ($self->use_svm_props) {
  			my $svm_rev_db = $self->rev_db_path($self->svm_uuid);
  			$self->rebuild_from_rev_db($svm_rev_db);
  		}
  		$self->unlink_rev_db_symlink;
  		return;
  	}
  	print "Rebuilding $map_path ...\n" if (!$partial);
  	my ($base_rev, $head) = ($partial ? $self->rev_map_max_norebuild(1) :
  		(undef, undef));
  	my $key_value = ($head ? "$head.." : "") . $self->refname;
  	if (exists $rebuild_status{$key_value}) {
  		print "Done rebuilding $map_path\n" if (!$partial || !$head);
  		my $rev_db_path = $self->rev_db_path;
  		if (-f $self->rev_db_path) {
  			unlink $self->rev_db_path or croak "unlink: $!";
  		}
  		$self->unlink_rev_db_symlink;
  		return;
  	}
  	my ($log, $ctx) =
  		command_output_pipe(qw/rev-list --pretty=raw --reverse/,
  				$key_value,
  				'--');
  	$rebuild_status{$key_value} = 1;
  	my $metadata_url = $self->metadata_url;
  	remove_username($metadata_url);
  	my $svn_uuid = $self->rewrite_uuid || $self->ra_uuid;
  	my $c;
  	while (<$log>) {
  		if ( m{^commit ($::sha1)$} ) {
  			$c = $1;
  			next;
  		}
  		next unless s{^\s*(git-svn-id:)}{$1};
  		my ($url, $rev, $uuid) = ::extract_metadata($_);
  		remove_username($url);
  
  		# ignore merges (from set-tree)
  		next if (!defined $rev || !$uuid);
  
  		# if we merged or otherwise started elsewhere, this is
  		# how we break out of it
  		if (($uuid ne $svn_uuid) ||
  		    ($metadata_url && $url && ($url ne $metadata_url))) {
  			next;
  		}
  		if ($partial && $head) {
  			print "Partial-rebuilding $map_path ...\n";
  			print "Currently at $base_rev = $head\n";
  			$head = undef;
  		}
  
  		$self->rev_map_set($rev, $c);
  		print "r$rev = $c\n";
  	}
  	command_close_pipe($log, $ctx);
  	print "Done rebuilding $map_path\n" if (!$partial || !$head);
  	my $rev_db_path = $self->rev_db_path;
  	if (-f $self->rev_db_path) {
  		unlink $self->rev_db_path or croak "unlink: $!";
  	}
  	$self->unlink_rev_db_symlink;
  }
  
  # rev_map:
  # Tie::File seems to be prone to offset errors if revisions get sparse,
  # it's not that fast, either.  Tie::File is also not in Perl 5.6.  So
  # one of my favorite modules is out :<  Next up would be one of the DBM
  # modules, but I'm not sure which is most portable...
  #
  # This is the replacement for the rev_db format, which was too big
  # and inefficient for large repositories with a lot of sparse history
  # (mainly tags)
  #
  # The format is this:
  #   - 24 bytes for every record,
  #     * 4 bytes for the integer representing an SVN revision number
  #     * 20 bytes representing the sha1 of a git commit
  #   - No empty padding records like the old format
  #     (except the last record, which can be overwritten)
  #   - new records are written append-only since SVN revision numbers
  #     increase monotonically
  #   - lookups on SVN revision number are done via a binary search
  #   - Piping the file to xxd -c24 is a good way of dumping it for
  #     viewing or editing (piped back through xxd -r), should the need
  #     ever arise.
  #   - The last record can be padding revision with an all-zero sha1
  #     This is used to optimize fetch performance when using multiple
  #     "fetch" directives in .git/config
  #
  # These files are disposable unless noMetadata or useSvmProps is set
  
  sub _rev_map_set {
  	my ($fh, $rev, $commit) = @_;
  
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	my $wr_offset = 0;
  	if ($size > 0) {
  		sysseek($fh, -24, SEEK_END) or croak "seek: $!";
  		my $read = sysread($fh, my $buf, 24) or croak "read: $!";
  		$read == 24 or croak "read only $read bytes (!= 24)";
  		my ($last_rev, $last_commit) = unpack(rev_map_fmt, $buf);
  		if ($last_commit eq ('0' x40)) {
  			if ($size >= 48) {
  				sysseek($fh, -48, SEEK_END) or croak "seek: $!";
  				$read = sysread($fh, $buf, 24) or
  				    croak "read: $!";
  				$read == 24 or
  				    croak "read only $read bytes (!= 24)";
  				($last_rev, $last_commit) =
  				    unpack(rev_map_fmt, $buf);
  				if ($last_commit eq ('0' x40)) {
  					croak "inconsistent .rev_map\n";
  				}
  			}
  			if ($last_rev >= $rev) {
  				croak "last_rev is higher!: $last_rev >= $rev";
  			}
  			$wr_offset = -24;
  		}
  	}
  	sysseek($fh, $wr_offset, SEEK_END) or croak "seek: $!";
  	syswrite($fh, pack(rev_map_fmt, $rev, $commit), 24) == 24 or
  	  croak "write: $!";
  }
  
  sub _rev_map_reset {
  	my ($fh, $rev, $commit) = @_;
  	my $c = _rev_map_get($fh, $rev);
  	$c eq $commit or die "_rev_map_reset(@_) commit $c does not match!\n";
  	my $offset = sysseek($fh, 0, SEEK_CUR) or croak "seek: $!";
  	truncate $fh, $offset or croak "truncate: $!";
  }
  
  sub mkfile {
  	my ($path) = @_;
  	unless (-e $path) {
  		my ($dir, $base) = ($path =~ m#^(.*?)/?([^/]+)$#);
  		mkpath([$dir]) unless -d $dir;
  		open my $fh, '>>', $path or die "Couldn't create $path: $!\n";
  		close $fh or die "Couldn't close (create) $path: $!\n";
  	}
  }
  
  sub rev_map_set {
  	my ($self, $rev, $commit, $update_ref, $uuid) = @_;
  	defined $commit or die "missing arg3\n";
  	length $commit == 40 or die "arg3 must be a full SHA1 hexsum\n";
  	my $db = $self->map_path($uuid);
  	my $db_lock = "$db.lock";
  	my $sigmask;
  	$update_ref ||= 0;
  	if ($update_ref) {
  		$sigmask = POSIX::SigSet->new();
  		my $signew = POSIX::SigSet->new(SIGINT, SIGHUP, SIGTERM,
  			SIGALRM, SIGUSR1, SIGUSR2);
  		sigprocmask(SIG_BLOCK, $signew, $sigmask) or
  			croak "Can't block signals: $!";
  	}
  	mkfile($db);
  
  	$LOCKFILES{$db_lock} = 1;
  	my $sync;
  	# both of these options make our .rev_db file very, very important
  	# and we can't afford to lose it because rebuild() won't work
  	if ($self->use_svm_props || $self->no_metadata) {
  		require File::Copy;
  		$sync = 1;
  		File::Copy::copy($db, $db_lock) or die "rev_map_set(@_): ",
  					   "Failed to copy: ",
  					   "$db => $db_lock ($!)\n";
  	} else {
  		rename $db, $db_lock or die "rev_map_set(@_): ",
  					    "Failed to rename: ",
  					    "$db => $db_lock ($!)\n";
  	}
  
  	sysopen(my $fh, $db_lock, O_RDWR | O_CREAT)
  	     or croak "Couldn't open $db_lock: $!\n";
  	if ($update_ref eq 'reset') {
  		clear_memoized_mergeinfo_caches();
  		_rev_map_reset($fh, $rev, $commit);
  	} else {
  		_rev_map_set($fh, $rev, $commit);
  	}
  
  	if ($sync) {
  		$fh->flush or die "Couldn't flush $db_lock: $!\n";
  		$fh->sync or die "Couldn't sync $db_lock: $!\n";
  	}
  	close $fh or croak $!;
  	if ($update_ref) {
  		$_head = $self;
  		my $note = "";
  		$note = " ($update_ref)" if ($update_ref !~ /^\d*$/);
  		command_noisy('update-ref', '-m', "r$rev$note",
  		              $self->refname, $commit);
  	}
  	rename $db_lock, $db or die "rev_map_set(@_): ", "Failed to rename: ",
  	                            "$db_lock => $db ($!)\n";
  	delete $LOCKFILES{$db_lock};
  	if ($update_ref) {
  		sigprocmask(SIG_SETMASK, $sigmask) or
  			croak "Can't restore signal mask: $!";
  	}
  }
  
  # If want_commit, this will return an array of (rev, commit) where
  # commit _must_ be a valid commit in the archive.
  # Otherwise, it'll return the max revision (whether or not the
  # commit is valid or just a 0x40 placeholder).
  sub rev_map_max {
  	my ($self, $want_commit) = @_;
  	$self->rebuild;
  	my ($r, $c) = $self->rev_map_max_norebuild($want_commit);
  	$want_commit ? ($r, $c) : $r;
  }
  
  sub rev_map_max_norebuild {
  	my ($self, $want_commit) = @_;
  	my $map_path = $self->map_path;
  	stat $map_path or return $want_commit ? (0, undef) : 0;
  	sysopen(my $fh, $map_path, O_RDONLY) or croak "open: $!";
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	if ($size == 0) {
  		close $fh or croak "close: $!";
  		return $want_commit ? (0, undef) : 0;
  	}
  
  	sysseek($fh, -24, SEEK_END) or croak "seek: $!";
  	sysread($fh, my $buf, 24) == 24 or croak "read: $!";
  	my ($r, $c) = unpack(rev_map_fmt, $buf);
  	if ($want_commit && $c eq ('0' x40)) {
  		if ($size < 48) {
  			return $want_commit ? (0, undef) : 0;
  		}
  		sysseek($fh, -48, SEEK_END) or croak "seek: $!";
  		sysread($fh, $buf, 24) == 24 or croak "read: $!";
  		($r, $c) = unpack(rev_map_fmt, $buf);
  		if ($c eq ('0'x40)) {
  			croak "Penultimate record is all-zeroes in $map_path";
  		}
  	}
  	close $fh or croak "close: $!";
  	$want_commit ? ($r, $c) : $r;
  }
  
  sub rev_map_get {
  	my ($self, $rev, $uuid) = @_;
  	my $map_path = $self->map_path($uuid);
  	return undef unless -e $map_path;
  
  	sysopen(my $fh, $map_path, O_RDONLY) or croak "open: $!";
  	my $c = _rev_map_get($fh, $rev);
  	close($fh) or croak "close: $!";
  	$c
  }
  
  sub _rev_map_get {
  	my ($fh, $rev) = @_;
  
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	if ($size == 0) {
  		return undef;
  	}
  
  	my ($l, $u) = (0, $size - 24);
  	my ($r, $c, $buf);
  
  	while ($l <= $u) {
  		my $i = int(($l/24 + $u/24) / 2) * 24;
  		sysseek($fh, $i, SEEK_SET) or croak "seek: $!";
  		sysread($fh, my $buf, 24) == 24 or croak "read: $!";
  		my ($r, $c) = unpack(rev_map_fmt, $buf);
  
  		if ($r < $rev) {
  			$l = $i + 24;
  		} elsif ($r > $rev) {
  			$u = $i - 24;
  		} else { # $r == $rev
  			return $c eq ('0' x 40) ? undef : $c;
  		}
  	}
  	undef;
  }
  
  # Finds the first svn revision that exists on (if $eq_ok is true) or
  # before $rev for the current branch.  It will not search any lower
  # than $min_rev.  Returns the git commit hash and svn revision number
  # if found, else (undef, undef).
  sub find_rev_before {
  	my ($self, $rev, $eq_ok, $min_rev) = @_;
  	--$rev unless $eq_ok;
  	$min_rev ||= 1;
  	my $max_rev = $self->rev_map_max;
  	$rev = $max_rev if ($rev > $max_rev);
  	while ($rev >= $min_rev) {
  		if (my $c = $self->rev_map_get($rev)) {
  			return ($rev, $c);
  		}
  		--$rev;
  	}
  	return (undef, undef);
  }
  
  # Finds the first svn revision that exists on (if $eq_ok is true) or
  # after $rev for the current branch.  It will not search any higher
  # than $max_rev.  Returns the git commit hash and svn revision number
  # if found, else (undef, undef).
  sub find_rev_after {
  	my ($self, $rev, $eq_ok, $max_rev) = @_;
  	++$rev unless $eq_ok;
  	$max_rev ||= $self->rev_map_max;
  	while ($rev <= $max_rev) {
  		if (my $c = $self->rev_map_get($rev)) {
  			return ($rev, $c);
  		}
  		++$rev;
  	}
  	return (undef, undef);
  }
  
  sub _new {
  	my ($class, $repo_id, $ref_id, $path) = @_;
  	unless (defined $repo_id && length $repo_id) {
  		$repo_id = $default_repo_id;
  	}
  	unless (defined $ref_id && length $ref_id) {
  		# Access the prefix option from the git-svn main program if it's loaded.
  		my $prefix = defined &::opt_prefix ? ::opt_prefix() : "";
  		$_[2] = $ref_id =
  		             "refs/remotes/$prefix$default_ref_id";
  	}
  	$_[1] = $repo_id;
  	my $svn_dir = svn_dir();
  	my $dir = "$svn_dir/$ref_id";
  
  	# Older repos imported by us used $svn_dir/foo instead of
  	# $svn_dir/refs/remotes/foo when tracking refs/remotes/foo
  	if ($ref_id =~ m{^refs/remotes/(.+)}) {
  		my $old_dir = "$svn_dir/$1";
  		if (-d $old_dir && ! -d $dir) {
  			$dir = $old_dir;
  		}
  	}
  
  	$_[3] = $path = '' unless (defined $path);
  	mkpath([$dir]);
  	my $obj = bless {
  		ref_id => $ref_id, dir => $dir, index => "$dir/index",
  	        config => "$svn_dir/config",
  	        map_root => "$dir/.rev_map", repo_id => $repo_id }, $class;
  
  	# Ensure it gets canonicalized
  	$obj->path($path);
  
  	return $obj;
  }
  
  sub path {
  	my $self = shift;
  
  	if (@_) {
  		my $path = shift;
  		$self->{_path} = canonicalize_path($path);
  		return;
  	}
  
  	return $self->{_path};
  }
  
  sub url {
  	my $self = shift;
  
  	if (@_) {
  		my $url = shift;
  		$self->{url} = canonicalize_url($url);
  		return;
  	}
  
  	return $self->{url};
  }
  
  # for read-only access of old .rev_db formats
  sub unlink_rev_db_symlink {
  	my ($self) = @_;
  	my $link = $self->rev_db_path;
  	$link =~ s/\.[\w-]+$// or croak "missing UUID at the end of $link";
  	if (-l $link) {
  		unlink $link or croak "unlink: $link failed!";
  	}
  }
  
  sub rev_db_path {
  	my ($self, $uuid) = @_;
  	my $db_path = $self->map_path($uuid);
  	$db_path =~ s{/\.rev_map\.}{/\.rev_db\.}
  	    or croak "map_path: $db_path does not contain '/.rev_map.' !";
  	$db_path;
  }
  
  # the new replacement for .rev_db
  sub map_path {
  	my ($self, $uuid) = @_;
  	$uuid ||= $self->ra_uuid;
  	"$self->{map_root}.$uuid";
  }
  
  sub uri_encode {
  	my ($f) = @_;
  	$f =~ s#([^a-zA-Z0-9\*!\:_\./\-])#sprintf("%%%02X",ord($1))#eg;
  	$f
  }
  
  sub uri_decode {
  	my ($f) = @_;
  	$f =~ s#%([0-9a-fA-F]{2})#chr(hex($1))#eg;
  	$f
  }
  
  sub remove_username {
  	$_[0] =~ s{^([^:]*://)[^@]+@}{$1};
  }
  
  1;
GIT_SVN

$fatpacked{"Git/SVN/Editor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_EDITOR';
  package Git::SVN::Editor;
  use vars qw/@ISA $_rmdir $_cp_similarity $_find_copies_harder $_rename_limit/;
  use strict;
  use warnings;
  use SVN::Core;
  use SVN::Delta;
  use Carp qw/croak/;
  use Git qw/command command_oneline command_noisy command_output_pipe
             command_input_pipe command_close_pipe
             command_bidi_pipe command_close_bidi_pipe
             get_record/;
  
  BEGIN {
  	@ISA = qw(SVN::Delta::Editor);
  }
  
  sub new {
  	my ($class, $opts) = @_;
  	foreach (qw/svn_path r ra tree_a tree_b log editor_cb/) {
  		die "$_ required!\n" unless (defined $opts->{$_});
  	}
  
  	my $pool = SVN::Pool->new;
  	my $mods = generate_diff($opts->{tree_a}, $opts->{tree_b});
  	my $types = check_diff_paths($opts->{ra}, $opts->{svn_path},
  	                             $opts->{r}, $mods);
  
  	# $opts->{ra} functions should not be used after this:
  	my @ce  = $opts->{ra}->get_commit_editor($opts->{log},
  	                                        $opts->{editor_cb}, $pool);
  	my $self = SVN::Delta::Editor->new(@ce, $pool);
  	bless $self, $class;
  	foreach (qw/svn_path r tree_a tree_b/) {
  		$self->{$_} = $opts->{$_};
  	}
  	$self->{url} = $opts->{ra}->{url};
  	$self->{mods} = $mods;
  	$self->{types} = $types;
  	$self->{pool} = $pool;
  	$self->{bat} = { '' => $self->open_root($self->{r}, $self->{pool}) };
  	$self->{rm} = { };
  	$self->{path_prefix} = length $self->{svn_path} ?
  	                       "$self->{svn_path}/" : '';
  	$self->{config} = $opts->{config};
  	$self->{mergeinfo} = $opts->{mergeinfo};
  	$self->{pathnameencoding} = Git::config('svn.pathnameencoding');
  	return $self;
  }
  
  sub generate_diff {
  	my ($tree_a, $tree_b) = @_;
  	my @diff_tree = qw(diff-tree -z -r);
  	if ($_cp_similarity) {
  		push @diff_tree, "-C$_cp_similarity";
  	} else {
  		push @diff_tree, '-C';
  	}
  	push @diff_tree, '--find-copies-harder' if $_find_copies_harder;
  	push @diff_tree, "-l$_rename_limit" if defined $_rename_limit;
  	push @diff_tree, $tree_a, $tree_b;
  	my ($diff_fh, $ctx) = command_output_pipe(@diff_tree);
  	my $state = 'meta';
  	my @mods;
  	while (defined($_ = get_record($diff_fh, "\0"))) {
  		if ($state eq 'meta' && /^:(\d{6})\s(\d{6})\s
  					($::sha1)\s($::sha1)\s
  					([MTCRAD])\d*$/xo) {
  			push @mods, {	mode_a => $1, mode_b => $2,
  					sha1_a => $3, sha1_b => $4,
  					chg => $5 };
  			if ($5 =~ /^(?:C|R)$/) {
  				$state = 'file_a';
  			} else {
  				$state = 'file_b';
  			}
  		} elsif ($state eq 'file_a') {
  			my $x = $mods[$#mods] or croak "Empty array\n";
  			if ($x->{chg} !~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			$x->{file_a} = $_;
  			$state = 'file_b';
  		} elsif ($state eq 'file_b') {
  			my $x = $mods[$#mods] or croak "Empty array\n";
  			if (exists $x->{file_a} && $x->{chg} !~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			if (!exists $x->{file_a} && $x->{chg} =~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			$x->{file_b} = $_;
  			$state = 'meta';
  		} else {
  			croak "Error parsing $_\n";
  		}
  	}
  	command_close_pipe($diff_fh, $ctx);
  	\@mods;
  }
  
  sub check_diff_paths {
  	my ($ra, $pfx, $rev, $mods) = @_;
  	my %types;
  	$pfx .= '/' if length $pfx;
  
  	sub type_diff_paths {
  		my ($ra, $types, $path, $rev) = @_;
  		my @p = split m#/+#, $path;
  		my $c = shift @p;
  		unless (defined $types->{$c}) {
  			$types->{$c} = $ra->check_path($c, $rev);
  		}
  		while (@p) {
  			$c .= '/' . shift @p;
  			next if defined $types->{$c};
  			$types->{$c} = $ra->check_path($c, $rev);
  		}
  	}
  
  	foreach my $m (@$mods) {
  		foreach my $f (qw/file_a file_b/) {
  			next unless defined $m->{$f};
  			my ($dir) = ($m->{$f} =~ m#^(.*?)/?(?:[^/]+)$#);
  			if (length $pfx.$dir && ! defined $types{$dir}) {
  				type_diff_paths($ra, \%types, $pfx.$dir, $rev);
  			}
  		}
  	}
  	\%types;
  }
  
  sub split_path {
  	return ($_[0] =~ m#^(.*?)/?([^/]+)$#);
  }
  
  sub repo_path {
  	my ($self, $path) = @_;
  	if (my $enc = $self->{pathnameencoding}) {
  		require Encode;
  		Encode::from_to($path, $enc, 'UTF-8');
  	}
  	$self->{path_prefix}.(defined $path ? $path : '');
  }
  
  sub url_path {
  	my ($self, $path) = @_;
  	$path = $self->repo_path($path);
  	if ($self->{url} =~ m#^https?://#) {
  		# characters are taken from subversion/libsvn_subr/path.c
  		$path =~ s#([^~a-zA-Z0-9_./!$&'()*+,-])#sprintf("%%%02X",ord($1))#eg;
  	}
  	$self->{url} . '/' . $path;
  }
  
  sub rmdirs {
  	my ($self) = @_;
  	my $rm = $self->{rm};
  	delete $rm->{''}; # we never delete the url we're tracking
  	return unless %$rm;
  
  	foreach (keys %$rm) {
  		my @d = split m#/#, $_;
  		my $c = shift @d;
  		$rm->{$c} = 1;
  		while (@d) {
  			$c .= '/' . shift @d;
  			$rm->{$c} = 1;
  		}
  	}
  	delete $rm->{$self->{svn_path}};
  	delete $rm->{''}; # we never delete the url we're tracking
  	return unless %$rm;
  
  	my ($fh, $ctx) = command_output_pipe(qw/ls-tree --name-only -r -z/,
  	                                     $self->{tree_b});
  	while (defined($_ = get_record($fh, "\0"))) {
  		my @dn = split m#/#, $_;
  		while (pop @dn) {
  			delete $rm->{join '/', @dn};
  		}
  		unless (%$rm) {
  			close $fh;
  			return;
  		}
  	}
  	command_close_pipe($fh, $ctx);
  
  	my ($r, $p, $bat) = ($self->{r}, $self->{pool}, $self->{bat});
  	foreach my $d (sort { $b =~ tr#/#/# <=> $a =~ tr#/#/# } keys %$rm) {
  		$self->close_directory($bat->{$d}, $p);
  		my ($dn) = ($d =~ m#^(.*?)/?(?:[^/]+)$#);
  		print "\tD+\t$d/\n" unless $::_q;
  		$self->SUPER::delete_entry($d, $r, $bat->{$dn}, $p);
  		delete $bat->{$d};
  	}
  }
  
  sub open_or_add_dir {
  	my ($self, $full_path, $baton, $deletions) = @_;
  	my $t = $self->{types}->{$full_path};
  	if (!defined $t) {
  		die "$full_path not known in r$self->{r} or we have a bug!\n";
  	}
  	{
  		no warnings 'once';
  		# SVN::Node::none and SVN::Node::file are used only once,
  		# so we're shutting up Perl's warnings about them.
  		if ($t == $SVN::Node::none || defined($deletions->{$full_path})) {
  			return $self->add_directory($full_path, $baton,
  			    undef, -1, $self->{pool});
  		} elsif ($t == $SVN::Node::dir) {
  			return $self->open_directory($full_path, $baton,
  			    $self->{r}, $self->{pool});
  		} # no warnings 'once'
  		print STDERR "$full_path already exists in repository at ",
  		    "r$self->{r} and it is not a directory (",
  		    ($t == $SVN::Node::file ? 'file' : 'unknown'),"/$t)\n";
  	} # no warnings 'once'
  	exit 1;
  }
  
  sub ensure_path {
  	my ($self, $path, $deletions) = @_;
  	my $bat = $self->{bat};
  	my $repo_path = $self->repo_path($path);
  	return $bat->{''} unless (length $repo_path);
  
  	my @p = split m#/+#, $repo_path;
  	my $c = shift @p;
  	$bat->{$c} ||= $self->open_or_add_dir($c, $bat->{''}, $deletions);
  	while (@p) {
  		my $c0 = $c;
  		$c .= '/' . shift @p;
  		$bat->{$c} ||= $self->open_or_add_dir($c, $bat->{$c0}, $deletions);
  	}
  	return $bat->{$c};
  }
  
  # Subroutine to convert a globbing pattern to a regular expression.
  # From perl cookbook.
  sub glob2pat {
  	my $globstr = shift;
  	my %patmap = ('*' => '.*', '?' => '.', '[' => '[', ']' => ']');
  	$globstr =~ s{(.)} { $patmap{$1} || "\Q$1" }ge;
  	return '^' . $globstr . '$';
  }
  
  sub check_autoprop {
  	my ($self, $pattern, $properties, $file, $fbat) = @_;
  	# Convert the globbing pattern to a regular expression.
  	my $regex = glob2pat($pattern);
  	# Check if the pattern matches the file name.
  	if($file =~ m/($regex)/) {
  		# Parse the list of properties to set.
  		my @props = split(/;/, $properties);
  		foreach my $prop (@props) {
  			# Parse 'name=value' syntax and set the property.
  			if ($prop =~ /([^=]+)=(.*)/) {
  				my ($n,$v) = ($1,$2);
  				for ($n, $v) {
  					s/^\s+//; s/\s+$//;
  				}
  				$self->change_file_prop($fbat, $n, $v);
  			}
  		}
  	}
  }
  
  sub apply_autoprops {
  	my ($self, $file, $fbat) = @_;
  	my $conf_t = ${$self->{config}}{'config'};
  	no warnings 'once';
  	# Check [miscellany]/enable-auto-props in svn configuration.
  	if (SVN::_Core::svn_config_get_bool(
  		$conf_t,
  		$SVN::_Core::SVN_CONFIG_SECTION_MISCELLANY,
  		$SVN::_Core::SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS,
  		0)) {
  		# Auto-props are enabled.  Enumerate them to look for matches.
  		my $callback = sub {
  			$self->check_autoprop($_[0], $_[1], $file, $fbat);
  		};
  		SVN::_Core::svn_config_enumerate(
  			$conf_t,
  			$SVN::_Core::SVN_CONFIG_SECTION_AUTO_PROPS,
  			$callback);
  	}
  }
  
  sub check_attr {
  	my ($attr,$path) = @_;
  	my $val = command_oneline("check-attr", $attr, "--", $path);
  	if ($val) { $val =~ s/^[^:]*:\s*[^:]*:\s*(.*)\s*$/$1/; }
  	return $val;
  }
  
  sub apply_manualprops {
  	my ($self, $file, $fbat) = @_;
  	my $pending_properties = check_attr( "svn-properties", $file );
  	if ($pending_properties eq "") { return; }
  	# Parse the list of properties to set.
  	my @props = split(/;/, $pending_properties);
  	# TODO: get existing properties to compare to
  	# - this fails for add so currently not done
  	# my $existing_props = ::get_svnprops($file);
  	my $existing_props = {};
  	# TODO: caching svn properties or storing them in .gitattributes
  	# would make that faster
  	foreach my $prop (@props) {
  		# Parse 'name=value' syntax and set the property.
  		if ($prop =~ /([^=]+)=(.*)/) {
  			my ($n,$v) = ($1,$2);
  			for ($n, $v) {
  				s/^\s+//; s/\s+$//;
  			}
  			my $existing = $existing_props->{$n};
  			if (!defined($existing) || $existing ne $v) {
  			    $self->change_file_prop($fbat, $n, $v);
  			}
  		}
  	}
  }
  
  sub A {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  					undef, -1);
  	print "\tA\t$m->{file_b}\n" unless $::_q;
  	$self->apply_autoprops($file, $fbat);
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub C {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	# workaround for a bug in svn serf backend (v1.8.5 and below):
  	# store third argument to ->add_file() in a local variable, to make it
  	# have the same lifetime as $fbat
  	my $upa = $self->url_path($m->{file_a});
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  				$upa, $self->{r});
  	print "\tC\t$m->{file_a} => $m->{file_b}\n" unless $::_q;
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub delete_entry {
  	my ($self, $path, $pbat) = @_;
  	my $rpath = $self->repo_path($path);
  	my ($dir, $file) = split_path($rpath);
  	$self->{rm}->{$dir} = 1;
  	$self->SUPER::delete_entry($rpath, $self->{r}, $pbat, $self->{pool});
  }
  
  sub R {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	# workaround for a bug in svn serf backend, see comment in C() above
  	my $upa = $self->url_path($m->{file_a});
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  				$upa, $self->{r});
  	print "\tR\t$m->{file_a} => $m->{file_b}\n" unless $::_q;
  	$self->apply_autoprops($file, $fbat);
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  
  	($dir, $file) = split_path($m->{file_a});
  	$pbat = $self->ensure_path($dir, $deletions);
  	$self->delete_entry($m->{file_a}, $pbat);
  }
  
  sub M {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	my $fbat = $self->open_file($self->repo_path($m->{file_b}),
  				$pbat,$self->{r},$self->{pool});
  	print "\t$m->{chg}\t$m->{file_b}\n" unless $::_q;
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub T {
  	my ($self, $m, $deletions) = @_;
  
  	# Work around subversion issue 4091: toggling the "is a
  	# symlink" property requires removing and re-adding a
  	# file or else "svn up" on affected clients trips an
  	# assertion and aborts.
  	if (($m->{mode_b} =~ /^120/ && $m->{mode_a} !~ /^120/) ||
  	    ($m->{mode_b} !~ /^120/ && $m->{mode_a} =~ /^120/)) {
  		$self->D({
  			mode_a => $m->{mode_a}, mode_b => '000000',
  			sha1_a => $m->{sha1_a}, sha1_b => '0' x 40,
  			chg => 'D', file_b => $m->{file_b}
  		}, $deletions);
  		$self->A({
  			mode_a => '000000', mode_b => $m->{mode_b},
  			sha1_a => '0' x 40, sha1_b => $m->{sha1_b},
  			chg => 'A', file_b => $m->{file_b}
  		}, $deletions);
  		return;
  	}
  
  	$self->M($m, $deletions);
  }
  
  sub change_file_prop {
  	my ($self, $fbat, $pname, $pval) = @_;
  	$self->SUPER::change_file_prop($fbat, $pname, $pval, $self->{pool});
  }
  
  sub change_dir_prop {
  	my ($self, $pbat, $pname, $pval) = @_;
  	$self->SUPER::change_dir_prop($pbat, $pname, $pval, $self->{pool});
  }
  
  sub _chg_file_get_blob ($$$$) {
  	my ($self, $fbat, $m, $which) = @_;
  	my $fh = $::_repository->temp_acquire("git_blob_$which");
  	if ($m->{"mode_$which"} =~ /^120/) {
  		print $fh 'link ' or croak $!;
  		$self->change_file_prop($fbat,'svn:special','*');
  	} elsif ($m->{mode_a} =~ /^120/ && $m->{"mode_$which"} !~ /^120/) {
  		$self->change_file_prop($fbat,'svn:special',undef);
  	}
  	my $blob = $m->{"sha1_$which"};
  	return ($fh,) if ($blob =~ /^0{40}$/);
  	my $size = $::_repository->cat_blob($blob, $fh);
  	croak "Failed to read object $blob" if ($size < 0);
  	$fh->flush == 0 or croak $!;
  	seek $fh, 0, 0 or croak $!;
  
  	my $exp = ::md5sum($fh);
  	seek $fh, 0, 0 or croak $!;
  	return ($fh, $exp);
  }
  
  sub chg_file {
  	my ($self, $fbat, $m) = @_;
  	if ($m->{mode_b} =~ /755$/ && $m->{mode_a} !~ /755$/) {
  		$self->change_file_prop($fbat,'svn:executable','*');
  	} elsif ($m->{mode_b} !~ /755$/ && $m->{mode_a} =~ /755$/) {
  		$self->change_file_prop($fbat,'svn:executable',undef);
  	}
  	my ($fh_a, $exp_a) = _chg_file_get_blob $self, $fbat, $m, 'a';
  	my ($fh_b, $exp_b) = _chg_file_get_blob $self, $fbat, $m, 'b';
  	my $pool = SVN::Pool->new;
  	my $atd = $self->apply_textdelta($fbat, $exp_a, $pool);
  	if (-s $fh_a) {
  		my $txstream = SVN::TxDelta::new ($fh_a, $fh_b, $pool);
  		my $res = SVN::TxDelta::send_txstream($txstream, @$atd, $pool);
  		if (defined $res) {
  			die "Unexpected result from send_txstream: $res\n",
  			    "(SVN::Core::VERSION: $SVN::Core::VERSION)\n";
  		}
  	} else {
  		my $got = SVN::TxDelta::send_stream($fh_b, @$atd, $pool);
  		die "Checksum mismatch\nexpected: $exp_b\ngot: $got\n"
  		    if ($got ne $exp_b);
  	}
  	Git::temp_release($fh_b, 1);
  	Git::temp_release($fh_a, 1);
  	$pool->clear;
  }
  
  sub D {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	print "\tD\t$m->{file_b}\n" unless $::_q;
  	$self->delete_entry($m->{file_b}, $pbat);
  }
  
  sub close_edit {
  	my ($self) = @_;
  	my ($p,$bat) = ($self->{pool}, $self->{bat});
  	foreach (sort { $b =~ tr#/#/# <=> $a =~ tr#/#/# } keys %$bat) {
  		next if $_ eq '';
  		$self->close_directory($bat->{$_}, $p);
  	}
  	$self->close_directory($bat->{''}, $p);
  	$self->SUPER::close_edit($p);
  	$p->clear;
  }
  
  sub abort_edit {
  	my ($self) = @_;
  	$self->SUPER::abort_edit($self->{pool});
  }
  
  sub DESTROY {
  	my $self = shift;
  	$self->SUPER::DESTROY(@_);
  	$self->{pool}->clear;
  }
  
  # this drives the editor
  sub apply_diff {
  	my ($self) = @_;
  	my $mods = $self->{mods};
  	my %o = ( D => 0, C => 1, R => 2, A => 3, M => 4, T => 5 );
  	my %deletions;
  
  	foreach my $m (@$mods) {
  		if ($m->{chg} eq "D") {
  			$deletions{$m->{file_b}} = 1;
  		}
  	}
  
  	foreach my $m (sort { $o{$a->{chg}} <=> $o{$b->{chg}} } @$mods) {
  		my $f = $m->{chg};
  		if (defined $o{$f}) {
  			$self->$f($m, \%deletions);
  		} else {
  			fatal("Invalid change type: $f");
  		}
  	}
  
  	if (defined($self->{mergeinfo})) {
  		$self->change_dir_prop($self->{bat}{''}, "svn:mergeinfo",
  			               $self->{mergeinfo});
  	}
  	$self->rmdirs if $_rmdir;
  	if (@$mods == 0 && !defined($self->{mergeinfo})) {
  		$self->abort_edit;
  	} else {
  		$self->close_edit;
  	}
  	return scalar @$mods;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Editor - commit driver for "git svn set-tree" and dcommit
  
  =head1 SYNOPSIS
  
  	use Git::SVN::Editor;
  	use Git::SVN::Ra;
  
  	my $ra = Git::SVN::Ra->new($url);
  	my %opts = (
  		r => 19,
  		log => "log message",
  		ra => $ra,
  		config => SVN::Core::config_get_config($svn_config_dir),
  		tree_a => "$commit^",
  		tree_b => "$commit",
  		editor_cb => sub { print "Committed r$_[0]\n"; },
  		mergeinfo => "/branches/foo:1-10",
  		svn_path => "trunk"
  	);
  	Git::SVN::Editor->new(\%opts)->apply_diff or print "No changes\n";
  
  	my $re = Git::SVN::Editor::glob2pat("trunk/*");
  	if ($branchname =~ /$re/) {
  		print "matched!\n";
  	}
  
  =head1 DESCRIPTION
  
  This module is an implementation detail of the "git svn" command.
  Do not use it unless you are developing git-svn.
  
  This module adapts the C<SVN::Delta::Editor> object returned by
  C<SVN::Delta::get_commit_editor> and drives it to convey the
  difference between two git tree objects to a remote Subversion
  repository.
  
  The interface will change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  Subversion perl bindings,
  the core L<Carp> module,
  and git's L<Git> helper module.
  
  C<Git::SVN::Editor> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Delta>,
  L<Git::SVN::Fetcher>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_EDITOR

$fatpacked{"Git/SVN/Fetcher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_FETCHER';
  package Git::SVN::Fetcher;
  use vars qw/@ISA $_ignore_regex $_include_regex $_preserve_empty_dirs
              $_placeholder_filename @deleted_gpath %added_placeholder
              $repo_id/;
  use strict;
  use warnings;
  use SVN::Delta;
  use Carp qw/croak/;
  use File::Basename qw/dirname/;
  use Git qw/command command_oneline command_noisy command_output_pipe
             command_input_pipe command_close_pipe
             command_bidi_pipe command_close_bidi_pipe
             get_record/;
  BEGIN {
  	@ISA = qw(SVN::Delta::Editor);
  }
  
  # file baton members: path, mode_a, mode_b, pool, fh, blob, base
  sub new {
  	my ($class, $git_svn, $switch_path) = @_;
  	my $self = SVN::Delta::Editor->new;
  	bless $self, $class;
  	if (exists $git_svn->{last_commit}) {
  		$self->{c} = $git_svn->{last_commit};
  		$self->{empty_symlinks} =
  		                  _mark_empty_symlinks($git_svn, $switch_path);
  	}
  
  	# some options are read globally, but can be overridden locally
  	# per [svn-remote "..."] section.  Command-line options will *NOT*
  	# override options set in an [svn-remote "..."] section
  	$repo_id = $git_svn->{repo_id};
  	my $k = "svn-remote.$repo_id.ignore-paths";
  	my $v = eval { command_oneline('config', '--get', $k) };
  	$self->{ignore_regex} = $v;
  
  	$k = "svn-remote.$repo_id.include-paths";
  	$v = eval { command_oneline('config', '--get', $k) };
  	$self->{include_regex} = $v;
  
  	$k = "svn-remote.$repo_id.preserve-empty-dirs";
  	$v = eval { command_oneline('config', '--get', '--bool', $k) };
  	if ($v && $v eq 'true') {
  		$_preserve_empty_dirs = 1;
  		$k = "svn-remote.$repo_id.placeholder-filename";
  		$v = eval { command_oneline('config', '--get', $k) };
  		$_placeholder_filename = $v;
  	}
  
  	# Load the list of placeholder files added during previous invocations.
  	$k = "svn-remote.$repo_id.added-placeholder";
  	$v = eval { command_oneline('config', '--get-all', $k) };
  	if ($_preserve_empty_dirs && $v) {
  		# command() prints errors to stderr, so we only call it if
  		# command_oneline() succeeded.
  		my @v = command('config', '--get-all', $k);
  		$added_placeholder{ dirname($_) } = $_ foreach @v;
  	}
  
  	$self->{empty} = {};
  	$self->{dir_prop} = {};
  	$self->{file_prop} = {};
  	$self->{absent_dir} = {};
  	$self->{absent_file} = {};
  	require Git::IndexInfo;
  	$self->{gii} = $git_svn->tmp_index_do(sub { Git::IndexInfo->new });
  	$self->{pathnameencoding} = Git::config('svn.pathnameencoding');
  	$self;
  }
  
  # this uses the Ra object, so it must be called before do_{switch,update},
  # not inside them (when the Git::SVN::Fetcher object is passed) to
  # do_{switch,update}
  sub _mark_empty_symlinks {
  	my ($git_svn, $switch_path) = @_;
  	my $bool = Git::config_bool('svn.brokenSymlinkWorkaround');
  	return {} if (!defined($bool)) || (defined($bool) && ! $bool);
  
  	my %ret;
  	my ($rev, $cmt) = $git_svn->last_rev_commit;
  	return {} unless ($rev && $cmt);
  
  	# allow the warning to be printed for each revision we fetch to
  	# ensure the user sees it.  The user can also disable the workaround
  	# on the repository even while git svn is running and the next
  	# revision fetched will skip this expensive function.
  	my $printed_warning;
  	chomp(my $empty_blob = `git hash-object -t blob --stdin < /dev/null`);
  	my ($ls, $ctx) = command_output_pipe(qw/ls-tree -r -z/, $cmt);
  	my $pfx = defined($switch_path) ? $switch_path : $git_svn->path;
  	$pfx .= '/' if length($pfx);
  	while (defined($_ = get_record($ls, "\0"))) {
  		s/\A100644 blob $empty_blob\t//o or next;
  		unless ($printed_warning) {
  			print STDERR "Scanning for empty symlinks, ",
  			             "this may take a while if you have ",
  				     "many empty files\n",
  				     "You may disable this with `",
  				     "git config svn.brokenSymlinkWorkaround ",
  				     "false'.\n",
  				     "This may be done in a different ",
  				     "terminal without restarting ",
  				     "git svn\n";
  			$printed_warning = 1;
  		}
  		my $path = $_;
  		my (undef, $props) =
  		               $git_svn->ra->get_file($pfx.$path, $rev, undef);
  		if ($props->{'svn:special'}) {
  			$ret{$path} = 1;
  		}
  	}
  	command_close_pipe($ls, $ctx);
  	\%ret;
  }
  
  # returns true if a given path is inside a ".git" directory
  sub in_dot_git {
  	$_[0] =~ m{(?:^|/)\.git(?:/|$)};
  }
  
  # return value: 0 -- don't ignore, 1 -- ignore
  # This will also check whether the path is explicitly included
  sub is_path_ignored {
  	my ($self, $path) = @_;
  	return 1 if in_dot_git($path);
  	return 1 if defined($self->{ignore_regex}) &&
  	            $path =~ m!$self->{ignore_regex}!;
  	return 0 if defined($self->{include_regex}) &&
  	            $path =~ m!$self->{include_regex}!;
  	return 0 if defined($_include_regex) &&
  	            $path =~ m!$_include_regex!;
  	return 1 if defined($self->{include_regex});
  	return 1 if defined($_include_regex);
  	return 0 unless defined($_ignore_regex);
  	return 1 if $path =~ m!$_ignore_regex!o;
  	return 0;
  }
  
  sub set_path_strip {
  	my ($self, $path) = @_;
  	$self->{path_strip} = qr/^\Q$path\E(\/|$)/ if length $path;
  }
  
  sub open_root {
  	{ path => '' };
  }
  
  sub open_directory {
  	my ($self, $path, $pb, $rev) = @_;
  	{ path => $path };
  }
  
  sub git_path {
  	my ($self, $path) = @_;
  	if (my $enc = $self->{pathnameencoding}) {
  		require Encode;
  		Encode::from_to($path, 'UTF-8', $enc);
  	}
  	if ($self->{path_strip}) {
  		$path =~ s!$self->{path_strip}!! or
  		  die "Failed to strip path '$path' ($self->{path_strip})\n";
  	}
  	$path;
  }
  
  sub delete_entry {
  	my ($self, $path, $rev, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  
  	my $gpath = $self->git_path($path);
  	return undef if ($gpath eq '');
  
  	# remove entire directories.
  	my ($tree) = (command('ls-tree', '-z', $self->{c}, "./$gpath")
  	                 =~ /\A040000 tree ([a-f\d]{40})\t\Q$gpath\E\0/);
  	if ($tree) {
  		my ($ls, $ctx) = command_output_pipe(qw/ls-tree
  		                                     -r --name-only -z/,
  				                     $tree);
  		while (defined($_ = get_record($ls, "\0"))) {
  			my $rmpath = "$gpath/$_";
  			$self->{gii}->remove($rmpath);
  			print "\tD\t$rmpath\n" unless $::_q;
  		}
  		print "\tD\t$gpath/\n" unless $::_q;
  		command_close_pipe($ls, $ctx);
  	} else {
  		$self->{gii}->remove($gpath);
  		print "\tD\t$gpath\n" unless $::_q;
  	}
  	# Don't add to @deleted_gpath if we're deleting a placeholder file.
  	push @deleted_gpath, $gpath unless $added_placeholder{dirname($path)};
  	$self->{empty}->{$path} = 0;
  	undef;
  }
  
  sub open_file {
  	my ($self, $path, $pb, $rev) = @_;
  	my ($mode, $blob);
  
  	goto out if $self->is_path_ignored($path);
  
  	my $gpath = $self->git_path($path);
  	($mode, $blob) = (command('ls-tree', '-z', $self->{c}, "./$gpath")
  	                     =~ /\A(\d{6}) blob ([a-f\d]{40})\t\Q$gpath\E\0/);
  	unless (defined $mode && defined $blob) {
  		die "$path was not found in commit $self->{c} (r$rev)\n";
  	}
  	if ($mode eq '100644' && $self->{empty_symlinks}->{$path}) {
  		$mode = '120000';
  	}
  out:
  	{ path => $path, mode_a => $mode, mode_b => $mode, blob => $blob,
  	  pool => SVN::Pool->new, action => 'M' };
  }
  
  sub add_file {
  	my ($self, $path, $pb, $cp_path, $cp_rev) = @_;
  	my $mode;
  
  	if (!$self->is_path_ignored($path)) {
  		my ($dir, $file) = ($path =~ m#^(.*?)/?([^/]+)$#);
  		delete $self->{empty}->{$dir};
  		$mode = '100644';
  
  		if ($added_placeholder{$dir}) {
  			# Remove our placeholder file, if we created one.
  			delete_entry($self, $added_placeholder{$dir})
  				unless $path eq $added_placeholder{$dir};
  			delete $added_placeholder{$dir}
  		}
  	}
  
  	{ path => $path, mode_a => $mode, mode_b => $mode,
  	  pool => SVN::Pool->new, action => 'A' };
  }
  
  sub add_directory {
  	my ($self, $path, $cp_path, $cp_rev) = @_;
  	goto out if $self->is_path_ignored($path);
  	my $gpath = $self->git_path($path);
  	if ($gpath eq '') {
  		my ($ls, $ctx) = command_output_pipe(qw/ls-tree
  		                                     -r --name-only -z/,
  				                     $self->{c});
  		while (defined($_ = get_record($ls, "\0"))) {
  			$self->{gii}->remove($_);
  			print "\tD\t$_\n" unless $::_q;
  			push @deleted_gpath, $gpath;
  		}
  		command_close_pipe($ls, $ctx);
  		$self->{empty}->{$path} = 0;
  	}
  	my ($dir, $file) = ($path =~ m#^(.*?)/?([^/]+)$#);
  	delete $self->{empty}->{$dir};
  	$self->{empty}->{$path} = 1;
  
  	if ($added_placeholder{$dir}) {
  		# Remove our placeholder file, if we created one.
  		delete_entry($self, $added_placeholder{$dir});
  		delete $added_placeholder{$dir}
  	}
  
  out:
  	{ path => $path };
  }
  
  sub change_dir_prop {
  	my ($self, $db, $prop, $value) = @_;
  	return undef if $self->is_path_ignored($db->{path});
  	$self->{dir_prop}->{$db->{path}} ||= {};
  	$self->{dir_prop}->{$db->{path}}->{$prop} = $value;
  	undef;
  }
  
  sub absent_directory {
  	my ($self, $path, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  	$self->{absent_dir}->{$pb->{path}} ||= [];
  	push @{$self->{absent_dir}->{$pb->{path}}}, $path;
  	undef;
  }
  
  sub absent_file {
  	my ($self, $path, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  	$self->{absent_file}->{$pb->{path}} ||= [];
  	push @{$self->{absent_file}->{$pb->{path}}}, $path;
  	undef;
  }
  
  sub change_file_prop {
  	my ($self, $fb, $prop, $value) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  	if ($prop eq 'svn:executable') {
  		if ($fb->{mode_b} != 120000) {
  			$fb->{mode_b} = defined $value ? 100755 : 100644;
  		}
  	} elsif ($prop eq 'svn:special') {
  		$fb->{mode_b} = defined $value ? 120000 : 100644;
  	} else {
  		$self->{file_prop}->{$fb->{path}} ||= {};
  		$self->{file_prop}->{$fb->{path}}->{$prop} = $value;
  	}
  	undef;
  }
  
  sub apply_textdelta {
  	my ($self, $fb, $exp) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  	my $suffix = 0;
  	++$suffix while $::_repository->temp_is_locked("svn_delta_${$}_$suffix");
  	my $fh = $::_repository->temp_acquire("svn_delta_${$}_$suffix");
  	# $fh gets auto-closed() by SVN::TxDelta::apply(),
  	# (but $base does not,) so dup() it for reading in close_file
  	open my $dup, '<&', $fh or croak $!;
  	my $base = $::_repository->temp_acquire("git_blob_${$}_$suffix");
  	# close_file may call temp_acquire on 'svn_hash', but because of the
  	# call chain, if the temp_acquire call from close_file ends up being the
  	# call that first creates the 'svn_hash' temp file, then the FileHandle
  	# that's created as a result will end up in an SVN::Pool that we clear
  	# in SVN::Ra::gs_fetch_loop_common.  Avoid that by making sure the
  	# 'svn_hash' FileHandle is already created before close_file is called.
  	my $tmp_fh = $::_repository->temp_acquire('svn_hash');
  	$::_repository->temp_release($tmp_fh, 1);
  
  	if ($fb->{blob}) {
  		my ($base_is_link, $size);
  
  		if ($fb->{mode_a} eq '120000' &&
  		    ! $self->{empty_symlinks}->{$fb->{path}}) {
  			print $base 'link ' or die "print $!\n";
  			$base_is_link = 1;
  		}
  	retry:
  		$size = $::_repository->cat_blob($fb->{blob}, $base);
  		die "Failed to read object $fb->{blob}" if ($size < 0);
  
  		if (defined $exp) {
  			seek $base, 0, 0 or croak $!;
  			my $got = ::md5sum($base);
  			if ($got ne $exp) {
  				my $err = "Checksum mismatch: ".
  				       "$fb->{path} $fb->{blob}\n" .
  				       "expected: $exp\n" .
  				       "     got: $got\n";
  				if ($base_is_link) {
  					warn $err,
  					     "Retrying... (possibly ",
  					     "a bad symlink from SVN)\n";
  					$::_repository->temp_reset($base);
  					$base_is_link = 0;
  					goto retry;
  				}
  				die $err;
  			}
  		}
  	}
  	seek $base, 0, 0 or croak $!;
  	$fb->{fh} = $fh;
  	$fb->{base} = $base;
  	[ SVN::TxDelta::apply($base, $dup, undef, $fb->{path}, $fb->{pool}) ];
  }
  
  sub close_file {
  	my ($self, $fb, $exp) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  
  	my $hash;
  	my $path = $self->git_path($fb->{path});
  	if (my $fh = $fb->{fh}) {
  		if (defined $exp) {
  			seek($fh, 0, 0) or croak $!;
  			my $got = ::md5sum($fh);
  			if ($got ne $exp) {
  				die "Checksum mismatch: $path\n",
  				    "expected: $exp\n    got: $got\n";
  			}
  		}
  		if ($fb->{mode_b} == 120000) {
  			sysseek($fh, 0, 0) or croak $!;
  			my $rd = sysread($fh, my $buf, 5);
  
  			if (!defined $rd) {
  				croak "sysread: $!\n";
  			} elsif ($rd == 0) {
  				warn "$path has mode 120000",
  				     " but it points to nothing\n",
  				     "converting to an empty file with mode",
  				     " 100644\n";
  				$fb->{mode_b} = '100644';
  			} elsif ($buf ne 'link ') {
  				warn "$path has mode 120000",
  				     " but is not a link\n";
  			} else {
  				my $tmp_fh = $::_repository->temp_acquire(
  					'svn_hash');
  				my $res;
  				while ($res = sysread($fh, my $str, 1024)) {
  					my $out = syswrite($tmp_fh, $str, $res);
  					defined($out) && $out == $res
  						or croak("write ",
  							Git::temp_path($tmp_fh),
  							": $!\n");
  				}
  				defined $res or croak $!;
  
  				($fh, $tmp_fh) = ($tmp_fh, $fh);
  				Git::temp_release($tmp_fh, 1);
  			}
  		}
  
  		$hash = $::_repository->hash_and_insert_object(
  				Git::temp_path($fh));
  		$hash =~ /^[a-f\d]{40}$/ or die "not a sha1: $hash\n";
  
  		Git::temp_release($fb->{base}, 1);
  		Git::temp_release($fh, 1);
  	} else {
  		$hash = $fb->{blob} or die "no blob information\n";
  	}
  	$fb->{pool}->clear;
  	$self->{gii}->update($fb->{mode_b}, $hash, $path) or croak $!;
  	print "\t$fb->{action}\t$path\n" if $fb->{action} && ! $::_q;
  	undef;
  }
  
  sub abort_edit {
  	my $self = shift;
  	$self->{nr} = $self->{gii}->{nr};
  	delete $self->{gii};
  	$self->SUPER::abort_edit(@_);
  }
  
  sub close_edit {
  	my $self = shift;
  
  	if ($_preserve_empty_dirs) {
  		my @empty_dirs;
  
  		# Any entry flagged as empty that also has an associated
  		# dir_prop represents a newly created empty directory.
  		foreach my $i (keys %{$self->{empty}}) {
  			push @empty_dirs, $i if exists $self->{dir_prop}->{$i};
  		}
  
  		# Search for directories that have become empty due subsequent
  		# file deletes.
  		push @empty_dirs, $self->find_empty_directories();
  
  		# Finally, add a placeholder file to each empty directory.
  		$self->add_placeholder_file($_) foreach (@empty_dirs);
  
  		$self->stash_placeholder_list();
  	}
  
  	$self->{git_commit_ok} = 1;
  	$self->{nr} = $self->{gii}->{nr};
  	delete $self->{gii};
  	$self->SUPER::close_edit(@_);
  }
  
  sub find_empty_directories {
  	my ($self) = @_;
  	my @empty_dirs;
  	my %dirs = map { dirname($_) => 1 } @deleted_gpath;
  
  	foreach my $dir (sort keys %dirs) {
  		next if $dir eq ".";
  
  		# If there have been any additions to this directory, there is
  		# no reason to check if it is empty.
  		my $skip_added = 0;
  		foreach my $t (qw/dir_prop file_prop/) {
  			foreach my $path (keys %{ $self->{$t} }) {
  				if (exists $self->{$t}->{dirname($path)}) {
  					$skip_added = 1;
  					last;
  				}
  			}
  			last if $skip_added;
  		}
  		next if $skip_added;
  
  		# Use `git ls-tree` to get the filenames of this directory
  		# that existed prior to this particular commit.
  		my $ls = command('ls-tree', '-z', '--name-only',
  				 $self->{c}, "$dir/");
  		my %files = map { $_ => 1 } split(/\0/, $ls);
  
  		# Remove the filenames that were deleted during this commit.
  		delete $files{$_} foreach (@deleted_gpath);
  
  		# Report the directory if there are no filenames left.
  		push @empty_dirs, $dir unless (scalar %files);
  	}
  	@empty_dirs;
  }
  
  sub add_placeholder_file {
  	my ($self, $dir) = @_;
  	my $path = "$dir/$_placeholder_filename";
  	my $gpath = $self->git_path($path);
  
  	my $fh = $::_repository->temp_acquire($gpath);
  	my $hash = $::_repository->hash_and_insert_object(Git::temp_path($fh));
  	Git::temp_release($fh, 1);
  	$self->{gii}->update('100644', $hash, $gpath) or croak $!;
  
  	# The directory should no longer be considered empty.
  	delete $self->{empty}->{$dir} if exists $self->{empty}->{$dir};
  
  	# Keep track of any placeholder files we create.
  	$added_placeholder{$dir} = $path;
  }
  
  sub stash_placeholder_list {
  	my ($self) = @_;
  	my $k = "svn-remote.$repo_id.added-placeholder";
  	my $v = eval { command_oneline('config', '--get-all', $k) };
  	command_noisy('config', '--unset-all', $k) if $v;
  	foreach (values %added_placeholder) {
  		command_noisy('config', '--add', $k, $_);
  	}
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Fetcher - tree delta consumer for "git svn fetch"
  
  =head1 SYNOPSIS
  
      use SVN::Core;
      use SVN::Ra;
      use Git::SVN;
      use Git::SVN::Fetcher;
      use Git;
  
      my $gs = Git::SVN->find_by_url($url);
      my $ra = SVN::Ra->new(url => $url);
      my $editor = Git::SVN::Fetcher->new($gs);
      my $reporter = $ra->do_update($SVN::Core::INVALID_REVNUM, '',
                                    1, $editor);
      $reporter->set_path('', $old_rev, 0);
      $reporter->finish_report;
      my $tree = $gs->tmp_index_do(sub { command_oneline('write-tree') });
  
      foreach my $path (keys %{$editor->{dir_prop}) {
          my $props = $editor->{dir_prop}{$path};
          foreach my $prop (keys %$props) {
              print "property $prop at $path changed to $props->{$prop}\n";
          }
      }
      foreach my $path (keys %{$editor->{empty}) {
          my $action = $editor->{empty}{$path} ? 'added' : 'removed';
          print "empty directory $path $action\n";
      }
      foreach my $path (keys %{$editor->{file_prop}) { ... }
      foreach my $parent (keys %{$editor->{absent_dir}}) {
          my @children = @{$editor->{abstent_dir}{$parent}};
          print "cannot fetch directory $parent/$_: not authorized?\n"
              foreach @children;
      }
      foreach my $parent (keys %{$editor->{absent_file}) { ... }
  
  =head1 DESCRIPTION
  
  This is a subclass of C<SVN::Delta::Editor>, which means it implements
  callbacks to act as a consumer of Subversion tree deltas.  This
  particular implementation of those callbacks is meant to store
  information about the resulting content which B<git svn fetch> could
  use to populate new commits and new entries for F<unhandled.log>.
  More specifically:
  
  =over
  
  =item * Additions, removals, and modifications of files are propagated
  to git-svn's index file F<$GIT_DIR/svn/$refname/index> using
  B<git update-index>.
  
  =item * Changes in Subversion path properties are recorded in the
  C<dir_prop> and C<file_prop> fields (which are hashes).
  
  =item * Addition and removal of empty directories are indicated by
  entries with value 1 and 0 respectively in the C<empty> hash.
  
  =item * Paths that are present but cannot be conveyed (presumably due
  to permissions) are recorded in the C<absent_file> and
  C<absent_dirs> hashes.  For each key, the corresponding value is
  a list of paths under that directory that were present but
  could not be conveyed.
  
  =back
  
  The interface is unstable.  Do not use this module unless you are
  developing git-svn.
  
  =head1 DEPENDENCIES
  
  L<SVN::Delta> from the Subversion perl bindings,
  the core L<Carp> and L<File::Basename> modules,
  and git's L<Git> helper module.
  
  C<Git::SVN::Fetcher> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Delta>,
  L<Git::SVN::Editor>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_FETCHER

$fatpacked{"Git/SVN/GlobSpec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_GLOBSPEC';
  package Git::SVN::GlobSpec;
  use strict;
  use warnings;
  
  sub new {
  	my ($class, $glob, $pattern_ok) = @_;
  	my $re = $glob;
  	$re =~ s!/+$!!g; # no need for trailing slashes
  	my (@left, @right, @patterns);
  	my $state = "left";
  	my $die_msg = "Only one set of wildcards " .
  				"(e.g. '*' or '*/*/*') is supported: $glob\n";
  	for my $part (split(m|/|, $glob)) {
  		if ($pattern_ok && $part =~ /[{}]/ &&
  			 $part !~ /^\{[^{}]+\}/) {
  			die "Invalid pattern in '$glob': $part\n";
  		}
  		my $nstars = $part =~ tr/*//;
  		if ($nstars > 1) {
  			die "Only one '*' is allowed in a pattern: '$part'\n";
  		}
  		if ($part =~ /(.*)\*(.*)/) {
  			die $die_msg if $state eq "right";
  			my ($l, $r) = ($1, $2);
  			$state = "pattern";
  			my $pat = quotemeta($l) . '[^/]*' . quotemeta($r);
  			push(@patterns, $pat);
  		} elsif ($pattern_ok && $part =~ /^\{(.*)\}$/) {
  			die $die_msg if $state eq "right";
  			$state = "pattern";
  			my $p = quotemeta($1);
  			$p =~ s/\\,/|/g;
  			push(@patterns, "(?:$p)");
  		} else {
  			if ($state eq "left") {
  				push(@left, $part);
  			} else {
  				push(@right, $part);
  				$state = "right";
  			}
  		}
  	}
  	my $depth = @patterns;
  	if ($depth == 0) {
  		die "One '*' is needed in glob: '$glob'\n";
  	}
  	my $left = join('/', @left);
  	my $right = join('/', @right);
  	$re = join('/', @patterns);
  	$re = join('\/',
  		   grep(length, quotemeta($left),
                                  "($re)(?=/|\$)",
                                  quotemeta($right)));
  	my $left_re = qr/^\/\Q$left\E(\/|$)/;
  	bless { left => $left, right => $right, left_regex => $left_re,
  	        regex => qr/$re/, glob => $glob, depth => $depth }, $class;
  }
  
  sub full_path {
  	my ($self, $path) = @_;
  	return (length $self->{left} ? "$self->{left}/" : '') .
  	       $path . (length $self->{right} ? "/$self->{right}" : '');
  }
  
  1;
GIT_SVN_GLOBSPEC

$fatpacked{"Git/SVN/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_LOG';
  package Git::SVN::Log;
  use strict;
  use warnings;
  use Git::SVN::Utils qw(fatal);
  use Git qw(command
             command_oneline
             command_output_pipe
             command_close_pipe
             get_tz_offset);
  use POSIX qw/strftime/;
  use constant commit_log_separator => ('-' x 72) . "\n";
  use vars qw/$TZ $limit $color $pager $non_recursive $verbose $oneline
              %rusers $show_commit $incremental/;
  
  # Option set in git-svn
  our $_git_format;
  
  sub cmt_showable {
  	my ($c) = @_;
  	return 1 if defined $c->{r};
  
  	# big commit message got truncated by the 16k pretty buffer in rev-list
  	if ($c->{l} && $c->{l}->[-1] eq "...\n" &&
  				$c->{a_raw} =~ /\@([a-f\d\-]+)>$/) {
  		@{$c->{l}} = ();
  		my @log = command(qw/cat-file commit/, $c->{c});
  
  		# shift off the headers
  		shift @log while ($log[0] ne '');
  		shift @log;
  
  		# TODO: make $c->{l} not have a trailing newline in the future
  		@{$c->{l}} = map { "$_\n" } grep !/^git-svn-id: /, @log;
  
  		(undef, $c->{r}, undef) = ::extract_metadata(
  				(grep(/^git-svn-id: /, @log))[-1]);
  	}
  	return defined $c->{r};
  }
  
  sub log_use_color {
  	return $color || Git->repository->get_colorbool('color.diff');
  }
  
  sub git_svn_log_cmd {
  	my ($r_min, $r_max, @args) = @_;
  	my $head = 'HEAD';
  	my (@files, @log_opts);
  	foreach my $x (@args) {
  		if ($x eq '--' || @files) {
  			push @files, $x;
  		} else {
  			if (::verify_ref("$x^0")) {
  				$head = $x;
  			} else {
  				push @log_opts, $x;
  			}
  		}
  	}
  
  	my ($url, $rev, $uuid, $gs) = ::working_head_info($head);
  
  	require Git::SVN;
  	$gs ||= Git::SVN->_new;
  	my @cmd = (qw/log --abbrev-commit --pretty=raw --default/,
  	           $gs->refname);
  	push @cmd, '-r' unless $non_recursive;
  	push @cmd, qw/--raw --name-status/ if $verbose;
  	push @cmd, '--color' if log_use_color();
  	push @cmd, @log_opts;
  	if (defined $r_max && $r_max == $r_min) {
  		push @cmd, '--max-count=1';
  		if (my $c = $gs->rev_map_get($r_max)) {
  			push @cmd, $c;
  		}
  	} elsif (defined $r_max) {
  		if ($r_max < $r_min) {
  			($r_min, $r_max) = ($r_max, $r_min);
  		}
  		my (undef, $c_max) = $gs->find_rev_before($r_max, 1, $r_min);
  		my (undef, $c_min) = $gs->find_rev_after($r_min, 1, $r_max);
  		# If there are no commits in the range, both $c_max and $c_min
  		# will be undefined.  If there is at least 1 commit in the
  		# range, both will be defined.
  		return () if !defined $c_min || !defined $c_max;
  		if ($c_min eq $c_max) {
  			push @cmd, '--max-count=1', $c_min;
  		} else {
  			push @cmd, '--boundary', "$c_min..$c_max";
  		}
  	}
  	return (@cmd, @files);
  }
  
  # adapted from pager.c
  sub config_pager {
  	if (! -t *STDOUT) {
  		$ENV{GIT_PAGER_IN_USE} = 'false';
  		$pager = undef;
  		return;
  	}
  	chomp($pager = command_oneline(qw(var GIT_PAGER)));
  	if ($pager eq 'cat') {
  		$pager = undef;
  	}
  	$ENV{GIT_PAGER_IN_USE} = defined($pager);
  }
  
  sub run_pager {
  	return unless defined $pager;
  	pipe my ($rfd, $wfd) or return;
  	defined(my $pid = fork) or fatal "Can't fork: $!";
  	if (!$pid) {
  		open STDOUT, '>&', $wfd or
  		                     fatal "Can't redirect to stdout: $!";
  		return;
  	}
  	open STDIN, '<&', $rfd or fatal "Can't redirect stdin: $!";
  	$ENV{LESS} ||= 'FRX';
  	$ENV{LV} ||= '-c';
  	exec $pager or fatal "Can't run pager: $! ($pager)";
  }
  
  sub format_svn_date {
  	my $t = shift || time;
  	require Git::SVN;
  	my $gmoff = get_tz_offset($t);
  	return strftime("%Y-%m-%d %H:%M:%S $gmoff (%a, %d %b %Y)", localtime($t));
  }
  
  sub parse_git_date {
  	my ($t, $tz) = @_;
  	# Date::Parse isn't in the standard Perl distro :(
  	if ($tz =~ s/^\+//) {
  		$t += tz_to_s_offset($tz);
  	} elsif ($tz =~ s/^\-//) {
  		$t -= tz_to_s_offset($tz);
  	}
  	return $t;
  }
  
  sub set_local_timezone {
  	if (defined $TZ) {
  		$ENV{TZ} = $TZ;
  	} else {
  		delete $ENV{TZ};
  	}
  }
  
  sub tz_to_s_offset {
  	my ($tz) = @_;
  	$tz =~ s/(\d\d)$//;
  	return ($1 * 60) + ($tz * 3600);
  }
  
  sub get_author_info {
  	my ($dest, $author, $t, $tz) = @_;
  	$author =~ s/(?:^\s*|\s*$)//g;
  	$dest->{a_raw} = $author;
  	my $au;
  	if ($::_authors) {
  		$au = $rusers{$author} || undef;
  	}
  	if (!$au) {
  		($au) = ($author =~ /<([^>]+)\@[^>]+>$/);
  	}
  	$dest->{t} = $t;
  	$dest->{tz} = $tz;
  	$dest->{a} = $au;
  	$dest->{t_utc} = parse_git_date($t, $tz);
  }
  
  sub process_commit {
  	my ($c, $r_min, $r_max, $defer) = @_;
  	if (defined $r_min && defined $r_max) {
  		if ($r_min == $c->{r} && $r_min == $r_max) {
  			show_commit($c);
  			return 0;
  		}
  		return 1 if $r_min == $r_max;
  		if ($r_min < $r_max) {
  			# we need to reverse the print order
  			return 0 if (defined $limit && --$limit < 0);
  			push @$defer, $c;
  			return 1;
  		}
  		if ($r_min != $r_max) {
  			return 1 if ($r_min < $c->{r});
  			return 1 if ($r_max > $c->{r});
  		}
  	}
  	return 0 if (defined $limit && --$limit < 0);
  	show_commit($c);
  	return 1;
  }
  
  my $l_fmt;
  sub show_commit {
  	my $c = shift;
  	if ($oneline) {
  		my $x = "\n";
  		if (my $l = $c->{l}) {
  			while ($l->[0] =~ /^\s*$/) { shift @$l }
  			$x = $l->[0];
  		}
  		$l_fmt ||= 'A' . length($c->{r});
  		print 'r',pack($l_fmt, $c->{r}),' | ';
  		print "$c->{c} | " if $show_commit;
  		print $x;
  	} else {
  		show_commit_normal($c);
  	}
  }
  
  sub show_commit_changed_paths {
  	my ($c) = @_;
  	return unless $c->{changed};
  	print "Changed paths:\n", @{$c->{changed}};
  }
  
  sub show_commit_normal {
  	my ($c) = @_;
  	print commit_log_separator, "r$c->{r} | ";
  	print "$c->{c} | " if $show_commit;
  	print "$c->{a} | ", format_svn_date($c->{t_utc}), ' | ';
  	my $nr_line = 0;
  
  	if (my $l = $c->{l}) {
  		while ($l->[$#$l] eq "\n" && $#$l > 0
  		                          && $l->[($#$l - 1)] eq "\n") {
  			pop @$l;
  		}
  		$nr_line = scalar @$l;
  		if (!$nr_line) {
  			print "1 line\n\n\n";
  		} else {
  			if ($nr_line == 1) {
  				$nr_line = '1 line';
  			} else {
  				$nr_line .= ' lines';
  			}
  			print $nr_line, "\n";
  			show_commit_changed_paths($c);
  			print "\n";
  			print $_ foreach @$l;
  		}
  	} else {
  		print "1 line\n";
  		show_commit_changed_paths($c);
  		print "\n";
  
  	}
  	foreach my $x (qw/raw stat diff/) {
  		if ($c->{$x}) {
  			print "\n";
  			print $_ foreach @{$c->{$x}}
  		}
  	}
  }
  
  sub cmd_show_log {
  	my (@args) = @_;
  	my ($r_min, $r_max);
  	my $r_last = -1; # prevent dupes
  	set_local_timezone();
  	if (defined $::_revision) {
  		if ($::_revision =~ /^(\d+):(\d+)$/) {
  			($r_min, $r_max) = ($1, $2);
  		} elsif ($::_revision =~ /^\d+$/) {
  			$r_min = $r_max = $::_revision;
  		} else {
  			fatal "-r$::_revision is not supported, use ",
  				"standard 'git log' arguments instead";
  		}
  	}
  
  	config_pager();
  	@args = git_svn_log_cmd($r_min, $r_max, @args);
  	if (!@args) {
  		print commit_log_separator unless $incremental || $oneline;
  		return;
  	}
  	my $log = command_output_pipe(@args);
  	run_pager();
  	my (@k, $c, $d, $stat);
  	my $esc_color = qr/(?:\033\[(?:(?:\d+;)*\d*)?m)*/;
  	while (<$log>) {
  		if (/^${esc_color}commit (?:- )?($::sha1_short)/o) {
  			my $cmt = $1;
  			if ($c && cmt_showable($c) && $c->{r} != $r_last) {
  				$r_last = $c->{r};
  				process_commit($c, $r_min, $r_max, \@k) or
  								goto out;
  			}
  			$d = undef;
  			$c = { c => $cmt };
  		} elsif (/^${esc_color}author (.+) (\d+) ([\-\+]?\d+)$/o) {
  			get_author_info($c, $1, $2, $3);
  		} elsif (/^${esc_color}(?:tree|parent|committer) /o) {
  			# ignore
  		} elsif (/^${esc_color}:\d{6} \d{6} $::sha1_short/o) {
  			push @{$c->{raw}}, $_;
  		} elsif (/^${esc_color}[ACRMDT]\t/) {
  			# we could add $SVN->{svn_path} here, but that requires
  			# remote access at the moment (repo_path_split)...
  			s#^(${esc_color})([ACRMDT])\t#$1   $2 #o;
  			push @{$c->{changed}}, $_;
  		} elsif (/^${esc_color}diff /o) {
  			$d = 1;
  			push @{$c->{diff}}, $_;
  		} elsif ($d) {
  			push @{$c->{diff}}, $_;
  		} elsif (/^\ .+\ \|\s*\d+\ $esc_color[\+\-]*
  		          $esc_color*[\+\-]*$esc_color$/x) {
  			$stat = 1;
  			push @{$c->{stat}}, $_;
  		} elsif ($stat && /^ \d+ files changed, \d+ insertions/) {
  			push @{$c->{stat}}, $_;
  			$stat = undef;
  		} elsif (/^${esc_color}    (git-svn-id:.+)$/o) {
  			($c->{url}, $c->{r}, undef) = ::extract_metadata($1);
  		} elsif (s/^${esc_color}    //o) {
  			push @{$c->{l}}, $_;
  		}
  	}
  	if ($c && defined $c->{r} && $c->{r} != $r_last) {
  		$r_last = $c->{r};
  		process_commit($c, $r_min, $r_max, \@k);
  	}
  	if (@k) {
  		($r_min, $r_max) = ($r_max, $r_min);
  		process_commit($_, $r_min, $r_max) foreach reverse @k;
  	}
  out:
  	close $log;
  	print commit_log_separator unless $incremental || $oneline;
  }
  
  sub cmd_blame {
  	my $path = pop;
  
  	config_pager();
  	run_pager();
  
  	my ($fh, $ctx, $rev);
  
  	if ($_git_format) {
  		($fh, $ctx) = command_output_pipe('blame', @_, $path);
  		while (my $line = <$fh>) {
  			if ($line =~ /^\^?([[:xdigit:]]+)\s/) {
  				# Uncommitted edits show up as a rev ID of
  				# all zeros, which we can't look up with
  				# cmt_metadata
  				if ($1 !~ /^0+$/) {
  					(undef, $rev, undef) =
  						::cmt_metadata($1);
  					$rev = '0' if (!$rev);
  				} else {
  					$rev = '0';
  				}
  				$rev = sprintf('%-10s', $rev);
  				$line =~ s/^\^?[[:xdigit:]]+(\s)/$rev$1/;
  			}
  			print $line;
  		}
  	} else {
  		($fh, $ctx) = command_output_pipe('blame', '-p', @_, 'HEAD',
  						  '--', $path);
  		my ($sha1);
  		my %authors;
  		my @buffer;
  		my %dsha; #distinct sha keys
  
  		while (my $line = <$fh>) {
  			push @buffer, $line;
  			if ($line =~ /^([[:xdigit:]]{40})\s\d+\s\d+/) {
  				$dsha{$1} = 1;
  			}
  		}
  
  		my $s2r = ::cmt_sha2rev_batch([keys %dsha]);
  
  		foreach my $line (@buffer) {
  			if ($line =~ /^([[:xdigit:]]{40})\s\d+\s\d+/) {
  				$rev = $s2r->{$1};
  				$rev = '0' if (!$rev)
  			}
  			elsif ($line =~ /^author (.*)/) {
  				$authors{$rev} = $1;
  				$authors{$rev} =~ s/\s/_/g;
  			}
  			elsif ($line =~ /^\t(.*)$/) {
  				printf("%6s %10s %s\n", $rev, $authors{$rev}, $1);
  			}
  		}
  	}
  	command_close_pipe($fh, $ctx);
  }
  
  1;
GIT_SVN_LOG

$fatpacked{"Git/SVN/Memoize/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_MEMOIZE_YAML';
  package Git::SVN::Memoize::YAML;
  use warnings;
  use strict;
  use YAML::Any ();
  
  # based on Memoize::Storable.
  
  sub TIEHASH {
  	my $package = shift;
  	my $filename = shift;
  	my $truehash = (-e $filename) ? YAML::Any::LoadFile($filename) : {};
  	my $self = {FILENAME => $filename, H => $truehash};
  	bless $self => $package;
  }
  
  sub STORE {
  	my $self = shift;
  	$self->{H}{$_[0]} = $_[1];
  }
  
  sub FETCH {
  	my $self = shift;
  	$self->{H}{$_[0]};
  }
  
  sub EXISTS {
  	my $self = shift;
  	exists $self->{H}{$_[0]};
  }
  
  sub DESTROY {
  	my $self = shift;
  	YAML::Any::DumpFile($self->{FILENAME}, $self->{H});
  }
  
  sub SCALAR {
  	my $self = shift;
  	scalar(%{$self->{H}});
  }
  
  sub FIRSTKEY {
  	'Fake hash from Git::SVN::Memoize::YAML';
  }
  
  sub NEXTKEY {
  	undef;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Memoize::YAML - store Memoized data in YAML format
  
  =head1 SYNOPSIS
  
      use Memoize;
      use Git::SVN::Memoize::YAML;
  
      tie my %cache => 'Git::SVN::Memoize::YAML', $filename;
      memoize('slow_function', SCALAR_CACHE => [HASH => \%cache]);
      slow_function(arguments);
  
  =head1 DESCRIPTION
  
  This module provides a class that can be used to tie a hash to a
  YAML file.  The file is read when the hash is initialized and
  rewritten when the hash is destroyed.
  
  The intent is to allow L<Memoize> to back its cache with a file in
  YAML format, just like L<Memoize::Storable> allows L<Memoize> to
  back its cache with a file in Storable format.  Unlike the Storable
  format, the YAML format is platform-independent and fairly stable.
  
  Carps on error.
  
  =head1 DIAGNOSTICS
  
  See L<YAML::Any>.
  
  =head1 DEPENDENCIES
  
  L<YAML::Any> from CPAN.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  The entire cache is read into a Perl hash when loading the file,
  so this is not very scalable.
GIT_SVN_MEMOIZE_YAML

$fatpacked{"Git/SVN/Migration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_MIGRATION';
  package Git::SVN::Migration;
  # these version numbers do NOT correspond to actual version numbers
  # of git or git-svn.  They are just relative.
  #
  # v0 layout: .git/$id/info/url, refs/heads/$id-HEAD
  #
  # v1 layout: .git/$id/info/url, refs/remotes/$id
  #
  # v2 layout: .git/svn/$id/info/url, refs/remotes/$id
  #
  # v3 layout: .git/svn/$id, refs/remotes/$id
  #            - info/url may remain for backwards compatibility
  #            - this is what we migrate up to this layout automatically,
  #            - this will be used by git svn init on single branches
  # v3.1 layout (auto migrated):
  #            - .rev_db => .rev_db.$UUID, .rev_db will remain as a symlink
  #              for backwards compatibility
  #
  # v4 layout: .git/svn/$repo_id/$id, refs/remotes/$repo_id/$id
  #            - this is only created for newly multi-init-ed
  #              repositories.  Similar in spirit to the
  #              --use-separate-remotes option in git-clone (now default)
  #            - we do not automatically migrate to this (following
  #              the example set by core git)
  #
  # v5 layout: .rev_db.$UUID => .rev_map.$UUID
  #            - newer, more-efficient format that uses 24-bytes per record
  #              with no filler space.
  #            - use xxd -c24 < .rev_map.$UUID to view and debug
  #            - This is a one-way migration, repositories updated to the
  #              new format will not be able to use old git-svn without
  #              rebuilding the .rev_db.  Rebuilding the rev_db is not
  #              possible if noMetadata or useSvmProps are set; but should
  #              be no problem for users that use the (sensible) defaults.
  use strict;
  use warnings;
  use Carp qw/croak/;
  use File::Path qw/mkpath/;
  use File::Basename qw/dirname basename/;
  
  our $_minimize;
  use Git qw(
  	command
  	command_noisy
  	command_output_pipe
  	command_close_pipe
  	command_oneline
  );
  use Git::SVN;
  
  sub migrate_from_v0 {
  	my $git_dir = $ENV{GIT_DIR};
  	return undef unless -d $git_dir;
  	my ($fh, $ctx) = command_output_pipe(qw/rev-parse --symbolic --all/);
  	my $migrated = 0;
  	while (<$fh>) {
  		chomp;
  		my ($id, $orig_ref) = ($_, $_);
  		next unless $id =~ s#^refs/heads/(.+)-HEAD$#$1#;
  		my $info_url = command_oneline(qw(rev-parse --git-path),
  						"$id/info/url");
  		next unless -f $info_url;
  		my $new_ref = "refs/remotes/$id";
  		if (::verify_ref("$new_ref^0")) {
  			print STDERR "W: $orig_ref is probably an old ",
  			             "branch used by an ancient version of ",
  				     "git-svn.\n",
  				     "However, $new_ref also exists.\n",
  				     "We will not be able ",
  				     "to use this branch until this ",
  				     "ambiguity is resolved.\n";
  			next;
  		}
  		print STDERR "Migrating from v0 layout...\n" if !$migrated;
  		print STDERR "Renaming ref: $orig_ref => $new_ref\n";
  		command_noisy('update-ref', $new_ref, $orig_ref);
  		command_noisy('update-ref', '-d', $orig_ref, $orig_ref);
  		$migrated++;
  	}
  	command_close_pipe($fh, $ctx);
  	print STDERR "Done migrating from v0 layout...\n" if $migrated;
  	$migrated;
  }
  
  sub migrate_from_v1 {
  	my $git_dir = $ENV{GIT_DIR};
  	my $migrated = 0;
  	return $migrated unless -d $git_dir;
  	my $svn_dir = Git::SVN::svn_dir();
  
  	# just in case somebody used 'svn' as their $id at some point...
  	return $migrated if -d $svn_dir && ! -f "$svn_dir/info/url";
  
  	print STDERR "Migrating from a git-svn v1 layout...\n";
  	mkpath([$svn_dir]);
  	print STDERR "Data from a previous version of git-svn exists, but\n\t",
  	             "$svn_dir\n\t(required for this version ",
  	             "($::VERSION) of git-svn) does not exist.\n";
  	my ($fh, $ctx) = command_output_pipe(qw/rev-parse --symbolic --all/);
  	while (<$fh>) {
  		my $x = $_;
  		next unless $x =~ s#^refs/remotes/##;
  		chomp $x;
  		my $info_url = command_oneline(qw(rev-parse --git-path),
  						"$x/info/url");
  		next unless -f $info_url;
  		my $u = eval { ::file_to_s($info_url) };
  		next unless $u;
  		my $dn = dirname("$svn_dir/$x");
  		mkpath([$dn]) unless -d $dn;
  		if ($x eq 'svn') { # they used 'svn' as GIT_SVN_ID:
  			mkpath(["$svn_dir/svn"]);
  			print STDERR " - $git_dir/$x/info => ",
  			                "$svn_dir/$x/info\n";
  			rename "$git_dir/$x/info", "$svn_dir/$x/info" or
  			       croak "$!: $x";
  			# don't worry too much about these, they probably
  			# don't exist with repos this old (save for index,
  			# and we can easily regenerate that)
  			foreach my $f (qw/unhandled.log index .rev_db/) {
  				rename "$git_dir/$x/$f", "$svn_dir/$x/$f";
  			}
  		} else {
  			print STDERR " - $git_dir/$x => $svn_dir/$x\n";
  			rename "$git_dir/$x", "$svn_dir/$x" or croak "$!: $x";
  		}
  		$migrated++;
  	}
  	command_close_pipe($fh, $ctx);
  	print STDERR "Done migrating from a git-svn v1 layout\n";
  	$migrated;
  }
  
  sub read_old_urls {
  	my ($l_map, $pfx, $path) = @_;
  	my @dir;
  	foreach (<$path/*>) {
  		if (-r "$_/info/url") {
  			$pfx .= '/' if $pfx && $pfx !~ m!/$!;
  			my $ref_id = $pfx . basename $_;
  			my $url = ::file_to_s("$_/info/url");
  			$l_map->{$ref_id} = $url;
  		} elsif (-d $_) {
  			push @dir, $_;
  		}
  	}
  	my $svn_dir = Git::SVN::svn_dir();
  	foreach (@dir) {
  		my $x = $_;
  		$x =~ s!^\Q$svn_dir\E/!!o;
  		read_old_urls($l_map, $x, $_);
  	}
  }
  
  sub migrate_from_v2 {
  	my @cfg = command(qw/config -l/);
  	return if grep /^svn-remote\..+\.url=/, @cfg;
  	my %l_map;
  	read_old_urls(\%l_map, '', Git::SVN::svn_dir());
  	my $migrated = 0;
  
  	require Git::SVN;
  	foreach my $ref_id (sort keys %l_map) {
  		eval { Git::SVN->init($l_map{$ref_id}, '', undef, $ref_id) };
  		if ($@) {
  			Git::SVN->init($l_map{$ref_id}, '', $ref_id, $ref_id);
  		}
  		$migrated++;
  	}
  	$migrated;
  }
  
  sub minimize_connections {
  	require Git::SVN;
  	require Git::SVN::Ra;
  
  	my $r = Git::SVN::read_all_remotes();
  	my $new_urls = {};
  	my $root_repos = {};
  	foreach my $repo_id (keys %$r) {
  		my $url = $r->{$repo_id}->{url} or next;
  		my $fetch = $r->{$repo_id}->{fetch} or next;
  		my $ra = Git::SVN::Ra->new($url);
  
  		# skip existing cases where we already connect to the root
  		if (($ra->url eq $ra->{repos_root}) ||
  		    ($ra->{repos_root} eq $repo_id)) {
  			$root_repos->{$ra->url} = $repo_id;
  			next;
  		}
  
  		my $root_ra = Git::SVN::Ra->new($ra->{repos_root});
  		my $root_path = $ra->url;
  		$root_path =~ s#^\Q$ra->{repos_root}\E(/|$)##;
  		foreach my $path (keys %$fetch) {
  			my $ref_id = $fetch->{$path};
  			my $gs = Git::SVN->new($ref_id, $repo_id, $path);
  
  			# make sure we can read when connecting to
  			# a higher level of a repository
  			my ($last_rev, undef) = $gs->last_rev_commit;
  			if (!defined $last_rev) {
  				$last_rev = eval {
  					$root_ra->get_latest_revnum;
  				};
  				next if $@;
  			}
  			my $new = $root_path;
  			$new .= length $path ? "/$path" : '';
  			eval {
  				$root_ra->get_log([$new], $last_rev, $last_rev,
  			                          0, 0, 1, sub { });
  			};
  			next if $@;
  			$new_urls->{$ra->{repos_root}}->{$new} =
  			        { ref_id => $ref_id,
  				  old_repo_id => $repo_id,
  				  old_path => $path };
  		}
  	}
  
  	my @emptied;
  	foreach my $url (keys %$new_urls) {
  		# see if we can re-use an existing [svn-remote "repo_id"]
  		# instead of creating a(n ugly) new section:
  		my $repo_id = $root_repos->{$url} || $url;
  
  		my $fetch = $new_urls->{$url};
  		foreach my $path (keys %$fetch) {
  			my $x = $fetch->{$path};
  			Git::SVN->init($url, $path, $repo_id, $x->{ref_id});
  			my $pfx = "svn-remote.$x->{old_repo_id}";
  
  			my $old_fetch = quotemeta("$x->{old_path}:".
  			                          "$x->{ref_id}");
  			command_noisy(qw/config --unset/,
  			              "$pfx.fetch", '^'. $old_fetch . '$');
  			delete $r->{$x->{old_repo_id}}->
  			       {fetch}->{$x->{old_path}};
  			if (!keys %{$r->{$x->{old_repo_id}}->{fetch}}) {
  				command_noisy(qw/config --unset/,
  				              "$pfx.url");
  				push @emptied, $x->{old_repo_id}
  			}
  		}
  	}
  	if (@emptied) {
  		my $file = $ENV{GIT_CONFIG} ||
  			command_oneline(qw(rev-parse --git-path config));
  		print STDERR <<EOF;
  The following [svn-remote] sections in your config file ($file) are empty
  and can be safely removed:
  EOF
  		print STDERR "[svn-remote \"$_\"]\n" foreach @emptied;
  	}
  }
  
  sub migration_check {
  	migrate_from_v0();
  	migrate_from_v1();
  	migrate_from_v2();
  	minimize_connections() if $_minimize;
  }
  
  1;
GIT_SVN_MIGRATION

$fatpacked{"Git/SVN/Prompt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_PROMPT';
  package Git::SVN::Prompt;
  use strict;
  use warnings;
  require SVN::Core;
  use vars qw/$_no_auth_cache $_username/;
  
  sub simple {
  	my ($cred, $realm, $default_username, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	$default_username = $_username if defined $_username;
  	if (defined $default_username && length $default_username) {
  		if (defined $realm && length $realm) {
  			print STDERR "Authentication realm: $realm\n";
  			STDERR->flush;
  		}
  		$cred->username($default_username);
  	} else {
  		username($cred, $realm, $may_save, $pool);
  	}
  	$cred->password(_read_password("Password for '" .
  	                               $cred->username . "': ", $realm));
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_server_trust {
  	my ($cred, $realm, $failures, $cert_info, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	print STDERR "Error validating server certificate for '$realm':\n";
  	{
  		no warnings 'once';
  		# All variables SVN::Auth::SSL::* are used only once,
  		# so we're shutting up Perl warnings about this.
  		if ($failures & $SVN::Auth::SSL::UNKNOWNCA) {
  			print STDERR " - The certificate is not issued ",
  			    "by a trusted authority. Use the\n",
  			    "   fingerprint to validate ",
  			    "the certificate manually!\n";
  		}
  		if ($failures & $SVN::Auth::SSL::CNMISMATCH) {
  			print STDERR " - The certificate hostname ",
  			    "does not match.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::NOTYETVALID) {
  			print STDERR " - The certificate is not yet valid.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::EXPIRED) {
  			print STDERR " - The certificate has expired.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::OTHER) {
  			print STDERR " - The certificate has ",
  			    "an unknown error.\n";
  		}
  	} # no warnings 'once'
  	printf STDERR
  	        "Certificate information:\n".
  	        " - Hostname: %s\n".
  	        " - Valid: from %s until %s\n".
  	        " - Issuer: %s\n".
  	        " - Fingerprint: %s\n",
  	        map $cert_info->$_, qw(hostname valid_from valid_until
  	                               issuer_dname fingerprint);
  	my $choice;
  prompt:
  	my $options = $may_save ?
  	      "(R)eject, accept (t)emporarily or accept (p)ermanently? " :
  	      "(R)eject or accept (t)emporarily? ";
  	STDERR->flush;
  	$choice = lc(substr(Git::prompt("Certificate problem.\n" . $options) || 'R', 0, 1));
  	if ($choice eq 't') {
  		$cred->may_save(undef);
  	} elsif ($choice eq 'r') {
  		return -1;
  	} elsif ($may_save && $choice eq 'p') {
  		$cred->may_save($may_save);
  	} else {
  		goto prompt;
  	}
  	$cred->accepted_failures($failures);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_client_cert {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	print STDERR "Client certificate filename: ";
  	STDERR->flush;
  	chomp(my $filename = <STDIN>);
  	$cred->cert_file($filename);
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_client_cert_pw {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	$cred->password(_read_password("Password: ", $realm));
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub username {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	if (defined $realm && length $realm) {
  		print STDERR "Authentication realm: $realm\n";
  	}
  	my $username;
  	if (defined $_username) {
  		$username = $_username;
  	} else {
  		$username = Git::prompt("Username: ");
  	}
  	$cred->username($username);
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub _read_password {
  	my ($prompt, $realm) = @_;
  	my $password = Git::prompt($prompt, 1);
  	$password;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Prompt - authentication callbacks for git-svn
  
  =head1 SYNOPSIS
  
      use Git::SVN::Prompt qw(simple ssl_client_cert ssl_client_cert_pw
                              ssl_server_trust username);
      use SVN::Client ();
  
      my $cached_simple = SVN::Client::get_simple_provider();
      my $git_simple = SVN::Client::get_simple_prompt_provider(\&simple, 2);
      my $cached_ssl = SVN::Client::get_ssl_server_trust_file_provider();
      my $git_ssl = SVN::Client::get_ssl_server_trust_prompt_provider(
          \&ssl_server_trust);
      my $cached_cert = SVN::Client::get_ssl_client_cert_file_provider();
      my $git_cert = SVN::Client::get_ssl_client_cert_prompt_provider(
          \&ssl_client_cert, 2);
      my $cached_cert_pw = SVN::Client::get_ssl_client_cert_pw_file_provider();
      my $git_cert_pw = SVN::Client::get_ssl_client_cert_pw_prompt_provider(
          \&ssl_client_cert_pw, 2);
      my $cached_username = SVN::Client::get_username_provider();
      my $git_username = SVN::Client::get_username_prompt_provider(
          \&username, 2);
  
      my $ctx = new SVN::Client(
          auth => [
              $cached_simple, $git_simple,
              $cached_ssl, $git_ssl,
              $cached_cert, $git_cert,
              $cached_cert_pw, $git_cert_pw,
              $cached_username, $git_username
          ]);
  
  =head1 DESCRIPTION
  
  This module is an implementation detail of the "git svn" command.
  It implements git-svn's authentication policy.  Do not use it unless
  you are developing git-svn.
  
  The interface will change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  L<SVN::Core>.
  
  =head1 SEE ALSO
  
  L<SVN::Client>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_PROMPT

$fatpacked{"Git/SVN/Ra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_RA';
  package Git::SVN::Ra;
  use vars qw/@ISA $config_dir $_ignore_refs_regex $_log_window_size/;
  use strict;
  use warnings;
  use Memoize;
  use Git::SVN::Utils qw(
  	canonicalize_url
  	canonicalize_path
  	add_path_to_url
  );
  
  use SVN::Ra;
  BEGIN {
  	@ISA = qw(SVN::Ra);
  }
  
  my ($ra_invalid, $can_do_switch, %ignored_err, $RA);
  
  BEGIN {
  	# enforce temporary pool usage for some simple functions
  	no strict 'refs';
  	for my $f (qw/rev_proplist get_latest_revnum get_uuid get_repos_root
  	              get_file/) {
  		my $SUPER = "SUPER::$f";
  		*$f = sub {
  			my $self = shift;
  			my $pool = SVN::Pool->new;
  			my @ret = $self->$SUPER(@_,$pool);
  			$pool->clear;
  			wantarray ? @ret : $ret[0];
  		};
  	}
  }
  
  # serf has a bug that leads to a coredump upon termination if the
  # remote access object is left around (not fixed yet in serf 1.3.1).
  # Explicitly free it to work around the issue.
  END {
  	$RA = undef;
  	$ra_invalid = 1;
  }
  
  sub _auth_providers () {
  	require SVN::Client;
  	my @rv = (
  	  SVN::Client::get_simple_provider(),
  	  SVN::Client::get_ssl_server_trust_file_provider(),
  	  SVN::Client::get_simple_prompt_provider(
  	    \&Git::SVN::Prompt::simple, 2),
  	  SVN::Client::get_ssl_client_cert_file_provider(),
  	  SVN::Client::get_ssl_client_cert_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_client_cert, 2),
  	  SVN::Client::get_ssl_client_cert_pw_file_provider(),
  	  SVN::Client::get_ssl_client_cert_pw_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_client_cert_pw, 2),
  	  SVN::Client::get_username_provider(),
  	  SVN::Client::get_ssl_server_trust_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_server_trust),
  	  SVN::Client::get_username_prompt_provider(
  	    \&Git::SVN::Prompt::username, 2)
  	);
  
  	# earlier 1.6.x versions would segfault, and <= 1.5.x didn't have
  	# this function
  	if (::compare_svn_version('1.6.15') >= 0) {
  		my $config = SVN::Core::config_get_config($config_dir);
  		my ($p, @a);
  		# config_get_config returns all config files from
  		# ~/.subversion, auth_get_platform_specific_client_providers
  		# just wants the config "file".
  		@a = ($config->{'config'}, undef);
  		$p = SVN::Core::auth_get_platform_specific_client_providers(@a);
  		# Insert the return value from
  		# auth_get_platform_specific_providers
  		unshift @rv, @$p;
  	}
  	\@rv;
  }
  
  sub prepare_config_once {
  	SVN::_Core::svn_config_ensure($config_dir, undef);
  	my ($baton, $callbacks) = SVN::Core::auth_open_helper(_auth_providers);
  	my $config = SVN::Core::config_get_config($config_dir);
  	my $conf_t = $config->{'config'};
  
  	no warnings 'once';
  	# The usage of $SVN::_Core::SVN_CONFIG_* variables
  	# produces warnings that variables are used only once.
  	# I had not found the better way to shut them up, so
  	# the warnings of type 'once' are disabled in this block.
  	if (SVN::_Core::svn_config_get_bool($conf_t,
  	    $SVN::_Core::SVN_CONFIG_SECTION_AUTH,
  	    $SVN::_Core::SVN_CONFIG_OPTION_STORE_PASSWORDS,
  	    1) == 0) {
  		my $val = '1';
  		if (::compare_svn_version('1.9.0') < 0) { # pre-SVN r1553823
  			my $dont_store_passwords = 1;
  			$val = bless \$dont_store_passwords, "_p_void";
  		}
  		SVN::_Core::svn_auth_set_parameter($baton,
  		    $SVN::_Core::SVN_AUTH_PARAM_DONT_STORE_PASSWORDS,
  		    $val);
  	}
  	if (SVN::_Core::svn_config_get_bool($conf_t,
  	    $SVN::_Core::SVN_CONFIG_SECTION_AUTH,
  	    $SVN::_Core::SVN_CONFIG_OPTION_STORE_AUTH_CREDS,
  	    1) == 0) {
  		$Git::SVN::Prompt::_no_auth_cache = 1;
  	}
  
  	return ($config, $baton, $callbacks);
  } # no warnings 'once'
  
  INIT {
  	Memoize::memoize '_auth_providers';
  	Memoize::memoize 'prepare_config_once';
  }
  
  sub new {
  	my ($class, $url) = @_;
  	$url = canonicalize_url($url);
  	return $RA if ($RA && $RA->url eq $url);
  
  	::_req_svn();
  
  	$RA = undef;
  	my ($config, $baton, $callbacks) = prepare_config_once();
  	my $self = SVN::Ra->new(url => $url, auth => $baton,
  	                      config => $config,
  			      pool => SVN::Pool->new,
  	                      auth_provider_callbacks => $callbacks);
  	$RA = bless $self, $class;
  
  	# Make sure its canonicalized
  	$self->url($url);
  	$self->{svn_path} = $url;
  	$self->{repos_root} = $self->get_repos_root;
  	$self->{svn_path} =~ s#^\Q$self->{repos_root}\E(/|$)##;
  	$self->{cache} = { check_path => { r => 0, data => {} },
  	                   get_dir => { r => 0, data => {} } };
  
  	return $RA;
  }
  
  sub url {
  	my $self = shift;
  
  	if (@_) {
  		my $url = shift;
  		$self->{url} = canonicalize_url($url);
  		return;
  	}
  
  	return $self->{url};
  }
  
  sub check_path {
  	my ($self, $path, $r) = @_;
  	my $cache = $self->{cache}->{check_path};
  	if ($r == $cache->{r} && exists $cache->{data}->{$path}) {
  		return $cache->{data}->{$path};
  	}
  	my $pool = SVN::Pool->new;
  	my $t = $self->SUPER::check_path($path, $r, $pool);
  	$pool->clear;
  	if ($r != $cache->{r}) {
  		%{$cache->{data}} = ();
  		$cache->{r} = $r;
  	}
  	$cache->{data}->{$path} = $t;
  }
  
  sub get_dir {
  	my ($self, $dir, $r) = @_;
  	my $cache = $self->{cache}->{get_dir};
  	if ($r == $cache->{r}) {
  		if (my $x = $cache->{data}->{$dir}) {
  			return wantarray ? @$x : $x->[0];
  		}
  	}
  	my $pool = SVN::Pool->new;
  	my ($d, undef, $props);
  
  	if (::compare_svn_version('1.4.0') >= 0) {
  		# n.b. in addition to being potentially more efficient,
  		# this works around what appears to be a bug in some
  		# SVN 1.8 versions
  		my $kind = 1; # SVN_DIRENT_KIND
  		($d, undef, $props) = $self->get_dir2($dir, $r, $kind, $pool);
  	} else {
  		($d, undef, $props) = $self->SUPER::get_dir($dir, $r, $pool);
  	}
  	my %dirents = map { $_ => { kind => $d->{$_}->kind } } keys %$d;
  	$pool->clear;
  	if ($r != $cache->{r}) {
  		%{$cache->{data}} = ();
  		$cache->{r} = $r;
  	}
  	$cache->{data}->{$dir} = [ \%dirents, $r, $props ];
  	wantarray ? (\%dirents, $r, $props) : \%dirents;
  }
  
  # get_log(paths, start, end, limit,
  #         discover_changed_paths, strict_node_history, receiver)
  sub get_log {
  	my ($self, @args) = @_;
  	my $pool = SVN::Pool->new;
  
  	# svn_log_changed_path_t objects passed to get_log are likely to be
  	# overwritten even if only the refs are copied to an external variable,
  	# so we should dup the structures in their entirety.  Using an
  	# externally passed pool (instead of our temporary and quickly cleared
  	# pool in Git::SVN::Ra) does not help matters at all...
  	my $receiver = pop @args;
  	my $prefix = "/".$self->{svn_path};
  	$prefix =~ s#/+($)##;
  	my $prefix_regex = qr#^\Q$prefix\E#;
  	push(@args, sub {
  		my ($paths) = $_[0];
  		return &$receiver(@_) unless $paths;
  		$_[0] = ();
  		foreach my $p (keys %$paths) {
  			my $i = $paths->{$p};
  			# Make path relative to our url, not repos_root
  			$p =~ s/$prefix_regex//;
  			my %s = map { $_ => $i->$_; }
  				qw/copyfrom_path copyfrom_rev action/;
  			if ($s{'copyfrom_path'}) {
  				$s{'copyfrom_path'} =~ s/$prefix_regex//;
  				$s{'copyfrom_path'} = canonicalize_path($s{'copyfrom_path'});
  			}
  			$_[0]{$p} = \%s;
  		}
  		&$receiver(@_);
  	});
  
  
  	# the limit parameter was not supported in SVN 1.1.x, so we
  	# drop it.  Therefore, the receiver callback passed to it
  	# is made aware of this limitation by being wrapped if
  	# the limit passed to is being wrapped.
  	if (::compare_svn_version('1.2.0') <= 0) {
  		my $limit = splice(@args, 3, 1);
  		if ($limit > 0) {
  			my $receiver = pop @args;
  			push(@args, sub { &$receiver(@_) if (--$limit >= 0) });
  		}
  	}
  	my $ret = $self->SUPER::get_log(@args, $pool);
  	$pool->clear;
  	$ret;
  }
  
  # uncommon, only for ancient SVN (<= 1.4.2)
  sub trees_match {
  	require IO::File;
  	require SVN::Client;
  	my ($self, $url1, $rev1, $url2, $rev2) = @_;
  	my $ctx = SVN::Client->new(auth => _auth_providers);
  	my $out = IO::File->new_tmpfile;
  
  	# older SVN (1.1.x) doesn't take $pool as the last parameter for
  	# $ctx->diff(), so we'll create a default one
  	my $pool = SVN::Pool->new_default_sub;
  
  	$ra_invalid = 1; # this will open a new SVN::Ra connection to $url1
  	$ctx->diff([], $url1, $rev1, $url2, $rev2, 1, 1, 0, $out, $out);
  	$out->flush;
  	my $ret = (($out->stat)[7] == 0);
  	close $out or croak $!;
  
  	$ret;
  }
  
  sub get_commit_editor {
  	my ($self, $log, $cb, $pool) = @_;
  
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef, 0) : ();
  	$self->SUPER::get_commit_editor($log, $cb, @lock, $pool);
  }
  
  sub gs_do_update {
  	my ($self, $rev_a, $rev_b, $gs, $editor) = @_;
  	my $new = ($rev_a == $rev_b);
  	my $path = $gs->path;
  
  	if ($new && -e $gs->{index}) {
  		unlink $gs->{index} or die
  		  "Couldn't unlink index: $gs->{index}: $!\n";
  	}
  	my $pool = SVN::Pool->new;
  	$editor->set_path_strip($path);
  	my (@pc) = split m#/#, $path;
  	my $reporter = $self->do_update($rev_b, (@pc ? shift @pc : ''),
  	                                1, $editor, $pool);
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef) : ();
  
  	# Since we can't rely on svn_ra_reparent being available, we'll
  	# just have to do some magic with set_path to make it so
  	# we only want a partial path.
  	my $sp = '';
  	my $final = join('/', @pc);
  	while (@pc) {
  		$reporter->set_path($sp, $rev_b, 0, @lock, $pool);
  		$sp .= '/' if length $sp;
  		$sp .= shift @pc;
  	}
  	die "BUG: '$sp' != '$final'\n" if ($sp ne $final);
  
  	$reporter->set_path($sp, $rev_a, $new, @lock, $pool);
  
  	$reporter->finish_report($pool);
  	$pool->clear;
  	$editor->{git_commit_ok};
  }
  
  # this requires SVN 1.4.3 or later (do_switch didn't work before 1.4.3, and
  # svn_ra_reparent didn't work before 1.4)
  sub gs_do_switch {
  	my ($self, $rev_a, $rev_b, $gs, $url_b, $editor) = @_;
  	my $path = $gs->path;
  	my $pool = SVN::Pool->new;
  
  	my $old_url = $self->url;
  	my $full_url = add_path_to_url( $self->url, $path );
  	my ($ra, $reparented);
  
  	if ($old_url =~ m#^svn(\+\w+)?://# ||
  	    ($full_url =~ m#^https?://# &&
  	     canonicalize_url($full_url) ne $full_url)) {
  		$_[0] = undef;
  		$self = undef;
  		$RA = undef;
  		$ra = Git::SVN::Ra->new($full_url);
  		$ra_invalid = 1;
  	} elsif ($old_url ne $full_url) {
  		SVN::_Ra::svn_ra_reparent(
  			$self->{session},
  			canonicalize_url($full_url),
  			$pool
  		);
  		$self->url($full_url);
  		$reparented = 1;
  	}
  
  	$ra ||= $self;
  	$url_b = canonicalize_url($url_b);
  	my $reporter = $ra->do_switch($rev_b, '', 1, $url_b, $editor, $pool);
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef) : ();
  	$reporter->set_path('', $rev_a, 0, @lock, $pool);
  	$reporter->finish_report($pool);
  
  	if ($reparented) {
  		SVN::_Ra::svn_ra_reparent($self->{session}, $old_url, $pool);
  		$self->url($old_url);
  	}
  
  	$pool->clear;
  	$editor->{git_commit_ok};
  }
  
  sub longest_common_path {
  	my ($gsv, $globs) = @_;
  	my %common;
  	my $common_max = scalar @$gsv;
  
  	foreach my $gs (@$gsv) {
  		my @tmp = split m#/#, $gs->path;
  		my $p = '';
  		foreach (@tmp) {
  			$p .= length($p) ? "/$_" : $_;
  			$common{$p} ||= 0;
  			$common{$p}++;
  		}
  	}
  	$globs ||= [];
  	$common_max += scalar @$globs;
  	foreach my $glob (@$globs) {
  		my @tmp = split m#/#, $glob->{path}->{left};
  		my $p = '';
  		foreach (@tmp) {
  			$p .= length($p) ? "/$_" : $_;
  			$common{$p} ||= 0;
  			$common{$p}++;
  		}
  	}
  
  	my $longest_path = '';
  	foreach (sort {length $b <=> length $a} keys %common) {
  		if ($common{$_} == $common_max) {
  			$longest_path = $_;
  			last;
  		}
  	}
  	$longest_path;
  }
  
  sub gs_fetch_loop_common {
  	my ($self, $base, $head, $gsv, $globs) = @_;
  	return if ($base > $head);
  	# Make sure the cat_blob open2 FileHandle is created before calling
  	# SVN::Pool::new_default so that it does not incorrectly end up in the pool.
  	$::_repository->_open_cat_blob_if_needed;
  	my $gpool = SVN::Pool->new_default;
  	my $ra_url = $self->url;
  	my $reload_ra = sub {
  		$_[0] = undef;
  		$self = undef;
  		$RA = undef;
  		$gpool->clear;
  		$self = Git::SVN::Ra->new($ra_url);
  		$ra_invalid = undef;
  	};
  	my $inc = $_log_window_size;
  	my ($min, $max) = ($base, $head < $base + $inc ? $head : $base + $inc);
  	my $longest_path = longest_common_path($gsv, $globs);
  	my $find_trailing_edge;
  	while (1) {
  		my %revs;
  		my $err;
  		my $err_handler = $SVN::Error::handler;
  		$SVN::Error::handler = sub {
  			($err) = @_;
  			skip_unknown_revs($err);
  		};
  		sub _cb {
  			my ($paths, $r, $author, $date, $log) = @_;
  			[ $paths,
  			  { author => $author, date => $date, log => $log } ];
  		}
  		$self->get_log([$longest_path], $min, $max, 0, 1, 1,
  		               sub { $revs{$_[1]} = _cb(@_) });
  		if ($err) {
  			print "Checked through r$max\r";
  		} else {
  			$find_trailing_edge = 1;
  		}
  		if ($err and $find_trailing_edge) {
  			print STDERR "Path '$longest_path' ",
  				     "was probably deleted:\n",
  				     $err->expanded_message,
  				     "\nWill attempt to follow ",
  				     "revisions r$min .. r$max ",
  				     "committed before the deletion\n";
  			my $hi = $max;
  			while (--$hi >= $min) {
  				my $ok;
  				$self->get_log([$longest_path], $min, $hi,
  				               0, 1, 1, sub {
  				               $ok = $_[1];
  				               $revs{$_[1]} = _cb(@_) });
  				if ($ok) {
  					print STDERR "r$min .. r$ok OK\n";
  					last;
  				}
  			}
  			$find_trailing_edge = 0;
  		}
  		$SVN::Error::handler = $err_handler;
  
  		my %exists = map { $_->path => $_ } @$gsv;
  		foreach my $r (sort {$a <=> $b} keys %revs) {
  			my ($paths, $logged) = @{delete $revs{$r}};
  
  			foreach my $gs ($self->match_globs(\%exists, $paths,
  			                                   $globs, $r)) {
  				if ($gs->rev_map_max >= $r) {
  					next;
  				}
  				next unless $gs->match_paths($paths, $r);
  				$gs->{logged_rev_props} = $logged;
  				if (my $last_commit = $gs->last_commit) {
  					$gs->assert_index_clean($last_commit);
  				}
  				my $log_entry = $gs->do_fetch($paths, $r);
  				if ($log_entry) {
  					$gs->do_git_commit($log_entry);
  				}
  				$Git::SVN::INDEX_FILES{$gs->{index}} = 1;
  			}
  			foreach my $g (@$globs) {
  				my $k = "svn-remote.$g->{remote}." .
  				        "$g->{t}-maxRev";
  				Git::SVN::tmp_config($k, $r);
  			}
  			$reload_ra->() if $ra_invalid;
  		}
  		# pre-fill the .rev_db since it'll eventually get filled in
  		# with '0' x40 if something new gets committed
  		foreach my $gs (@$gsv) {
  			next if $gs->rev_map_max >= $max;
  			next if defined $gs->rev_map_get($max);
  			$gs->rev_map_set($max, 0 x40);
  		}
  		foreach my $g (@$globs) {
  			my $k = "svn-remote.$g->{remote}.$g->{t}-maxRev";
  			Git::SVN::tmp_config($k, $max);
  		}
  		last if $max >= $head;
  		$min = $max + 1;
  		$max += $inc;
  		$max = $head if ($max > $head);
  
  		$reload_ra->();
  	}
  	Git::SVN::gc();
  }
  
  sub get_dir_globbed {
  	my ($self, $left, $depth, $r) = @_;
  
  	my @x = eval { $self->get_dir($left, $r) };
  	return unless scalar @x == 3;
  	my $dirents = $x[0];
  	my @finalents;
  	foreach my $de (keys %$dirents) {
  		next if $dirents->{$de}->{kind} != $SVN::Node::dir;
  		if ($depth > 1) {
  			my @args = ("$left/$de", $depth - 1, $r);
  			foreach my $dir ($self->get_dir_globbed(@args)) {
  				push @finalents, "$de/$dir";
  			}
  		} else {
  			push @finalents, $de;
  		}
  	}
  	@finalents;
  }
  
  # return value: 0 -- don't ignore, 1 -- ignore
  sub is_ref_ignored {
  	my ($g, $p) = @_;
  	my $refname = $g->{ref}->full_path($p);
  	return 1 if defined($g->{ignore_refs_regex}) &&
  	            $refname =~ m!$g->{ignore_refs_regex}!;
  	return 0 unless defined($_ignore_refs_regex);
  	return 1 if $refname =~ m!$_ignore_refs_regex!o;
  	return 0;
  }
  
  sub match_globs {
  	my ($self, $exists, $paths, $globs, $r) = @_;
  
  	sub get_dir_check {
  		my ($self, $exists, $g, $r) = @_;
  
  		my @dirs = $self->get_dir_globbed($g->{path}->{left},
  		                                  $g->{path}->{depth},
  		                                  $r);
  
  		foreach my $de (@dirs) {
  			my $p = $g->{path}->full_path($de);
  			next if $exists->{$p};
  			next if (length $g->{path}->{right} &&
  				 ($self->check_path($p, $r) !=
  				  $SVN::Node::dir));
  			next unless $p =~ /$g->{path}->{regex}/;
  			$exists->{$p} = Git::SVN->init($self->url, $p, undef,
  					 $g->{ref}->full_path($de), 1);
  		}
  	}
  	foreach my $g (@$globs) {
  		if (my $path = $paths->{"/$g->{path}->{left}"}) {
  			if ($path->{action} =~ /^[AR]$/) {
  				get_dir_check($self, $exists, $g, $r);
  			}
  		}
  		foreach (keys %$paths) {
  			if (/$g->{path}->{left_regex}/ &&
  			    !/$g->{path}->{regex}/) {
  				next if $paths->{$_}->{action} !~ /^[AR]$/;
  				get_dir_check($self, $exists, $g, $r);
  			}
  			next unless /$g->{path}->{regex}/;
  			my $p = $1;
  			my $pathname = $g->{path}->full_path($p);
  			next if is_ref_ignored($g, $p);
  			next if $exists->{$pathname};
  			next if ($self->check_path($pathname, $r) !=
  			         $SVN::Node::dir);
  			$exists->{$pathname} = Git::SVN->init(
  			                      $self->url, $pathname, undef,
  			                      $g->{ref}->full_path($p), 1);
  		}
  		my $c = '';
  		foreach (split m#/#, $g->{path}->{left}) {
  			$c .= "/$_";
  			next unless ($paths->{$c} &&
  			             ($paths->{$c}->{action} =~ /^[AR]$/));
  			get_dir_check($self, $exists, $g, $r);
  		}
  	}
  	values %$exists;
  }
  
  sub minimize_url {
  	my ($self) = @_;
  	return $self->url if ($self->url eq $self->{repos_root});
  	my $url = $self->{repos_root};
  	my @components = split(m!/!, $self->{svn_path});
  	my $c = '';
  	do {
  		$url = add_path_to_url($url, $c);
  		eval {
  			my $ra = (ref $self)->new($url);
  			my $latest = $ra->get_latest_revnum;
  			$ra->get_log("", $latest, 0, 1, 0, 1, sub {});
  		};
  	} while ($@ && defined($c = shift @components));
  
  	return canonicalize_url($url);
  }
  
  sub can_do_switch {
  	my $self = shift;
  	unless (defined $can_do_switch) {
  		my $pool = SVN::Pool->new;
  		my $rep = eval {
  			$self->do_switch(1, '', 0, $self->url,
  			                 SVN::Delta::Editor->new, $pool);
  		};
  		if ($@) {
  			$can_do_switch = 0;
  		} else {
  			$rep->abort_report($pool);
  			$can_do_switch = 1;
  		}
  		$pool->clear;
  	}
  	$can_do_switch;
  }
  
  sub skip_unknown_revs {
  	my ($err) = @_;
  	my $errno = $err->apr_err();
  	# Maybe the branch we're tracking didn't
  	# exist when the repo started, so it's
  	# not an error if it doesn't, just continue
  	#
  	# Wonderfully consistent library, eh?
  	# 160013 - svn:// and file://
  	# 175002 - http(s)://
  	# 175007 - http(s):// (this repo required authorization, too...)
  	#   More codes may be discovered later...
  	if ($errno == 175007 || $errno == 175002 || $errno == 160013) {
  		my $err_key = $err->expanded_message;
  		# revision numbers change every time, filter them out
  		$err_key =~ s/\d+/\0/g;
  		$err_key = "$errno\0$err_key";
  		unless ($ignored_err{$err_key}) {
  			warn "W: Ignoring error from SVN, path probably ",
  			     "does not exist: ($errno): ",
  			     $err->expanded_message,"\n";
  			warn "W: Do not be alarmed at the above message ",
  			     "git-svn is just searching aggressively for ",
  			     "old history.\n",
  			     "This may take a while on large repositories\n";
  			$ignored_err{$err_key} = 1;
  		}
  		return;
  	}
  	die "Error from SVN, ($errno): ", $err->expanded_message,"\n";
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Ra - Subversion remote access functions for git-svn
  
  =head1 SYNOPSIS
  
      use Git::SVN::Ra;
  
      my $ra = Git::SVN::Ra->new($branchurl);
      my ($dirents, $fetched_revnum, $props) =
          $ra->get_dir('.', $SVN::Core::INVALID_REVNUM);
  
  =head1 DESCRIPTION
  
  This is a wrapper around the L<SVN::Ra> module for use by B<git-svn>.
  It fills in some default parameters (such as the authentication
  scheme), smooths over incompatibilities between libsvn versions, adds
  caching, and implements some functions specific to B<git-svn>.
  
  Do not use it unless you are developing git-svn.  The interface will
  change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  Subversion perl bindings,
  L<Git::SVN>.
  
  C<Git::SVN::Ra> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Ra>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_RA

$fatpacked{"Git/SVN/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_UTILS';
  package Git::SVN::Utils;
  
  use strict;
  use warnings;
  
  use SVN::Core;
  
  use base qw(Exporter);
  
  our @EXPORT_OK = qw(
  	fatal
  	can_compress
  	canonicalize_path
  	canonicalize_url
  	join_paths
  	add_path_to_url
  );
  
  
  =head1 NAME
  
  Git::SVN::Utils - utility functions used across Git::SVN
  
  =head1 SYNOPSIS
  
      use Git::SVN::Utils qw(functions to import);
  
  =head1 DESCRIPTION
  
  This module contains functions which are useful across many different
  parts of Git::SVN.  Mostly it's a place to put utility functions
  rather than duplicate the code or have classes grabbing at other
  classes.
  
  =head1 FUNCTIONS
  
  All functions can be imported only on request.
  
  =head3 fatal
  
      fatal(@message);
  
  Display a message and exit with a fatal error code.
  
  =cut
  
  # Note: not certain why this is in use instead of die.  Probably because
  # the exit code of die is 255?  Doesn't appear to be used consistently.
  sub fatal (@) { print STDERR "@_\n"; exit 1 }
  
  
  =head3 can_compress
  
      my $can_compress = can_compress;
  
  Returns true if Compress::Zlib is available, false otherwise.
  
  =cut
  
  my $can_compress;
  sub can_compress {
  	return $can_compress if defined $can_compress;
  
  	return $can_compress = eval { require Compress::Zlib; };
  }
  
  
  =head3 canonicalize_path
  
      my $canoncalized_path = canonicalize_path($path);
  
  Converts $path into a canonical form which is safe to pass to the SVN
  API as a file path.
  
  =cut
  
  # Turn foo/../bar into bar
  sub _collapse_dotdot {
  	my $path = shift;
  
  	1 while $path =~ s{/[^/]+/+\.\.}{};
  	1 while $path =~ s{[^/]+/+\.\./}{};
  	1 while $path =~ s{[^/]+/+\.\.}{};
  
  	return $path;
  }
  
  
  sub canonicalize_path {
  	my $path = shift;
  	my $rv;
  
  	# The 1.7 way to do it
  	if ( defined &SVN::_Core::svn_dirent_canonicalize ) {
  		$path = _collapse_dotdot($path);
  		$rv = SVN::_Core::svn_dirent_canonicalize($path);
  	}
  	# The 1.6 way to do it
  	# This can return undef on subversion-perl-1.4.2-2.el5 (CentOS 5.2)
  	elsif ( defined &SVN::_Core::svn_path_canonicalize ) {
  		$path = _collapse_dotdot($path);
  		$rv = SVN::_Core::svn_path_canonicalize($path);
  	}
  
  	return $rv if defined $rv;
  
  	# No SVN API canonicalization is available, or the SVN API
  	# didn't return a successful result, do it ourselves
  	return _canonicalize_path_ourselves($path);
  }
  
  
  sub _canonicalize_path_ourselves {
  	my ($path) = @_;
  	my $dot_slash_added = 0;
  	if (substr($path, 0, 1) ne "/") {
  		$path = "./" . $path;
  		$dot_slash_added = 1;
  	}
  	$path =~ s#/+#/#g;
  	$path =~ s#/\.(?:/|$)#/#g;
  	$path = _collapse_dotdot($path);
  	$path =~ s#/$##g;
  	$path =~ s#^\./## if $dot_slash_added;
  	$path =~ s#^\.$##;
  	return $path;
  }
  
  
  =head3 canonicalize_url
  
      my $canonicalized_url = canonicalize_url($url);
  
  Converts $url into a canonical form which is safe to pass to the SVN
  API as a URL.
  
  =cut
  
  sub canonicalize_url {
  	my $url = shift;
  
  	# The 1.7 way to do it
  	if ( defined &SVN::_Core::svn_uri_canonicalize ) {
  		return SVN::_Core::svn_uri_canonicalize($url);
  	}
  	# There wasn't a 1.6 way to do it, so we do it ourself.
  	else {
  		return _canonicalize_url_ourselves($url);
  	}
  }
  
  
  sub _canonicalize_url_path {
  	my ($uri_path) = @_;
  
  	my @parts;
  	foreach my $part (split m{/+}, $uri_path) {
  		$part =~ s/([^!\$%&'()*+,.\/\w:=\@_`~-]|%(?![a-fA-F0-9]{2}))/sprintf("%%%02X",ord($1))/eg;
  		push @parts, $part;
  	}
  
  	return join('/', @parts);
  }
  
  sub _canonicalize_url_ourselves {
  	my ($url) = @_;
  	if ($url =~ m#^([^:]+)://([^/]*)(.*)$#) {
  		my ($scheme, $domain, $uri) = ($1, $2, _canonicalize_url_path(canonicalize_path($3)));
  		$url = "$scheme://$domain$uri";
  	}
  	$url;
  }
  
  
  =head3 join_paths
  
      my $new_path = join_paths(@paths);
  
  Appends @paths together into a single path.  Any empty paths are ignored.
  
  =cut
  
  sub join_paths {
  	my @paths = @_;
  
  	@paths = grep { defined $_ && length $_ } @paths;
  
  	return '' unless @paths;
  	return $paths[0] if @paths == 1;
  
  	my $new_path = shift @paths;
  	$new_path =~ s{/+$}{};
  
  	my $last_path = pop @paths;
  	$last_path =~ s{^/+}{};
  
  	for my $path (@paths) {
  		$path =~ s{^/+}{};
  		$path =~ s{/+$}{};
  		$new_path .= "/$path";
  	}
  
  	return $new_path .= "/$last_path";
  }
  
  
  =head3 add_path_to_url
  
      my $new_url = add_path_to_url($url, $path);
  
  Appends $path onto the $url.  If $path is empty, $url is returned unchanged.
  
  =cut
  
  sub add_path_to_url {
  	my($url, $path) = @_;
  
  	return $url if !defined $path or !length $path;
  
  	# Strip trailing and leading slashes so we don't
  	# wind up with http://x.com///path
  	$url  =~ s{/+$}{};
  	$path =~ s{^/+}{};
  
  	# If a path has a % in it, URI escape it so it's not
  	# mistaken for a URI escape later.
  	$path =~ s{%}{%25}g;
  
  	return join '/', $url, $path;
  }
  
  1;
GIT_SVN_UTILS

$fatpacked{"HTTP/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  use URI;
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              no warnings 'uninitialized';
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuration object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Configuration for request and response objects
  
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.02";
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  will be the full 4-digit year, and $month numbers start with 1 (for January).
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned (C<undef> in
  scalar context).
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  use Carp ();
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  our $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      if (exists $self->{'::std_case'}) {
  	$c->{'::std_case'} = $self->{'::std_case'};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      Carp::croak("Illegal field name '$field'")
          if rindex($field, ':') > 1 || !length($field);
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless($standard_case{$field} || $self->{'::std_case'}{$field}) {
  	    # generate a %std_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $self->{'::std_case'}{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } grep !/^::/, keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $self->{'::std_case'}{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return grep !/^::/, keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $vals);
  	}
      }
  }
  
  sub flatten {
  	my($self)=@_;
  
  	(
  		map {
  			my $k = $_;
  			map {
  				( $k => $_ )
  			} $self->header($_);
  		} $self->header_field_names
  	);
  }
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		$val = '' if not defined $val;
  		my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    $vals = '' if not defined $vals;
  	    my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # initial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promises that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->flatten()
  
  Returns the list of pairs of keys and values.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Class encapsulating HTTP Message headers
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  use HTTP::Headers;
  
  package
      HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::Auth
  
  =head1 VERSION
  
  version 6.16
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package
      HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::ETag
  
  =head1 VERSION
  
  version 6.16
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  use base 'Exporter';
  
  our @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessarily be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Header value parsing utility functions
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  unless ($HTTP::URI_CLASS) {
      if ($ENV{PERL_HTTP_URI_CLASS}
      &&  $ENV{PERL_HTTP_URI_CLASS} =~ /^([\w:]+)$/) {
          $HTTP::URI_CLASS = $1;
      } else {
          $HTTP::URI_CLASS = "URI";
      }
  }
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = defined( $_[1] ) ? $_[1] : '';
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = defined( $_[1] ) ? $_[1] : '';
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16LE" if /^\xFF\xFE/;
  	return "UTF-16BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32BE" if /^\x00\x00\x00</;
  	    return "UTF-32LE" if /^<\x00\x00\x00/;
  	    return "UTF-16BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	require IO::HTML;
  	# Use relaxed search to match previous versions of HTTP::Message:
  	my $encoding = IO::HTML::find_charset_in($$cref, { encoding    => 1,
  	                                                   need_pragma => 0 });
  	return $encoding->mime_name if $encoding;
      }
      elsif ($self->content_type eq "application/json") {
  	for ($$cref) {
  	    # RFC 4627, ch 3
  	    return "UTF-32BE" if /^\x00\x00\x00./s;
  	    return "UTF-32LE" if /^.\x00\x00\x00/s;
  	    return "UTF-16BE" if /^\x00.\x00./s;
  	    return "UTF-16LE" if /^.\x00.\x00/s;
  	    return "UTF-8";
  	}
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity" || $ce eq "none";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2" or $ce eq "bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it as is
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2", "bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity" || $encoding eq "none") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2" || $encoding eq "bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = $opt{no_content};
  	$no_content = "(no content)" unless defined $no_content;
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = $no_content;
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  # allow subclasses to override what will handle individual parts
  sub _part_class {
      return __PACKAGE__;
  }
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = $self->_part_class->new(
  	    $self->remove_content_headers,
  	    $self->content(""),
  	);
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls to the headers object.
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { local $Carp::Internal{+__PACKAGE__} = 1; shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map $self->_part_class->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ $self->_part_class->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  If the C<undef> argument is given, the content is reset to its default value,
  which is an empty string.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If a @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item no_content => $str
  
  Replaces the "(no content)" marker.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style message (base class)
  
HTTP_MESSAGE

$fatpacked{"HTTP/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST';
  package HTTP::Request;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  use base 'HTTP::Message';
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      Carp::carp('Undefined argument to parse()') if $^W && ! defined $str;
      my $request_line;
      if (defined $str && $str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      if (defined $request_line) {
          my($method, $uri, $protocol) = split(' ', $request_line);
          $self->method($method);
          $self->uri($uri) if defined($uri);
          $self->protocol($protocol) if $protocol;
      }
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme') && $uri->can('canonical');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT", "PATCH" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parsable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 EXAMPLES
  
  Creating requests to be sent with L<LWP::UserAgent> or others can be easy. Here
  are a few examples.
  
  =head2 Simple POST
  
  Here, we'll create a simple POST request that could be used to send JSON data
  to an endpoint.
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
  
      use Encode qw(encode_utf8);
      use HTTP::Request ();
      use JSON::MaybeXS qw(encode_json);
  
      my $url = 'https://www.example.com/api/user/123';
      my $header = ['Content-Type' => 'application/json; charset=UTF-8'];
      my $data = {foo => 'bar', baz => 'quux'};
      my $encoded_data = encode_utf8(encode_json($data));
  
      my $r = HTTP::Request->new('POST', $url, $header, $encoded_data);
      # at this point, we could send it via LWP::UserAgent
      # my $ua = LWP::UserAgent->new();
      # my $res = $ua->request($r);
  
  =head2 Batch POST Request
  
  Some services, like Google, allow multiple requests to be sent in one batch.
  L<https://developers.google.com/drive/v3/web/batch> for example. Using the
  C<add_part> method from L<HTTP::Message> makes this simple.
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
  
      use Encode qw(encode_utf8);
      use HTTP::Request ();
      use JSON::MaybeXS qw(encode_json);
  
      my $auth_token = 'auth_token';
      my $batch_url = 'https://www.googleapis.com/batch';
      my $url = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id';
      my $url_no_email = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id&sendNotificationEmail=false';
  
      # generate a JSON post request for one of the batch entries
      my $req1 = build_json_request($url, {
          emailAddress => 'example@appsrocks.com',
          role => "writer",
          type => "user",
      });
  
      # generate a JSON post request for one of the batch entries
      my $req2 = build_json_request($url_no_email, {
          domain => "appsrocks.com",
          role => "reader",
          type => "domain",
      });
  
      # generate a multipart request to send all of the other requests
      my $r = HTTP::Request->new('POST', $batch_url, [
          'Accept-Encoding' => 'gzip',
          # if we don't provide a boundary here, HTTP::Message will generate
          # one for us. We could use UUID::uuid() here if we wanted.
          'Content-Type' => 'multipart/mixed; boundary=END_OF_PART'
      ]);
  
      # add the two POST requests to the main request
      $r->add_part($req1, $req2);
      # at this point, we could send it via LWP::UserAgent
      # my $ua = LWP::UserAgent->new();
      # my $res = $ua->request($r);
      exit();
  
      sub build_json_request {
          my ($url, $href) = @_;
          my $header = ['Authorization' => "Bearer $auth_token", 'Content-Type' => 'application/json; charset=UTF-8'];
          return HTTP::Request->new('POST', $url, $header, encode_utf8(encode_json($href)));
      }
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style request message
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  our $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  use Exporter 5.57 'import';
  
  our @EXPORT =qw(GET HEAD PUT PATCH POST);
  our @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  sub PATCH { request_type_with_data('PATCH', @_); }
  sub POST { request_type_with_data('POST', @_); }
  sub PUT { request_type_with_data('PUT', @_); }
  
  sub request_type_with_data
  {
      my $type = shift;
      my $url  = shift;
      my $req = HTTP::Request->new($type => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  
  	    # HTML/4.01 says that line breaks are represented as "CR LF" pairs (i.e., `%0D%0A')
  	    $content =~ s/(?<!%0D)%0A/%0D%0A/g if defined($content);
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      while (my ($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
              no warnings 'uninitialized';
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
    $ua->request(PATCH 'http://somewhere/foo', [foo => bar, bar => foo]);
    $ua->request(PUT 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provides functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.
  
  Note that L<LWP::UserAgent> has several convenience methods, including
  C<get>, C<head>, C<delete>, C<post> and C<put>.
  
  The following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The C<GET> function returns an L<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the C<PUT>, C<PATCH>
   and C<POST> functions described below.
  
  The C<get(...)> method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(GET ...) >>.
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The C<head(...)>  method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(HEAD ...) >>.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like C<GET> but the method in the request is C<DELETE>.  This function
  is not exported by default.
  
  =item PATCH $url
  
  =item PATCH $url, Header => Value,...
  
  =item PATCH $url, $form_ref, Header => Value,...
  
  =item PATCH $url, Header => Value,..., Content => $form_ref
  
  =item PATCH $url, Header => Value,..., Content => $content
  
  The same as C<POST> below, but the method in the request is C<PATCH>.
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, $form_ref, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $form_ref
  
  =item PUT $url, Header => Value,..., Content => $content
  
  The same as C<POST> below, but the method in the request is C<PUT>
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  C<POST>, C<PATCH> and C<PUT> all work with the same parameters.
  
    %data = ( title => 'something', body => something else' );
    $ua = LWP::UserAgent->new();
    $request = HTTP::Request::Common::POST( $url, [ %data ] );
    $response = $ua->request($request);
  
  They take a second optional array or hash reference
  parameter C<$form_ref>.  The content can also be specified
  directly using the C<Content> pseudo-header, and you may also provide
  the C<$form_ref> this way.
  
  The C<Content> pseudo-header steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  The C<$form_ref> argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate an HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create an L<HTTP::Request> object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the C<$form_ref> is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by C<LWP::MediaTypes::guess_media_type()>
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create an L<HTTP::Request> object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the C<$DYNAMIC_FILE_UPLOAD> variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no C<Content-Length> header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the C<Content-Length> is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The C<post(...)>  method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(POST ...) >>.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  Also, there are some examples in L<HTTP::Request/"EXAMPLES"> that you might
  find useful. For example, batch requests are explained there.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Construct common HTTP::Request objects
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_RESPONSE';
  package HTTP::Response;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  use base 'HTTP::Message';
  
  use HTTP::Status ();
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      Carp::carp('Undefined argument to parse()') if $^W && ! defined $str;
      my $status_line;
      if (defined $str && $str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      $status_line =~ s/\r\z// if defined $status_line;
  
      my $self = $class->SUPER::parse($str);
      if (defined $status_line) {
          my($protocol, $code, $message);
          if ($status_line =~ /^\d{3} /) {
             # Looks like a response created by HTTP::Response->new
             ($code, $message) = split(' ', $status_line, 2);
          } else {
             ($protocol, $code, $message) = split(' ', $status_line, 3);
          }
          $self->protocol($protocol) if $protocol;
          $self->code($code) if defined($code);
          $self->message($message) if defined($message);
      }
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  sub is_client_error { HTTP::Status::is_client_error (shift->{'_rc'}); }
  sub is_server_error { HTTP::Status::is_server_error (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request);
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meanings of these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of an HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then any base
  URI embedded in the document (step 1) will already have initialized the
  "Content-Base:" header. (See L<LWP::UserAgent/parse_head>).  This means that
  this method only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  =item $r->is_client_error
  
  =item $r->is_server_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style response message
  
HTTP_RESPONSE

$fatpacked{"HTTP/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.16';
  
  require 5.002;   # because we use prototypes
  
  use base 'Exporter';
  our @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  our @EXPORT_OK = qw(is_client_error is_server_error is_cacheable_by_default);
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 7231 (2017-12-20)
  # See also:
  # https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518: WebDAV
      103 => 'Early Hints',                     # RFC 8297: Indicating Hints
  #   104 .. 199
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',                 # RFC 7233: Range Requests
      207 => 'Multi-Status',                    # RFC 4918: WebDAV
      208 => 'Already Reported',                # RFC 5842: WebDAV bindings
  #   209 .. 225
      226 => 'IM used',                         # RFC 3229: Delta encoding
  #   227 .. 299
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',                    # RFC 7232: Conditional Request
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      308 => 'Permanent Redirect',              # RFC 7528: Permanent Redirect
  #   309 .. 399
      400 => 'Bad Request',
      401 => 'Unauthorized',                    # RFC 7235: Authentication
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',   # RFC 7235: Authentication
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',             # RFC 7232: Conditional Request
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',   # RFC 7233: Range Requests
      417 => 'Expectation Failed',
  #   418 .. 420
      421 => 'Misdirected Request',             # RFC 7540: HTTP/2
      422 => 'Unprocessable Entity',            # RFC 4918: WebDAV
      423 => 'Locked',                          # RFC 4918: WebDAV
      424 => 'Failed Dependency',               # RFC 4918: WebDAV
  #   425
      426 => 'Upgrade Required',
  #   427
      428 => 'Precondition Required',           # RFC 6585: Additional Codes
      429 => 'Too Many Requests',               # RFC 6585: Additional Codes
  #   430
      431 => 'Request Header Fields Too Large', # RFC 6585: Additional Codes
  #   432 .. 450
      451 => 'Unavailable For Legal Reasons',   # RFC 7724: Legal Obstacels
  #   452 .. 499
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295: Transparant Ngttn
      507 => 'Insufficient Storage',            # RFC 4918: WebDAV
      508 => 'Loop Detected',                   # RFC 5842: WebDAV bindings
  #   509
      510 => 'Not Extended',                    # RFC 2774: Extension Framework
      511 => 'Network Authentication Required', # RFC 6585: Additional Codes
  );
  
  # keep some unofficial codes that used to be in this distribution
  %StatusCode = (
      %StatusCode,
      418 => 'I\'m a teapot',                   # RFC 2324: HTCPC/1.0  1-april
      425 => 'Unordered Collection',            #           WebDAV Draft
      449 => 'Retry with',                      #           microsoft
      509 => 'Bandwidth Limit Exceeded',        #           Apache / cPanel
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ s/I'm/I am/;
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  *RC_NO_CODE = \&RC_UNORDERED_COLLECTION;
  push(@EXPORT, "RC_NO_CODE");
  
  our %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info                 ($) { $_[0] && $_[0] >= 100 && $_[0] < 200; }
  sub is_success              ($) { $_[0] && $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect             ($) { $_[0] && $_[0] >= 300 && $_[0] < 400; }
  sub is_error                ($) { $_[0] && $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error         ($) { $_[0] && $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error         ($) { $_[0] && $_[0] >= 500 && $_[0] < 600; }
  sub is_cacheable_by_default ($) { $_[0] &&
      (  $_[0] == 200 # OK
      || $_[0] == 203 # Non-Authoritative Information
      || $_[0] == 204 # No Content
      || $_[0] == 206 # Not Acceptable
      || $_[0] == 300 # Multiple Choices
      || $_[0] == 301 # Moved Permanently
      || $_[0] == 404 # Not Found
      || $_[0] == 405 # Method Not Allowed
      || $_[0] == 410 # Gone
      || $_[0] == 414 # Request-URI Too Large
      || $_[0] == 501 # Not Implemented
      ); }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 VERSION
  
  version 6.16
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of an HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
     HTTP_EARLY_HINTS                     (103)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
     HTTP_ALREADY_REPORTED		(208)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
     HTTP_PERMANENT_REDIRECT              (308)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_I_AM_A_TEAPOT			(418)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_PRECONDITION_REQUIRED		(428)
     HTTP_TOO_MANY_REQUESTS		(429)
     HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
     HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  returns TRUE for both client and server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is a I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is a I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =item is_cacheable_by_default( $code )
  
  Return TRUE if C<$code> indicates that a response is cacheable by default, and
  it can be reused by a cache with heuristic expiration. All other status codes
  are not cacheable by default. See L<RFC 7231 - HTTP/1.1 Semantics and Content, 
  Section 6.1. Overview of Status Codes|https://tools.ietf.org/html/rfc7231#section-6.1>.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explicit imports and
  the C<:constants> tag instead of relying on this.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP Status code processing
HTTP_STATUS

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use base qw(Exporter);
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '2.90';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my $Module_XS  = 'JSON::XS';
  my $Module_PP  = 'JSON::PP';
  my $Module_bp  = 'JSON::backportPP'; # included in JSON distribution
  my $PP_Version = '2.27203';
  my $XS_Version = '2.34';
  
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw/allow_tags/; # Currently nothing
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_INSTALL_ONLY      = 2; # Don't call _set_methods()
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  my $_USSING_bpPP       = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1' or $backend =~ /JSON::XS\s*,\s*JSON::PP/) {
          _load_xs($_INSTALL_DONT_DIE) or _load_pp();
      }
      elsif ($backend eq '0' or $backend eq 'JSON::PP') {
          _load_pp();
      }
      elsif ($backend eq '2' or $backend eq 'JSON::XS') {
          _load_xs();
      }
      elsif ($backend eq 'JSON::backportPP') {
          $_USSING_bpPP = 1;
          _load_pp();
      }
      else {
          Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend eq $Module_XS);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              eval q|
                  require B;
                  *UNIVERSAL::TO_JSON = sub {
                      my $b_obj = B::svref_2object( $_[0] );
                      return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                              : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                              : undef
                              ;
                  }
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $XS_Version; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->backend eq $Module_XS;
  }
  
  
  sub is_pp {
      return not $_[0]->is_xs;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub _load_xs {
      my $opt = shift;
  
      $JSON::DEBUG and Carp::carp "Load $Module_XS.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($Module_PP);
  
      eval qq|
          use $Module_XS $XS_Version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_XS...($@)";
              return 0;
          }
          Carp::croak $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_XS );
          my $data = join("", <DATA>); # this code is from Jcode 2.xx.
          close(DATA);
          eval $data;
          JSON::Backend::XS->init;
      }
  
      return 1;
  };
  
  
  sub _load_pp {
      my $opt = shift;
      my $backend = $_USSING_bpPP ? $Module_bp : $Module_PP;
  
      $JSON::DEBUG and Carp::carp "Load $backend.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($backend);
  
      if ( $_USSING_bpPP ) {
          eval qq| require $backend |;
      }
      else {
          eval qq| use $backend $PP_Version () |;
      }
  
      if ($@) {
          if ( $backend eq $Module_PP ) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_PP ($@), so try to load $Module_bp";
              $_USSING_bpPP++;
              $backend = $Module_bp;
              JSON::Boolean::_overrride_overload($backend);
              local $^W; # if PP installed but invalid version, backportPP redefines methods.
              eval qq| require $Module_bp |;
          }
          Carp::croak $@ if $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_PP ); # even if backportPP, set $Backend with 'JSON::PP'
          JSON::Backend::PP->init;
      }
  };
  
  
  sub _set_module {
      return if defined $JSON::true;
  
      my $module = shift;
  
      local $^W;
      no strict qw(refs);
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::ISA, $module;
      if ( JSON->is_xs and JSON->backend->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      for my $method ($module eq $Module_XS ? @PPOnlyMethods : @XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  
  
  #
  # JSON Boolean
  #
  
  package JSON::Boolean;
  
  my %Installed;
  
  sub _overrride_overload {
      return; # this function is currently disable.
      return if ($Installed{ $_[0] }++);
  
      my $boolean = $_[0] . '::Boolean';
  
      eval sprintf(q|
          package %s;
          use overload (
              '""' => sub { ${$_[0]} == 1 ? 'true' : 'false' },
              'eq' => sub {
                  my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
                  if ($op eq 'true' or $op eq 'false') {
                      return "$obj" eq 'true' ? 'true' eq $op : 'false' eq $op;
                  }
                  else {
                      return $obj ? 1 == $op : 0 == $op;
                  }
              },
          );
      |, $boolean);
  
      if ($@) { Carp::croak $@; }
  
      if ( exists $INC{'JSON/XS.pm'} and $boolean eq 'JSON::XS::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::XS::true  = sub () { $true };
          *JSON::XS::false = sub () { $false };
      }
      elsif ( exists $INC{'JSON/PP.pm'} and $boolean eq 'JSON::PP::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::PP::true  = sub { $true };
          *JSON::PP::false = sub { $false };
      }
  
      return 1;
  }
  
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::PP::is_xs"}  = sub { 0 };
      *{"JSON::PP::is_pp"}  = sub { 1 };
      return 1;
  }
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  use constant INDENT_LENGTH_FLAG => 15 << 12;
  
  use constant UNSUPPORTED_ENCODE_FLAG => {
      ESCAPE_SLASH      => 0x00000010,
      ALLOW_BIGNUM      => 0x00000020,
      AS_NONBLESSED     => 0x00000040,
      EXPANDED          => 0x10000000, # for developer's
  };
  
  use constant UNSUPPORTED_DECODE_FLAG => {
      LOOSE             => 0x00000001,
      ALLOW_BIGNUM      => 0x00000002,
      ALLOW_BAREKEY     => 0x00000004,
      ALLOW_SINGLEQUOTE => 0x00000008,
      EXPANDED          => 0x20000000, # for developer's
  };
  
  
  sub init {
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"JSON::XS::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::XS::encode_json"};
      *{"JSON::XS::is_xs"}  = sub { 1 };
      *{"JSON::XS::is_pp"}  = sub { 0 };
      return 1;
  }
  
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      local $^W;
      no strict qw(refs);
  
      my $JSON_XS_encode_orignal     = \&JSON::XS::encode;
      my $JSON_XS_decode_orignal     = \&JSON::XS::decode;
      my $JSON_XS_incr_parse_orignal = \&JSON::XS::incr_parse;
  
      *JSON::XS::decode     = \&JSON::Backend::XS::Supportable::_decode;
      *JSON::XS::encode     = \&JSON::Backend::XS::Supportable::_encode;
      *JSON::XS::incr_parse = \&JSON::Backend::XS::Supportable::_incr_parse;
  
      *{JSON::XS::_original_decode}     = $JSON_XS_decode_orignal;
      *{JSON::XS::_original_encode}     = $JSON_XS_encode_orignal;
      *{JSON::XS::_original_incr_parse} = $JSON_XS_incr_parse_orignal;
  
      push @JSON::Backend::XS::Supportable::ISA, 'JSON';
  
      my $pkg = 'JSON::Backend::XS::Supportable';
  
      *{JSON::new} = sub {
          my $proto = JSON::XS->new; $$proto = 0;
          bless  $proto, $pkg;
      };
  
  
      for my $method (@methods) {
          my $flag = uc($method);
          my $type |= (UNSUPPORTED_ENCODE_FLAG->{$flag} || 0);
             $type |= (UNSUPPORTED_DECODE_FLAG->{$flag} || 0);
  
          next unless($type);
  
          $pkg->_make_unsupported_method($method => $type);
      }
  
  #    push @{"JSON::XS::Boolean::ISA"}, qw(JSON::PP::Boolean);
  #    push @{"JSON::PP::Boolean::ISA"}, qw(JSON::Boolean);
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  
      return 1;
  }
  
  
  
  
  #
  # Helper classes for XS
  #
  
  package JSON::Backend::XS::Supportable;
  
  $Carp::Internal{'JSON::Backend::XS::Supportable'} = 1;
  
  sub _make_unsupported_method {
      my ($pkg, $method, $type) = @_;
  
      local $^W;
      no strict qw(refs);
  
      *{"$pkg\::$method"} = sub {
          local $^W;
          if (defined $_[1] ? $_[1] : 1) {
              ${$_[0]} |= $type;
          }
          else {
              ${$_[0]} &= ~$type;
          }
          $_[0];
      };
  
      *{"$pkg\::get_$method"} = sub {
          ${$_[0]} & $type ? 1 : '';
      };
  
  }
  
  
  sub _set_for_pp {
      JSON::_load_pp( $_INSTALL_ONLY );
  
      my $type  = shift;
      my $pp    = JSON::PP->new;
      my $prop = $_[0]->property;
  
      for my $name (keys %$prop) {
          $pp->$name( $prop->{$name} ? $prop->{$name} : 0 );
      }
  
      my $unsupported = $type eq 'encode' ? JSON::Backend::XS::UNSUPPORTED_ENCODE_FLAG
                                          : JSON::Backend::XS::UNSUPPORTED_DECODE_FLAG;
      my $flags       = ${$_[0]} || 0;
  
      for my $name (keys %$unsupported) {
          next if ($name eq 'EXPANDED'); # for developer's
          my $enable = ($flags & $unsupported->{$name}) ? 1 : 0;
          my $method = lc $name;
          $pp->$method($enable);
      }
  
      $pp->indent_length( $_[0]->get_indent_length );
  
      return $pp;
  }
  
  sub _encode { # using with PP encode
      if (${$_[0]}) {
          _set_for_pp('encode' => @_)->encode($_[1]);
      }
      else {
          $_[0]->_original_encode( $_[1] );
      }
  }
  
  
  sub _decode { # if unsupported-flag is set, use PP
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->decode($_[1]);
      }
      else {
          $_[0]->_original_decode( $_[1] );
      }
  }
  
  
  sub decode_prefix { # if unsupported-flag is set, use PP
      _set_for_pp('decode' => @_)->decode_prefix($_[1]);
  }
  
  
  sub _incr_parse {
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->incr_parse($_[1]);
      }
      else {
          $_[0]->_original_incr_parse( $_[1] );
      }
  }
  
  
  sub get_indent_length {
      ${$_[0]} << 4 >> 16;
  }
  
  
  sub indent_length {
      my $length = $_[1];
  
      if (!defined $length or $length > 15 or $length < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          local $^W;
          $length <<= 12;
          ${$_[0]} &= ~ JSON::Backend::XS::INDENT_LENGTH_FLAG;
          ${$_[0]} |= $length;
          *JSON::XS::encode = \&JSON::Backend::XS::Supportable::_encode;
      }
  
      $_[0];
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # If you want to use PP only support features, call with '-support_by_pp'
   # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.
   
   use JSON -support_by_pp;
   
   # option-acceptable interfaces (expect/generate UNICODE by default)
   
   $json_text   = to_json( $perl_scalar, { ascii => 1, pretty => 1 } );
   $perl_scalar = from_json( $json_text, { utf8  => 1 } );
   
   # Between (en|de)code_json and (to|from)_json, if you want to write
   # a code which communicates to an outer world (encoded in UTF-8),
   # recommend to use (en|de)code_json.
   
  =head1 VERSION
  
      2.90
  
  This version is compatible with JSON::XS B<2.34> and later.
  (Not yet compatble to JSON::XS B<3.0x>.)
  
  
  =head1 NOTE
  
  JSON::PP was earlier included in the C<JSON> distribution, but
  has since Perl 5.14 been a core module. For this reason,
  L<JSON::PP> was removed from the JSON distribution and can now
  be found also in the Perl5 repository at
  
  =over
  
  =item * L<http://perl5.git.perl.org/perl.git>
  
  =back
  
  (The newest JSON::PP version still exists in CPAN.)
  
  Instead, the C<JSON> distribution will include JSON::backportPP
  for backwards computability. JSON.pm should thus work as it did
  before.
  
  =head1 DESCRIPTION
  
   *************************** CAUTION **************************************
   *                                                                        *
   * INCOMPATIBLE CHANGE (JSON::XS version 2.90)                            *
   *                                                                        *
   * JSON.pm had patched JSON::XS::Boolean and JSON::PP::Boolean internally *
   * on loading time for making these modules inherit JSON::Boolean.        *
   * But since JSON::XS v3.0 it use Types::Serialiser as boolean class.     *
   * Then now JSON.pm breaks boolean classe overload features and           *
   * -support_by_pp if JSON::XS v3.0 or later is installed.                 *
   *                                                                        *
   * JSON::true and JSON::false returned JSON::Boolean objects.             *
   * For workaround, they return JSON::PP::Boolean objects in this version. *
   *                                                                        *
   *     isa_ok(JSON::true, 'JSON::PP::Boolean');                           *
   *                                                                        *
   * And it discards a feature:                                             *
   *                                                                        *
   *     ok(JSON::true eq 'true');                                          *
   *                                                                        *
   * In other word, JSON::PP::Boolean overload numeric only.                *
   *                                                                        *
   *     ok( JSON::true == 1 );                                             *
   *                                                                        *
   **************************************************************************
  
   ************************** CAUTION ********************************
   * This is 'JSON module version 2' and there are many differences  *
   * to version 1.xx                                                 *
   * Please check your applications using old version.              *
   *   See to 'INCOMPATIBLE CHANGES TO OLD VERSION'                  *
   *******************************************************************
  
  JSON (JavaScript Object Notation) is a simple data format.
  See to L<http://www.json.org/> and C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>).
  
  This module converts Perl data structures to JSON and vice versa using either
  L<JSON::XS> or L<JSON::PP>.
  
  JSON::XS is the fastest and most proper JSON module on CPAN which must be
  compiled and installed in your environment.
  JSON::PP is a pure-Perl module which is bundled in this distribution and
  has a strong compatibility to JSON::XS.
  
  This module try to use JSON::XS by default and fail to it, use JSON::PP instead.
  So its features completely depend on JSON::XS or JSON::PP.
  
  See to L<BACKEND MODULE DECISION>.
  
  To distinguish the module name 'JSON' and the format type JSON,
  the former is quoted by CE<lt>E<gt> (its results vary with your using media),
  and the latter is left just as it is.
  
  Module name : C<JSON>
  
  Format type : JSON
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module (i.e. backend modules) knows how to handle Unicode, documents
  how and when it does so, and even documents what "correct" means.
  
  Even though there are limitations, this feature is available since Perl version 5.6.
  
  JSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later), so in older versions
  C<JSON> should call JSON::PP as the backend which can be used since Perl 5.005.
  
  With Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a Perl side problem,
  JSON::PP works slower in the versions. And in 5.005, the Unicode handling is not available.
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> for more information.
  
  See also to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>
  and L<JSON::XS/ENCODING/CODESET_FLAG_NOTES>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  L</MAPPING> section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  See to L<JSON::XS/FEATURES> and L<JSON::PP/FEATURES>.
  
  =item * fast
  
  This module returns a JSON::XS object itself if available.
  Compared to other JSON modules and other serialisers such as Storable,
  JSON::XS usually compares favorably in terms of speed, too.
  
  If not available, C<JSON> returns a JSON::PP object instead of JSON::XS and
  it is very slow as pure-Perl.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an
  object oriented interface interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format possible
  (nice for simple line-based protocols), a pure-ASCII format (for when your transport
  is not 8-bit clean, still supports the whole Unicode range), or a pretty-printed
  format (for when you want to read that stuff). Or you can combine those features
  in whatever way you like.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  C<to_json> and C<from_json> are additional functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar)
  
  Converts the given Perl data structure to a json string.
  
  This function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Takes a hash reference as the second.
  
     $json_text = to_json($perl_scalar, $flag_hashref)
  
  So,
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
  
  equivalent to:
  
     $json_text = JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<encode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text)
  
  The opposite of C<to_json>: expects a json string and tries
  to parse it, returning the resulting reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->decode($json_text)
  
  Takes a hash reference as the second.
  
      $perl_scalar = from_json($json_text, $flag_hashref)
  
  So,
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
  
  equivalent to:
  
      $perl_scalar = JSON->new->utf8(1)->decode($json_text)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<decode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<from_json>.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    # or
    $perl_scalar = from_json( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<to_json>.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # or 
    $unicode_json_text = to_json( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  =head2 new
  
      $json = JSON->new
  
  Returns a new C<JSON> object inherited from either JSON::XS or JSON::PP
  that can be used to de/encode JSON strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
  This feature depends on the used Perl version and environment.
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  The indent space length is three and JSON::XS cannot change the indent
  space length.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, identifying them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The indent space length is three.
  With JSON::PP, you can also access C<indent_length> to change indent space length.
  
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =over
  
  =item convert_blessed_universally mode
  
  If use C<JSON> with C<-convert_blessed_universally>, the C<UNIVERSAL::TO_JSON>
  subroutine is defined as the below code:
  
     *UNIVERSAL::TO_JSON = sub {
         my $b_obj = B::svref_2object( $_[0] );
         return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                 : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                 : undef
                 ;
     }
  
  This will cause that C<encode> method converts simple blessed objects into
  JSON objects as non-blessed object.
  
     JSON -convert_blessed_universally;
     $json->allow_blessed->convert_blessed->encode( $blessed_object )
  
  This feature is experimental and may be removed in the future.
  
  =back
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  With JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  With JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>. See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE> and L<JSON::PP/METHODS>.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing. (JSON::XS)
  
  With JSON::PP as the backend, when a large value (100 or more) was set and
  it de/encodes a deep nested object/text, it may raise a warning
  'Deep recursion on subroutine' at the perl runtime phase.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS>, below, for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 property
  
      $boolean = $json->property($property_name)
  
  Returns a boolean value about above some properties.
  
  The available properties are C<ascii>, C<latin1>, C<utf8>,
  C<indent>,C<space_before>, C<space_after>, C<relaxed>, C<canonical>,
  C<allow_nonref>, C<allow_unknown>, C<allow_blessed>, C<convert_blessed>,
  C<shrink>, C<max_depth> and C<max_size>.
  
     $boolean = $json->property('utf8');
      => 0
     $json->utf8;
     $boolean = $json->property('utf8');
      => 1
  
  Sets the property with a given boolean value.
  
      $json = $json->property($property_name => $boolean);
  
  With no argument, it returns all the above properties as a hash reference.
  
      $flag_hashref = $json->property();
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  The backend module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP SUPPORT METHODS
  
  The below methods are JSON::PP own methods, so when C<JSON> works
  with JSON::PP (i.e. the created object is a JSON::PP object), available.
  See to L<JSON::PP/JSON::PP OWN METHODS> in detail.
  
  If you use C<JSON> with additional C<-support_by_pp>, some methods
  are available even with JSON::XS. See to L<USE PP FEATURES EVEN THOUGH XS BACKEND>.
  
     BEING { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
     # functional interfaces too.
     print to_json(["/"], {escape_slash => 1});
     print from_json('["foo"]', {utf8 => 1});
  
  If you do not want to all functions but C<-support_by_pp>,
  use C<-no_export>.
  
     use JSON -support_by_pp, -no_export;
     # functional interfaces are not exported.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  any JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<MAPPING> about the conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But by default
  JSON backend modules encode strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  With JSON::XS, The indent space length is 3 and cannot be changed.
  With JSON::PP, it sets the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  with 'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  If the backend is JSON::PP and C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  In future, the ordered object feature will be added to JSON::PP using C<tie> mechanism.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  With C<convert_blessed_universally> mode,  C<encode> converts blessed
  hash references or blessed array references (contains other blessed references)
  into JSON members and arrays.
  
     use JSON -convert_blessed_universally;
     JSON->new->allow_blessed->convert_blessed->encode( $blessed_object );
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  If the backend is JSON::PP and C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 JSON and ECMAscript
  
  See to L<JSON::XS/JSON and ECMAscript>.
  
  =head1 JSON and YAML
  
  JSON is not a subset of YAML.
  See to L<JSON::XS/JSON and YAML>.
  
  
  =head1 BACKEND MODULE DECISION
  
  When you use C<JSON>, C<JSON> tries to C<use> JSON::XS. If this call failed, it will
  C<uses> JSON::PP. The required JSON::XS version is I<2.2> or later.
  
  The C<JSON> constructor method returns an object inherited from the backend module,
  and JSON::XS object is a blessed scalar reference while JSON::PP is a blessed hash
  reference.
  
  So, your program should not depend on the backend module, especially
  returned objects should not be modified.
  
   my $json = JSON->new; # XS or PP?
   $json->{stash} = 'this is xs object'; # this code may raise an error!
  
  To check the backend module, there are some methods - C<backend>, C<is_pp> and C<is_xs>.
  
    JSON->backend; # 'JSON::XS' or 'JSON::PP'
    
    JSON->backend->is_pp: # 0 or 1
    
    JSON->backend->is_xs: # 1 or 0
    
    $json->is_xs; # 1 or 0
    
    $json->is_pp; # 0 or 1
  
  
  If you set an environment variable C<PERL_JSON_BACKEND>, the calling action will be changed.
  
  =over
  
  =item PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = 'JSON::PP'
  
  Always use JSON::PP
  
  =item PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = 'JSON::XS,JSON::PP'
  
  (The default) Use compiled JSON::XS if it is properly compiled & installed,
  otherwise use JSON::PP.
  
  =item PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = 'JSON::XS'
  
  Always use compiled JSON::XS, die if it isn't properly compiled & installed.
  
  =item PERL_JSON_BACKEND = 'JSON::backportPP'
  
  Always use JSON::backportPP.
  JSON::backportPP is JSON::PP back port module.
  C<JSON> includes JSON::backportPP instead of JSON::PP.
  
  =back
  
  These ideas come from L<DBI::PurePerl> mechanism.
  
  example:
  
   BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::PP' }
   use JSON; # always uses JSON::PP
  
  In future, it may be able to specify another module.
  
  =head1 USE PP FEATURES EVEN THOUGH XS BACKEND
  
  Many methods are available with either JSON::XS or JSON::PP and
  when the backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS unsupported)
  method is called, it will C<warn> and be noop.
  
  But If you C<use> C<JSON> passing the optional string C<-support_by_pp>,
  it makes a part of those unsupported methods available.
  This feature is achieved by using JSON::PP in C<de/encode>.
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS
     use JSON -support_by_pp;
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
  At this time, the returned object is a C<JSON::Backend::XS::Supportable>
  object (re-blessed XS object), and  by checking JSON::XS unsupported flags
  in de/encoding, can support some unsupported methods - C<loose>, C<allow_bignum>,
  C<allow_barekey>, C<allow_singlequote>, C<escape_slash> and C<indent_length>.
  
  When any unsupported methods are not enable, C<XS de/encode> will be
  used as is. The switch is achieved by changing the symbolic tables.
  
  C<-support_by_pp> is effective only when the backend module is JSON::XS
  and it makes the de/encoding speed down a bit.
  
  See to L<JSON::PP SUPPORT METHODS>.
  
  =head1 INCOMPATIBLE CHANGES TO OLD VERSION
  
  There are big incompatibility between new version (2.00) and old (1.xx).
  If you use old C<JSON> 1.xx in your code, please check it.
  
  See to L<Transition ways from 1.xx to 2.xx.>
  
  =over
  
  =item jsonToObj and objToJson are obsoleted.
  
  Non Perl-style name C<jsonToObj> and C<objToJson> are obsoleted
  (but not yet deleted from the source).
  If you use these functions in your code, please replace them
  with C<from_json> and C<to_json>.
  
  
  =item Global variables are no longer available.
  
  C<JSON> class variables - C<$JSON::AUTOCONVERT>, C<$JSON::BareKey>, etc...
  - are not available any longer.
  Instead, various features can be used through object methods.
  
  
  =item Package JSON::Converter and JSON::Parser are deleted.
  
  Now C<JSON> bundles with JSON::PP which can handle JSON more properly than them.
  
  =item Package JSON::NotString is deleted.
  
  There was C<JSON::NotString> class which represents JSON value C<true>, C<false>, C<null>
  and numbers. It was deleted and replaced by C<JSON::Boolean>.
  
  C<JSON::Boolean> represents C<true> and C<false>.
  
  C<JSON::Boolean> does not represent C<null>.
  
  C<JSON::null> returns C<undef>.
  
  C<JSON> makes L<JSON::XS::Boolean> and L<JSON::PP::Boolean> is-a relation
  to L<JSON::Boolean>.
  
  =item function JSON::Number is obsoleted.
  
  C<JSON::Number> is now needless because JSON::XS and JSON::PP have
  round-trip integrity.
  
  =item JSONRPC modules are deleted.
  
  Perl implementation of JSON-RPC protocol - C<JSONRPC >, C<JSONRPC::Transport::HTTP>
  and C<Apache::JSONRPC > are deleted in this distribution.
  Instead of them, there is L<JSON::RPC> which supports JSON-RPC protocol version 1.1.
  
  =back
  
  =head2 Transition ways from 1.xx to 2.xx.
  
  You should set C<suport_by_pp> mode firstly, because
  it is always successful for the below codes even with JSON::XS.
  
      use JSON -support_by_pp;
  
  =over
  
  =item Exported jsonToObj (simple)
  
    from_json($json_text);
  
  =item Exported objToJson (simple)
  
    to_json($perl_scalar);
  
  =item Exported jsonToObj (advanced)
  
    $flags = {allow_barekey => 1, allow_singlequote => 1};
    from_json($json_text, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    $JSON::QuotApos = 1;
    jsonToObj($json_text);
  
  =item Exported objToJson (advanced)
  
    $flags = {allow_blessed => 1, allow_barekey => 1};
    to_json($perl_scalar, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    objToJson($perl_scalar);
  
  =item jsonToObj as object method
  
    $json->decode($json_text);
  
  =item objToJson as object method
  
    $json->encode($perl_scalar);
  
  =item new method with parameters
  
  The C<new> method in 2.x takes any parameters no longer.
  You can set parameters instead;
  
     $json = JSON->new->pretty;
  
  =item $JSON::Pretty, $JSON::Indent, $JSON::Delimiter
  
  If C<indent> is enable, that means C<$JSON::Pretty> flag set. And
  C<$JSON::Delimiter> was substituted by C<space_before> and C<space_after>.
  In conclusion:
  
     $json->indent->space_before->space_after;
  
  Equivalent to:
  
    $json->pretty;
  
  To change indent length, use C<indent_length>.
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->pretty->indent_length(2)->encode($perl_scalar);
  
  =item $JSON::BareKey
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_barekey->decode($json_text)
  
  =item $JSON::ConvBlessed
  
  use C<-convert_blessed_universally>. See to L<convert_blessed>.
  
  =item $JSON::QuotApos
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_singlequote->decode($json_text)
  
  =item $JSON::SingleQuote
  
  Disable. C<JSON> does not make such a invalid JSON string any longer.
  
  =item $JSON::KeySort
  
    $json->canonical->encode($perl_scalar)
  
  This is the ascii sort.
  
  If you want to use with your own sort routine, check the C<sort_by> method.
  
  (Only with JSON::PP, even if C<-support_by_pp> is used currently.)
  
    $json->sort_by($sort_routine_ref)->encode($perl_scalar)
   
    $json->sort_by(sub { $JSON::PP::a <=> $JSON::PP::b })->encode($perl_scalar)
  
  Can't access C<$a> and C<$b> but C<$JSON::PP::a> and C<$JSON::PP::b>.
  
  =item $JSON::SkipInvalid
  
    $json->allow_unknown
  
  =item $JSON::AUTOCONVERT
  
  Needless. C<JSON> backend modules have the round-trip integrity.
  
  =item $JSON::UTF8
  
  Needless because C<JSON> (JSON::XS/JSON::PP) sets
  the UTF8 flag on properly.
  
      # With UTF8-flagged strings
  
      $json->allow_nonref;
      $str = chr(1000); # UTF8-flagged
  
      $json_text  = $json->utf8(0)->encode($str);
      utf8::is_utf8($json_text);
      # true
      $json_text  = $json->utf8(1)->encode($str);
      utf8::is_utf8($json_text);
      # false
  
      $str = '"' . chr(1000) . '"'; # UTF8-flagged
  
      $perl_scalar  = $json->utf8(0)->decode($str);
      utf8::is_utf8($perl_scalar);
      # true
      $perl_scalar  = $json->utf8(1)->decode($str);
      # died because of 'Wide character in subroutine'
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =item $JSON::UnMapping
  
  Disable. See to L<MAPPING>.
  
  =item $JSON::SelfConvert
  
  This option was deleted.
  Instead of it, if a given blessed object has the C<TO_JSON> method,
  C<TO_JSON> will be executed with C<convert_blessed>.
  
    $json->convert_blessed->encode($blessed_hashref_or_arrayref)
    # if need, call allow_blessed
  
  Note that it was C<toJson> in old version, but now not C<toJson> but C<TO_JSON>.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item example programs
  
  =back
  
  =head1 THREADS
  
  No test with JSON::PP. If with JSON::XS, See to L<JSON::XS/THREADS>.
  
  
  =head1 BUGS
  
  Please report bugs relevant to C<JSON> to E<lt>makamaka[at]cpan.orgE<gt>.
  
  
  =head1 SEE ALSO
  
  Most of the document is copied and modified from JSON::XS doc.
  
  L<JSON::XS>, L<JSON::PP>
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  use vars qw($VERSION);
  $VERSION = '2.27204';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package # hide from PAUSE
            JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  unless ( $INC{'JSON/PP.pm'} ) {
      eval q|
          package
              JSON::PP::Boolean;
  
          use overload (
              "0+"     => sub { ${$_[0]} },
              "++"     => sub { $_[0] = ${$_[0]} + 1 },
              "--"     => sub { $_[0] = ${$_[0]} - 1 },
              fallback => 1,
          );
      |;
  }
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  ###############################
  
  package # hide from PAUSE
    JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  use vars qw($VERSION);
  $VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj || '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27200
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and
  L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types
  supported by JSON and Perl, the deserialised data structure is
  identical on the Perl level. (e.g. the string "2.0" doesn't suddenly
  become "2" just because it looks like a number). There I<are> minor
  exceptions to this, read the MAPPING section below to learn about
  those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a
  security feature). But when some options are set, loose checking
  features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Returns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code reference
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutine' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> about the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Returns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte semantics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable
  and similar modules. See L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::backportPP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by
  Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP';
  package LWP;
  
  $VERSION = "6.08";
  sub Version { $VERSION; }
  
  require 5.008;
  require LWP::UserAgent;  # this should load everything you need
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  LWP - The World-Wide Web library for Perl
  
  =head1 SYNOPSIS
  
    use LWP;
    print "This is libwww-perl-$LWP::VERSION\n";
  
  
  =head1 DESCRIPTION
  
  The libwww-perl collection is a set of Perl modules which provides a
  simple and consistent application programming interface (API) to the
  World-Wide Web.  The main focus of the library is to provide classes
  and functions that allow you to write WWW clients. The library also
  contain modules that are of more general use and even classes that
  help you implement simple HTTP servers.
  
  Most modules in this library provide an object oriented API.  The user
  agent, requests sent and responses received from the WWW server are
  all represented by objects.  This makes a simple and powerful
  interface to these services.  The interface is easy to extend
  and customize for your own needs.
  
  The main features of the library are:
  
  =over 3
  
  =item *
  
  Contains various reusable components (modules) that can be
  used separately or together.
  
  =item *
  
  Provides an object oriented model of HTTP-style communication.  Within
  this framework we currently support access to http, https, gopher, ftp, news,
  file, and mailto resources.
  
  =item *
  
  Provides a full object oriented interface or
  a very simple procedural interface.
  
  =item *
  
  Supports the basic and digest authorization schemes.
  
  =item *
  
  Supports transparent redirect handling.
  
  =item *
  
  Supports access through proxy servers.
  
  =item *
  
  Provides parser for F<robots.txt> files and a framework for constructing robots.
  
  =item *
  
  Supports parsing of HTML forms.
  
  =item *
  
  Implements HTTP content negotiation algorithm that can
  be used both in protocol modules and in server scripts (like CGI
  scripts).
  
  =item *
  
  Supports HTTP cookies.
  
  =item *
  
  Some simple command line clients, for instance C<lwp-request> and C<lwp-download>.
  
  =back
  
  
  =head1 HTTP STYLE COMMUNICATION
  
  
  The libwww-perl library is based on HTTP style communication. This
  section tries to describe what that means.
  
  Let us start with this quote from the HTTP specification document
  <URL:http://www.w3.org/Protocols/>:
  
  =over 3
  
  =item
  
  The HTTP protocol is based on a request/response paradigm. A client
  establishes a connection with a server and sends a request to the
  server in the form of a request method, URI, and protocol version,
  followed by a MIME-like message containing request modifiers, client
  information, and possible body content. The server responds with a
  status line, including the message's protocol version and a success or
  error code, followed by a MIME-like message containing server
  information, entity meta-information, and possible body content.
  
  =back
  
  What this means to libwww-perl is that communication always take place
  through these steps: First a I<request> object is created and
  configured. This object is then passed to a server and we get a
  I<response> object in return that we can examine. A request is always
  independent of any previous requests, i.e. the service is stateless.
  The same simple model is used for any kind of service we want to
  access.
  
  For example, if we want to fetch a document from a remote file server,
  then we send it a request that contains a name for that document and
  the response will contain the document itself.  If we access a search
  engine, then the content of the request will contain the query
  parameters and the response will contain the query result.  If we want
  to send a mail message to somebody then we send a request object which
  contains our message to the mail server and the response object will
  contain an acknowledgment that tells us that the message has been
  accepted and will be forwarded to the recipient(s).
  
  It is as simple as that!
  
  
  =head2 The Request Object
  
  The libwww-perl request object has the class name C<HTTP::Request>.
  The fact that the class name uses C<HTTP::> as a
  prefix only implies that we use the HTTP model of communication.  It
  does not limit the kind of services we can try to pass this I<request>
  to.  For instance, we will send C<HTTP::Request>s both to ftp and
  gopher servers, as well as to the local file system.
  
  The main attributes of the request objects are:
  
  =over 3
  
  =item *
  
  B<method> is a short string that tells what kind of
  request this is.  The most common methods are B<GET>, B<PUT>,
  B<POST> and B<HEAD>.
  
  =item *
  
  B<uri> is a string denoting the protocol, server and
  the name of the "document" we want to access.  The B<uri> might
  also encode various other parameters.
  
  =item *
  
  B<headers> contains additional information about the
  request and can also used to describe the content.  The headers
  are a set of keyword/value pairs.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  =head2 The Response Object
  
  The libwww-perl response object has the class name C<HTTP::Response>.
  The main attributes of objects of this class are:
  
  =over 3
  
  =item *
  
  B<code> is a numerical value that indicates the overall
  outcome of the request.
  
  =item *
  
  B<message> is a short, human readable string that
  corresponds to the I<code>.
  
  =item *
  
  B<headers> contains additional information about the
  response and describe the content.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  Since we don't want to handle all possible I<code> values directly in
  our programs, a libwww-perl response object has methods that can be
  used to query what kind of response this is.  The most commonly used
  response classification methods are:
  
  =over 3
  
  =item is_success()
  
  The request was successfully received, understood or accepted.
  
  =item is_error()
  
  The request failed.  The server or the resource might not be
  available, access to the resource might be denied or other things might
  have failed for some reason.
  
  =back
  
  =head2 The User Agent
  
  Let us assume that we have created a I<request> object. What do we
  actually do with it in order to receive a I<response>?
  
  The answer is that you pass it to a I<user agent> object and this
  object takes care of all the things that need to be done
  (like low-level communication and error handling) and returns
  a I<response> object. The user agent represents your
  application on the network and provides you with an interface that
  can accept I<requests> and return I<responses>.
  
  The user agent is an interface layer between
  your application code and the network.  Through this interface you are
  able to access the various servers on the network.
  
  The class name for the user agent is C<LWP::UserAgent>.  Every
  libwww-perl application that wants to communicate should create at
  least one object of this class. The main method provided by this
  object is request(). This method takes an C<HTTP::Request> object as
  argument and (eventually) returns a C<HTTP::Response> object.
  
  The user agent has many other attributes that let you
  configure how it will interact with the network and with your
  application.
  
  =over 3
  
  =item *
  
  B<timeout> specifies how much time we give remote servers to
  respond before the library disconnects and creates an
  internal I<timeout> response.
  
  =item *
  
  B<agent> specifies the name that your application uses when it
  presents itself on the network.
  
  =item *
  
  B<from> can be set to the e-mail address of the person
  responsible for running the application.  If this is set, then the
  address will be sent to the servers with every request.
  
  =item *
  
  B<parse_head> specifies whether we should initialize response
  headers from the E<lt>head> section of HTML documents.
  
  =item *
  
  B<proxy> and B<no_proxy> specify if and when to go through
  a proxy server. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
  
  =item *
  
  B<credentials> provides a way to set up user names and
  passwords needed to access certain services.
  
  =back
  
  Many applications want even more control over how they interact
  with the network and they get this by sub-classing
  C<LWP::UserAgent>.  The library includes a
  sub-class, C<LWP::RobotUA>, for robot applications.
  
  =head2 An Example
  
  This example shows how the user agent, a request and a response are
  represented in actual perl code:
  
    # Create a user agent object
    use LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("MyApp/0.1 ");
  
    # Create a request
    my $req = HTTP::Request->new(POST => 'http://search.cpan.org/search');
    $req->content_type('application/x-www-form-urlencoded');
    $req->content('query=libwww-perl&mode=dist');
  
    # Pass request to the user agent and get a response back
    my $res = $ua->request($req);
  
    # Check the outcome of the response
    if ($res->is_success) {
        print $res->content;
    }
    else {
        print $res->status_line, "\n";
    }
  
  The $ua is created once when the application starts up.  New request
  objects should normally created for each request sent.
  
  
  =head1 NETWORK SUPPORT
  
  This section discusses the various protocol schemes and
  the HTTP style methods that headers may be used for each.
  
  For all requests, a "User-Agent" header is added and initialized from
  the $ua->agent attribute before the request is handed to the network
  layer.  In the same way, a "From" header is initialized from the
  $ua->from attribute.
  
  For all responses, the library adds a header called "Client-Date".
  This header holds the time when the response was received by
  your application.  The format and semantics of the header are the
  same as the server created "Date" header.  You may also encounter other
  "Client-XXX" headers.  They are all generated by the library
  internally and are not received from the servers.
  
  =head2 HTTP Requests
  
  HTTP requests are just handed off to an HTTP server and it
  decides what happens.  Few servers implement methods beside the usual
  "GET", "HEAD", "POST" and "PUT", but CGI-scripts may implement
  any method they like.
  
  If the server is not available then the library will generate an
  internal error response.
  
  The library automatically adds a "Host" and a "Content-Length" header
  to the HTTP request before it is sent over the network.
  
  For a GET request you might want to add a "If-Modified-Since" or
  "If-None-Match" header to make the request conditional.
  
  For a POST request you should add the "Content-Type" header.  When you
  try to emulate HTML E<lt>FORM> handling you should usually let the value
  of the "Content-Type" header be "application/x-www-form-urlencoded".
  See L<lwpcook> for examples of this.
  
  The libwww-perl HTTP implementation currently support the HTTP/1.1
  and HTTP/1.0 protocol.
  
  The library allows you to access proxy server through HTTP.  This
  means that you can set up the library to forward all types of request
  through the HTTP protocol module.  See L<LWP::UserAgent> for
  documentation of this.
  
  
  =head2 HTTPS Requests
  
  HTTPS requests are HTTP requests over an encrypted network connection
  using the SSL protocol developed by Netscape.  Everything about HTTP
  requests above also apply to HTTPS requests.  In addition the library
  will add the headers "Client-SSL-Cipher", "Client-SSL-Cert-Subject" and
  "Client-SSL-Cert-Issuer" to the response.  These headers denote the
  encryption method used and the name of the server owner.
  
  The request can contain the header "If-SSL-Cert-Subject" in order to
  make the request conditional on the content of the server certificate.
  If the certificate subject does not match, no request is sent to the
  server and an internally generated error response is returned.  The
  value of the "If-SSL-Cert-Subject" header is interpreted as a Perl
  regular expression.
  
  
  =head2 FTP Requests
  
  The library currently supports GET, HEAD and PUT requests.  GET
  retrieves a file or a directory listing from an FTP server.  PUT
  stores a file on a ftp server.
  
  You can specify a ftp account for servers that want this in addition
  to user name and password.  This is specified by including an "Account"
  header in the request.
  
  User name/password can be specified using basic authorization or be
  encoded in the URL.  Failed logins return an UNAUTHORIZED response with
  "WWW-Authenticate: Basic" and can be treated like basic authorization
  for HTTP.
  
  The library supports ftp ASCII transfer mode by specifying the "type=a"
  parameter in the URL. It also supports transfer of ranges for FTP transfers
  using the "Range" header.
  
  Directory listings are by default returned unprocessed (as returned
  from the ftp server) with the content media type reported to be
  "text/ftp-dir-listing". The C<File::Listing> module provides methods
  for parsing of these directory listing.
  
  The ftp module is also able to convert directory listings to HTML and
  this can be requested via the standard HTTP content negotiation
  mechanisms (add an "Accept: text/html" header in the request if you
  want this).
  
  For normal file retrievals, the "Content-Type" is guessed based on the
  file name suffix. See L<LWP::MediaTypes>.
  
  The "If-Modified-Since" request header works for servers that implement
  the MDTM command.  It will probably not work for directory listings though.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
    $req->header(Accept => "text/html, */*;q=0.1");
  
  =head2 News Requests
  
  Access to the USENET News system is implemented through the NNTP
  protocol.  The name of the news server is obtained from the
  NNTP_SERVER environment variable and defaults to "news".  It is not
  possible to specify the hostname of the NNTP server in news: URLs.
  
  The library supports GET and HEAD to retrieve news articles through the
  NNTP protocol.  You can also post articles to newsgroups by using
  (surprise!) the POST method.
  
  GET on newsgroups is not implemented yet.
  
  Examples:
  
    $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
  
    $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
    $req->header(Subject => 'This is a test',
                 From    => 'me@some.where.org');
    $req->content(<<EOT);
    This is the content of the message that we are sending to
    the world.
    EOT
  
  
  =head2 Gopher Request
  
  The library supports the GET and HEAD methods for gopher requests.  All
  request header values are ignored.  HEAD cheats and returns a
  response without even talking to server.
  
  Gopher menus are always converted to HTML.
  
  The response "Content-Type" is generated from the document type
  encoded (as the first letter) in the request URL path itself.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'gopher://gopher.sn.no/');
  
  
  
  =head2 File Request
  
  The library supports GET and HEAD methods for file requests.  The
  "If-Modified-Since" header is supported.  All other headers are
  ignored.  The I<host> component of the file URL must be empty or set
  to "localhost".  Any other I<host> value will be treated as an error.
  
  Directories are always converted to an HTML document.  For normal
  files, the "Content-Type" and "Content-Encoding" in the response are
  guessed based on the file suffix.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'file:/etc/passwd');
  
  
  =head2 Mailto Request
  
  You can send (aka "POST") mail messages using the library.  All
  headers specified for the request are passed on to the mail system.
  The "To" header is initialized from the mail address in the URL.
  
  Example:
  
    $req = HTTP::Request->new(POST => 'mailto:libwww@perl.org');
    $req->header(Subject => "subscribe");
    $req->content("Please subscribe me to the libwww-perl mailing list!\n");
  
  =head2 CPAN Requests
  
  URLs with scheme C<cpan:> are redirected to the a suitable CPAN
  mirror.  If you have your own local mirror of CPAN you might tell LWP
  to use it for C<cpan:> URLs by an assignment like this:
  
    $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
  
  Suitable CPAN mirrors are also picked up from the configuration for
  the CPAN.pm, so if you have used that module a suitable mirror should
  be picked automatically.  If neither of these apply, then a redirect
  to the generic CPAN http location is issued.
  
  Example request to download the newest perl:
  
    $req = HTTP::Request->new(GET => "cpan:src/latest.tar.gz");
  
  
  =head1 OVERVIEW OF CLASSES AND PACKAGES
  
  This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
  
   LWP::MemberMixin   -- Access to member variables of Perl5 classes
     LWP::UserAgent   -- WWW user agent class
       LWP::RobotUA   -- When developing a robot applications
     LWP::Protocol          -- Interface to various protocol schemes
       LWP::Protocol::http  -- http:// access
       LWP::Protocol::file  -- file:// access
       LWP::Protocol::ftp   -- ftp:// access
       ...
  
   LWP::Authen::Basic -- Handle 401 and 407 responses
   LWP::Authen::Digest
  
   HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
   HTTP::Message      -- HTTP style message
     HTTP::Request    -- HTTP request
     HTTP::Response   -- HTTP response
   HTTP::Daemon       -- A HTTP server class
  
   WWW::RobotRules    -- Parse robots.txt files
     WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
  
   Net::HTTP          -- Low level HTTP client
  
  The following modules provide various functions and definitions.
  
   LWP                -- This file.  Library version number and documentation.
   LWP::MediaTypes    -- MIME types configuration (text/html etc.)
   LWP::Simple        -- Simplified procedural interface for common functions
   HTTP::Status       -- HTTP status code (200 OK etc)
   HTTP::Date         -- Date parsing module for HTTP date formats
   HTTP::Negotiate    -- HTTP content negotiation calculation
   File::Listing      -- Parse directory listings
   HTML::Form         -- Processing for <form>s in HTML documents
  
  
  =head1 MORE DOCUMENTATION
  
  All modules contain detailed information on the interfaces they
  provide.  The L<lwpcook> manpage is the libwww-perl cookbook that contain
  examples of typical usage of the library.  You might want to take a
  look at how the scripts L<lwp-request>, L<lwp-download>, L<lwp-dump>
  and L<lwp-mirror> are implemented.
  
  =head1 ENVIRONMENT
  
  The following environment variables are used by LWP:
  
  =over
  
  =item HOME
  
  The C<LWP::MediaTypes> functions will look for the F<.media.types> and
  F<.mime.types> files relative to you home directory.
  
  =item http_proxy
  
  =item ftp_proxy
  
  =item xxx_proxy
  
  =item no_proxy
  
  These environment variables can be set to enable communication through
  a proxy server.  See the description of the C<env_proxy> method in
  L<LWP::UserAgent>.
  
  =item PERL_LWP_ENV_PROXY
  
  If set to a TRUE value, then the C<LWP::UserAgent> will by default call
  C<env_proxy> during initialization.  This makes LWP honor the proxy variables
  described above.
  
  =item PERL_LWP_SSL_VERIFY_HOSTNAME
  
  The default C<verify_hostname> setting for C<LWP::UserAgent>.  If
  not set the default will be 1.  Set it as 0 to disable hostname
  verification (the default prior to libwww-perl 5.840.
  
  =item PERL_LWP_SSL_CA_FILE
  
  =item PERL_LWP_SSL_CA_PATH
  
  The file and/or directory
  where the trusted Certificate Authority certificates
  is located.  See L<LWP::UserAgent> for details.
  
  =item PERL_HTTP_URI_CLASS
  
  Used to decide what URI objects to instantiate.  The default is C<URI>.
  You might want to set it to C<URI::URL> for compatibility with old times.
  
  =back
  
  =head1 AUTHORS
  
  LWP was made possible by contributions from Adam Newby, Albert
  Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas König,
  Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
  Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
  J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
  Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
  Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
  D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
  Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
  Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
  Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
  Williams, KONISHI Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
  Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
  Markus B Krüger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
  Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
  Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
  J. Schinder, peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin,
  Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
  Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
  shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
  Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
  Tony Finch, Ville Skyttä, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
  
  LWP owes a lot in motivation, design, and code, to the libwww-perl
  library for Perl4 by Roy Fielding, which included work from Alberto
  Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
  Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
  Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
  Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
  libwww-perl-0.40 library for details.
  
  =head1 COPYRIGHT
  
    Copyright 1995-2009, Gisle Aas
    Copyright 1995, Martijn Koster
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AVAILABILITY
  
  The latest version of this library is likely to be available from CPAN
  as well as:
  
    http://github.com/libwww-perl/libwww-perl
  
  The best place to discuss this code is on the <libwww@perl.org>
  mailing list.
  
  =cut
LWP

$fatpacked{"LWP/Authen/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_BASIC';
  package LWP::Authen::Basic;
  use strict;
  
  require MIME::Base64;
  
  sub auth_header {
      my($class, $user, $pass) = @_;
      return "Basic " . MIME::Base64::encode("$user:$pass", "");
  }
  
  sub authenticate
  {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my $realm = $auth_param->{realm} || "";
      my $url = $proxy ? $request->{proxy} : $request->uri_canonical;
      return $response unless $url;
      my $host_port = $url->host_port;
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
      my @m = $proxy ? (m_proxy => $url) : (m_host_port => $host_port);
      push(@m, realm => $realm);
  
      my $h = $ua->get_my_handler("request_prepare", @m, sub {
          $_[0]{callback} = sub {
              my($req, $ua, $h) = @_;
              my($user, $pass) = $ua->credentials($host_port, $h->{realm});
  	    if (defined $user) {
  		my $auth_value = $class->auth_header($user, $pass, $req, $ua, $h);
  		$req->header($auth_header => $auth_value);
  	    }
          };
      });
      $h->{auth_param} = $auth_param;
  
      if (!$proxy && !$request->header($auth_header) && $ua->credentials($host_port, $realm)) {
  	# we can make sure this handler applies and retry
          add_path($h, $url->path);
          return $ua->request($request->clone, $arg, $size, $response);
      }
  
      my($user, $pass) = $ua->get_basic_credentials($realm, $url, $proxy);
      unless (defined $user and defined $pass) {
  	$ua->set_my_handler("request_prepare", undef, @m);  # delete handler
  	return $response;
      }
  
      # check that the password has changed
      my ($olduser, $oldpass) = $ua->credentials($host_port, $realm);
      return $response if (defined $olduser and defined $oldpass and
                           $user eq $olduser and $pass eq $oldpass);
  
      $ua->credentials($host_port, $realm, $user, $pass);
      add_path($h, $url->path) unless $proxy;
      return $ua->request($request->clone, $arg, $size, $response);
  }
  
  sub add_path {
      my($h, $path) = @_;
      $path =~ s,[^/]+\z,,;
      push(@{$h->{m_path_prefix}}, $path);
  }
  
  1;
LWP_AUTHEN_BASIC

$fatpacked{"LWP/Authen/Digest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_DIGEST';
  package LWP::Authen::Digest;
  
  use strict;
  use base 'LWP::Authen::Basic';
  
  require Digest::MD5;
  
  sub auth_header {
      my($class, $user, $pass, $request, $ua, $h) = @_;
  
      my $auth_param = $h->{auth_param};
  
      my $nc = sprintf "%08X", ++$ua->{authen_md5_nonce_count}{$auth_param->{nonce}};
      my $cnonce = sprintf "%8x", time;
  
      my $uri = $request->uri->path_query;
      $uri = "/" unless length $uri;
  
      my $md5 = Digest::MD5->new;
  
      my(@digest);
      $md5->add(join(":", $user, $auth_param->{realm}, $pass));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      push(@digest, $auth_param->{nonce});
  
      if ($auth_param->{qop}) {
  	push(@digest, $nc, $cnonce, ($auth_param->{qop} =~ m|^auth[,;]auth-int$|) ? 'auth' : $auth_param->{qop});
      }
  
      $md5->add(join(":", $request->method, $uri));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      $md5->add(join(":", @digest));
      my($digest) = $md5->hexdigest;
      $md5->reset;
  
      my %resp = map { $_ => $auth_param->{$_} } qw(realm nonce opaque);
      @resp{qw(username uri response algorithm)} = ($user, $uri, $digest, "MD5");
  
      if (($auth_param->{qop} || "") =~ m|^auth([,;]auth-int)?$|) {
  	@resp{qw(qop cnonce nc)} = ("auth", $cnonce, $nc);
      }
  
      my(@order) = qw(username realm qop algorithm uri nonce nc cnonce response);
      if($request->method =~ /^(?:POST|PUT)$/) {
  	$md5->add($request->content);
  	my $content = $md5->hexdigest;
  	$md5->reset;
  	$md5->add(join(":", @digest[0..1], $content));
  	$md5->reset;
  	$resp{"message-digest"} = $md5->hexdigest;
  	push(@order, "message-digest");
      }
      push(@order, "opaque");
      my @pairs;
      for (@order) {
  	next unless defined $resp{$_};
  
  	# RFC2617 sais that qop-value and nc-value should be unquoted.
  	if ( $_ eq 'qop' || $_ eq 'nc' ) {
  		push(@pairs, "$_=" . $resp{$_});
  	}
  	else {
  		push(@pairs, "$_=" . qq("$resp{$_}"));
  	}
      }
  
      my $auth_value  = "Digest " . join(", ", @pairs);
      return $auth_value;
  }
  
  1;
LWP_AUTHEN_DIGEST

$fatpacked{"LWP/Authen/Ntlm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_NTLM';
  package LWP::Authen::Ntlm;
  
  use strict;
  use vars qw/$VERSION/;
  
  $VERSION = "6.00";
  
  use Authen::NTLM "1.02";
  use MIME::Base64 "2.12";
  
  sub authenticate {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my($user, $pass) = $ua->get_basic_credentials($auth_param->{realm},
                                                    $request->uri, $proxy);
  
      unless(defined $user and defined $pass) {
  		return $response;
  	}
  
  	if (!$ua->conn_cache()) {
  		warn "The keep_alive option must be enabled for NTLM authentication to work.  NTLM authentication aborted.\n";
  		return $response;
  	}
  
  	my($domain, $username) = split(/\\/, $user);
  
  	ntlm_domain($domain);
  	ntlm_user($username);
  	ntlm_password($pass);
  
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
  	# my ($challenge) = $response->header('WWW-Authenticate'); 
  	my $challenge;
  	foreach ($response->header('WWW-Authenticate')) { 
  		last if /^NTLM/ && ($challenge=$_);
  	}
  
  	if ($challenge eq 'NTLM') {
  		# First phase, send handshake
  	    my $auth_value = "NTLM " . ntlm();
  		ntlm_reset();
  
  	    # Need to check this isn't a repeated fail!
  	    my $r = $response;
  		my $retry_count = 0;
  	    while ($r) {
  			my $auth = $r->request->header($auth_header);
  			++$retry_count if ($auth && $auth eq $auth_value);
  			if ($retry_count > 2) {
  				    # here we know this failed before
  				    $response->header("Client-Warning" =>
  						      "Credentials for '$user' failed before");
  				    return $response;
  			}
  			$r = $r->previous;
  	    }
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    return $ua->request($referral, $arg, $size, $response);
  	}
  	
  	else {
  		# Second phase, use the response challenge (unless non-401 code
  		#  was returned, in which case, we just send back the response
  		#  object, as is
  		my $auth_value;
  		if ($response->code ne '401') {
  			return $response;
  		}
  		else {
  			my $challenge;
  			foreach ($response->header('WWW-Authenticate')) { 
  				last if /^NTLM/ && ($challenge=$_);
  			}
  			$challenge =~ s/^NTLM //;
  			ntlm();
  			$auth_value = "NTLM " . ntlm($challenge);
  			ntlm_reset();
  		}
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    my $response2 = $ua->request($referral, $arg, $size, $response);
  		return $response2;
  	}
  }
  
  1;
  
  
  =head1 NAME
  
  LWP::Authen::Ntlm - Library for enabling NTLM authentication (Microsoft) in LWP
  
  =head1 SYNOPSIS
  
   use LWP::UserAgent;
   use HTTP::Request::Common;
   my $url = 'http://www.company.com/protected_page.html';
  
   # Set up the ntlm client and then the base64 encoded ntlm handshake message
   my $ua = LWP::UserAgent->new(keep_alive=>1);
   $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
   $request = GET $url;
   print "--Performing request now...-----------\n";
   $response = $ua->request($request);
   print "--Done with request-------------------\n";
  
   if ($response->is_success) {print "It worked!->" . $response->code . "\n"}
   else {print "It didn't work!->" . $response->code . "\n"}
  
  =head1 DESCRIPTION
  
  C<LWP::Authen::Ntlm> allows LWP to authenticate against servers that are using the 
  NTLM authentication scheme popularized by Microsoft.  This type of authentication is 
  common on intranets of Microsoft-centric organizations.
  
  The module takes advantage of the Authen::NTLM module by Mark Bush.  Since there 
  is also another Authen::NTLM module available from CPAN by Yee Man Chan with an 
  entirely different interface, it is necessary to ensure that you have the correct 
  NTLM module.
  
  In addition, there have been problems with incompatibilities between different 
  versions of Mime::Base64, which Bush's Authen::NTLM makes use of.  Therefore, it is 
  necessary to ensure that your Mime::Base64 module supports exporting of the 
  encode_base64 and decode_base64 functions.
  
  =head1 USAGE
  
  The module is used indirectly through LWP, rather than including it directly in your 
  code.  The LWP system will invoke the NTLM authentication when it encounters the 
  authentication scheme while attempting to retrieve a URL from a server.  In order 
  for the NTLM authentication to work, you must have a few things set up in your 
  code prior to attempting to retrieve the URL:
  
  =over 4
  
  =item *
  
  Enable persistent HTTP connections
  
  To do this, pass the "keep_alive=>1" option to the LWP::UserAgent when creating it, like this:
  
      my $ua = LWP::UserAgent->new(keep_alive=>1);
  
  =item *
  
  Set the credentials on the UserAgent object
  
  The credentials must be set like this:
  
     $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
  Note that you cannot use the HTTP::Request object's authorization_basic() method to set 
  the credentials.  Note, too, that the 'www.company.com:80' portion only sets credentials 
  on the specified port AND it is case-sensitive (this is due to the way LWP is coded, and 
  has nothing to do with LWP::Authen::Ntlm)
  
  =back
  
  =head1 AVAILABILITY
  
  General queries regarding LWP should be made to the LWP Mailing List.
  
  Questions specific to LWP::Authen::Ntlm can be forwarded to jtillman@bigfoot.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 James Tillman. All rights reserved. This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<lwpcook>.
LWP_AUTHEN_NTLM

$fatpacked{"LWP/ConnCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_CONNCACHE';
  package LWP::ConnCache;
  
  use strict;
  use vars qw($VERSION $DEBUG);
  
  $VERSION = "6.02";
  
  
  sub new {
      my($class, %cnf) = @_;
  
      my $total_capacity = 1;
      if (exists $cnf{total_capacity}) {
          $total_capacity = delete $cnf{total_capacity};
      }
      if (%cnf && $^W) {
  	require Carp;
  	Carp::carp("Unrecognised options: @{[sort keys %cnf]}")
      }
      my $self = bless { cc_conns => [] }, $class;
      $self->total_capacity($total_capacity);
      $self;
  }
  
  
  sub deposit {
      my($self, $type, $key, $conn) = @_;
      push(@{$self->{cc_conns}}, [$conn, $type, $key, time]);
      $self->enforce_limits($type);
      return;
  }
  
  
  sub withdraw {
      my($self, $type, $key) = @_;
      my $conns = $self->{cc_conns};
      for my $i (0 .. @$conns - 1) {
  	my $c = $conns->[$i];
  	next unless $c->[1] eq $type && $c->[2] eq $key;
  	splice(@$conns, $i, 1);  # remove it
  	return $c->[0];
      }
      return undef;
  }
  
  
  sub total_capacity {
      my $self = shift;
      my $old = $self->{cc_limit_total};
      if (@_) {
  	$self->{cc_limit_total} = shift;
  	$self->enforce_limits;
      }
      $old;
  }
  
  
  sub capacity {
      my $self = shift;
      my $type = shift;
      my $old = $self->{cc_limit}{$type};
      if (@_) {
  	$self->{cc_limit}{$type} = shift;
  	$self->enforce_limits($type);
      }
      $old;
  }
  
  
  sub enforce_limits {
      my($self, $type) = @_;
      my $conns = $self->{cc_conns};
  
      my @types = $type ? ($type) : ($self->get_types);
      for $type (@types) {
  	next unless $self->{cc_limit};
  	my $limit = $self->{cc_limit}{$type};
  	next unless defined $limit;
  	for my $i (reverse 0 .. @$conns - 1) {
  	    next unless $conns->[$i][1] eq $type;
  	    if (--$limit < 0) {
  		$self->dropping(splice(@$conns, $i, 1), "$type capacity exceeded");
  	    }
  	}
      }
  
      if (defined(my $total = $self->{cc_limit_total})) {
  	while (@$conns > $total) {
  	    $self->dropping(shift(@$conns), "Total capacity exceeded");
  	}
      }
  }
  
  
  sub dropping {
      my($self, $c, $reason) = @_;
      print "DROPPING @$c [$reason]\n" if $DEBUG;
  }
  
  
  sub drop {
      my($self, $checker, $reason) = @_;
      if (ref($checker) ne "CODE") {
  	# make it so
  	if (!defined $checker) {
  	    $checker = sub { 1 };  # drop all of them
  	}
  	elsif (_looks_like_number($checker)) {
  	    my $age_limit = $checker;
  	    my $time_limit = time - $age_limit;
  	    $reason ||= "older than $age_limit";
  	    $checker = sub { $_[3] < $time_limit };
  	}
  	else {
  	    my $type = $checker;
  	    $reason ||= "drop $type";
  	    $checker = sub { $_[1] eq $type };  # match on type
  	}
      }
      $reason ||= "drop";
  
      local $SIG{__DIE__};  # don't interfere with eval below
      local $@;
      my @c;
      for (@{$self->{cc_conns}}) {
  	my $drop;
  	eval {
  	    if (&$checker(@$_)) {
  		$self->dropping($_, $reason);
  		$drop++;
  	    }
  	};
  	push(@c, $_) unless $drop;
      }
      @{$self->{cc_conns}} = @c;
  }
  
  
  sub prune {
      my $self = shift;
      $self->drop(sub { !shift->ping }, "ping");
  }
  
  
  sub get_types {
      my $self = shift;
      my %t;
      $t{$_->[1]}++ for @{$self->{cc_conns}};
      return keys %t;
  }
  
  
  sub get_connections {
      my($self, $type) = @_;
      my @c;
      for (@{$self->{cc_conns}}) {
  	push(@c, $_->[0]) if !$type || ($type && $type eq $_->[1]);
      }
      @c;
  }
  
  
  sub _looks_like_number {
      $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::ConnCache - Connection cache manager
  
  =head1 NOTE
  
  This module is experimental.  Details of its interface is likely to
  change in the future.
  
  =head1 SYNOPSIS
  
   use LWP::ConnCache;
   my $cache = LWP::ConnCache->new;
   $cache->deposit($type, $key, $sock);
   $sock = $cache->withdraw($type, $key);
  
  =head1 DESCRIPTION
  
  The C<LWP::ConnCache> class is the standard connection cache manager
  for LWP::UserAgent.
  
  The following basic methods are provided:
  
  =over
  
  =item $cache = LWP::ConnCache->new( %options )
  
  This method constructs a new C<LWP::ConnCache> object.  The only
  option currently accepted is 'total_capacity'.  If specified it
  initialize the total_capacity option.  It defaults to the value 1.
  
  =item $cache->total_capacity( [$num_connections] )
  
  Get/sets the number of connection that will be cached.  Connections
  will start to be dropped when this limit is reached.  If set to C<0>,
  then all connections are immediately dropped.  If set to C<undef>,
  then there is no limit.
  
  =item $cache->capacity($type, [$num_connections] )
  
  Get/set a limit for the number of connections of the specified type
  that can be cached.  The $type will typically be a short string like
  "http" or "ftp".
  
  =item $cache->drop( [$checker, [$reason]] )
  
  Drop connections by some criteria.  The $checker argument is a
  subroutine that is called for each connection.  If the routine returns
  a TRUE value then the connection is dropped.  The routine is called
  with ($conn, $type, $key, $deposit_time) as arguments.
  
  Shortcuts: If the $checker argument is absent (or C<undef>) all cached
  connections are dropped.  If the $checker is a number then all
  connections untouched that the given number of seconds or more are
  dropped.  If $checker is a string then all connections of the given
  type are dropped.
  
  The $reason argument is passed on to the dropped() method.
  
  =item $cache->prune
  
  Calling this method will drop all connections that are dead.  This is
  tested by calling the ping() method on the connections.  If the ping()
  method exists and returns a FALSE value, then the connection is
  dropped.
  
  =item $cache->get_types
  
  This returns all the 'type' fields used for the currently cached
  connections.
  
  =item $cache->get_connections( [$type] )
  
  This returns all connection objects of the specified type.  If no type
  is specified then all connections are returned.  In scalar context the
  number of cached connections of the specified type is returned.
  
  =back
  
  
  The following methods are called by low-level protocol modules to
  try to save away connections and to get them back.
  
  =over
  
  =item $cache->deposit($type, $key, $conn)
  
  This method adds a new connection to the cache.  As a result other
  already cached connections might be dropped.  Multiple connections with
  the same $type/$key might added.
  
  =item $conn = $cache->withdraw($type, $key)
  
  This method tries to fetch back a connection that was previously
  deposited.  If no cached connection with the specified $type/$key is
  found, then C<undef> is returned.  There is not guarantee that a
  deposited connection can be withdrawn, as the cache manger is free to
  drop connections at any time.
  
  =back
  
  The following methods are called internally.  Subclasses might want to
  override them.
  
  =over
  
  =item $conn->enforce_limits([$type])
  
  This method is called with after a new connection is added (deposited)
  in the cache or capacity limits are adjusted.  The default
  implementation drops connections until the specified capacity limits
  are not exceeded.
  
  =item $conn->dropping($conn_record, $reason)
  
  This method is called when a connection is dropped.  The record
  belonging to the dropped connection is passed as the first argument
  and a string describing the reason for the drop is passed as the
  second argument.  The default implementation makes some noise if the
  $LWP::ConnCache::DEBUG variable is set and nothing more.
  
  =back
  
  =head1 SUBCLASSING
  
  For specialized cache policy it makes sense to subclass
  C<LWP::ConnCache> and perhaps override the deposit(), enforce_limits()
  and dropping() methods.
  
  The object itself is a hash.  Keys prefixed with C<cc_> are reserved
  for the base class.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_CONNCACHE

$fatpacked{"LWP/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUG';
  package LWP::Debug;  # legacy
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(level trace debug conns);
  
  use Carp ();
  
  my @levels = qw(trace debug conns);
  %current_level = ();
  
  
  sub import
  {
      my $pack = shift;
      my $callpkg = caller(0);
      my @symbols = ();
      my @levels = ();
      for (@_) {
  	if (/^[-+]/) {
  	    push(@levels, $_);
  	}
  	else {
  	    push(@symbols, $_);
  	}
      }
      Exporter::export($pack, $callpkg, @symbols);
      level(@levels);
  }
  
  
  sub level
  {
      for (@_) {
  	if ($_ eq '+') {              # all on
  	    # switch on all levels
  	    %current_level = map { $_ => 1 } @levels;
  	}
  	elsif ($_ eq '-') {           # all off
  	    %current_level = ();
  	}
  	elsif (/^([-+])(\w+)$/) {
  	    $current_level{$2} = $1 eq '+';
  	}
  	else {
  	    Carp::croak("Illegal level format $_");
  	}
      }
  }
  
  
  sub trace  { _log(@_) if $current_level{'trace'}; }
  sub debug  { _log(@_) if $current_level{'debug'}; }
  sub conns  { _log(@_) if $current_level{'conns'}; }
  
  
  sub _log
  {
      my $msg = shift;
      $msg .= "\n" unless $msg =~ /\n$/;  # ensure trailing "\n"
  
      my($package,$filename,$line,$sub) = caller(2);
      print STDERR "$sub: $msg";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Debug - deprecated
  
  =head1 DESCRIPTION
  
  LWP::Debug is used to provide tracing facilities, but these are not used
  by LWP any more.  The code in this module is kept around
  (undocumented) so that 3rd party code that happens to use the old
  interfaces continue to run.
  
  One useful feature that LWP::Debug provided (in an imprecise and
  troublesome way) was network traffic monitoring.  The following
  section provides some hints about recommended replacements.
  
  =head2 Network traffic monitoring
  
  The best way to monitor the network traffic that LWP generates is to
  use an external TCP monitoring program.  The Wireshark program
  (L<http://www.wireshark.org/>) is highly recommended for this.
  
  Another approach it to use a debugging HTTP proxy server and make
  LWP direct all its traffic via this one.  Call C<< $ua->proxy >> to
  set it up and then just use LWP as before.
  
  For less precise monitoring needs just setting up a few simple
  handlers might do.  The following example sets up handlers to dump the
  request and response objects that pass through LWP:
  
    use LWP::UserAgent;
    $ua = LWP::UserAgent->new;
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
  
    $ua->add_handler("request_send",  sub { shift->dump; return });
    $ua->add_handler("response_done", sub { shift->dump; return });
  
    $ua->get("http://www.example.com");
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
LWP_DEBUG

$fatpacked{"LWP/DebugFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUGFILE';
  package LWP::DebugFile;
  
  # legacy stub
  
  1;
LWP_DEBUGFILE

$fatpacked{"LWP/MemberMixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_MEMBERMIXIN';
  package LWP::MemberMixin;
  
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = shift if @_;
      return $old;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::MemberMixin - Member access mixin class
  
  =head1 SYNOPSIS
  
   package Foo;
   require LWP::MemberMixin;
   @ISA=qw(LWP::MemberMixin);
  
  =head1 DESCRIPTION
  
  A mixin class to get methods that provide easy access to member
  variables in the %$self.
  Ideally there should be better Perl language support for this.
  
  There is only one method provided:
  
  =over 4
  
  =item _elem($elem [, $val])
  
  Internal method to get/set the value of member variable
  C<$elem>. If C<$val> is present it is used as the new value
  for the member variable.  If it is not present the current
  value is not touched. In both cases the previous value of
  the member variable is returned.
  
  =back
LWP_MEMBERMIXIN

$fatpacked{"LWP/Protocol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL';
  package LWP::Protocol;
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.06";
  
  use strict;
  use Carp ();
  use HTTP::Status ();
  use HTTP::Response;
  
  my %ImplementedBy = (); # scheme => classname
  
  
  
  sub new
  {
      my($class, $scheme, $ua) = @_;
  
      my $self = bless {
  	scheme => $scheme,
  	ua => $ua,
  
  	# historical/redundant
          max_size => $ua->{max_size},
      }, $class;
  
      $self;
  }
  
  
  sub create
  {
      my($scheme, $ua) = @_;
      my $impclass = LWP::Protocol::implementor($scheme) or
  	Carp::croak("Protocol scheme '$scheme' is not supported");
  
      # hand-off to scheme specific implementation sub-class
      my $protocol = $impclass->new($scheme, $ua);
  
      return $protocol;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
  
      if ($impclass) {
  	$ImplementedBy{$scheme} = $impclass;
      }
      my $ic = $ImplementedBy{$scheme};
      return $ic if $ic;
  
      return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
      $scheme = $1; # untaint
      $scheme =~ s/[.+\-]/_/g;  # make it a legal module name
  
      # scheme not yet known, look for a 'use'd implementation
      $ic = "LWP::Protocol::$scheme";  # default location
      $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
  	# try to autoload it
  	eval "require $ic";
  	if ($@) {
  	    if ($@ =~ /Can't locate/) { #' #emacs get confused by '
  		$ic = '';
  	    }
  	    else {
  		die "$@\n";
  	    }
  	}
      }
      $ImplementedBy{$scheme} = $ic if $ic;
      $ic;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
  }
  
  
  # legacy
  sub timeout    { shift->_elem('timeout',    @_); }
  sub max_size   { shift->_elem('max_size',   @_); }
  
  
  sub collect
  {
      my ($self, $arg, $response, $collector) = @_;
      my $content;
      my($ua, $max_size) = @{$self}{qw(ua max_size)};
  
      eval {
  	local $\; # protect the print below from surprises
          if (!defined($arg) || !$response->is_success) {
              $response->{default_add_content} = 1;
          }
          elsif (!ref($arg) && length($arg)) {
              open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
  	    binmode($fh);
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
                      print $fh $_[3] or die "Can't write to '$arg': $!";
                      1;
                  },
              });
              push(@{$response->{handlers}{response_done}}, {
                  callback => sub {
  		    close($fh) or die "Can't write to '$arg': $!";
  		    undef($fh);
  		},
  	    });
          }
          elsif (ref($arg) eq 'CODE') {
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
  		    &$arg($_[3], $_[0], $self);
  		    1;
                  },
              });
          }
          else {
              die "Unexpected collect argument '$arg'";
          }
  
          $ua->run_handlers("response_header", $response);
  
          if (delete $response->{default_add_content}) {
              push(@{$response->{handlers}{response_data}}, {
  		callback => sub {
  		    $_[0]->add_content($_[3]);
  		    1;
  		},
  	    });
          }
  
  
          my $content_size = 0;
          my $length = $response->content_length;
          my %skip_h;
  
          while ($content = &$collector, length $$content) {
              for my $h ($ua->handlers("response_data", $response)) {
                  next if $skip_h{$h};
                  unless ($h->{callback}->($response, $ua, $h, $$content)) {
                      # XXX remove from $response->{handlers}{response_data} if present
                      $skip_h{$h}++;
                  }
              }
              $content_size += length($$content);
              $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
              if (defined($max_size) && $content_size > $max_size) {
                  $response->push_header("Client-Aborted", "max_size");
                  last;
              }
          }
      };
      my $err = $@;
      delete $response->{handlers}{response_data};
      delete $response->{handlers} unless %{$response->{handlers}};
      if ($err) {
          chomp($err);
          $response->push_header('X-Died' => $err);
          $response->push_header("Client-Aborted", "die");
          return $response;
      }
  
      return $response;
  }
  
  
  sub collect_once
  {
      my($self, $arg, $response) = @_;
      my $content = \ $_[3];
      my $first = 1;
      $self->collect($arg, $response, sub {
  	return $content if $first--;
  	return \ "";
      });
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::Protocol - Base class for LWP protocols
  
  =head1 SYNOPSIS
  
   package LWP::Protocol::foo;
   require LWP::Protocol;
   @ISA=qw(LWP::Protocol);
  
  =head1 DESCRIPTION
  
  This class is used a the base class for all protocol implementations
  supported by the LWP library.
  
  When creating an instance of this class using
  C<LWP::Protocol::create($url)>, and you get an initialized subclass
  appropriate for that access method. In other words, the
  LWP::Protocol::create() function calls the constructor for one of its
  subclasses.
  
  All derived LWP::Protocol classes need to override the request()
  method which is used to service a request. The overridden method can
  make use of the collect() function to collect together chunks of data
  as it is received.
  
  The following methods and functions are provided:
  
  =over 4
  
  =item $prot = LWP::Protocol->new()
  
  The LWP::Protocol constructor is inherited by subclasses. As this is a
  virtual base class this method should B<not> be called directly.
  
  =item $prot = LWP::Protocol::create($scheme)
  
  Create an object of the class implementing the protocol to handle the
  given scheme. This is a function, not a method. It is more an object
  factory than a constructor. This is the function user agents should
  use to access protocols.
  
  =item $class = LWP::Protocol::implementor($scheme, [$class])
  
  Get and/or set implementor class for a scheme.  Returns '' if the
  specified scheme is not supported.
  
  =item $prot->request(...)
  
   $response = $protocol->request($request, $proxy, undef);
   $response = $protocol->request($request, $proxy, '/tmp/sss');
   $response = $protocol->request($request, $proxy, \&callback, 1024);
  
  Dispatches a request over the protocol, and returns a response
  object. This method needs to be overridden in subclasses.  Refer to
  L<LWP::UserAgent> for description of the arguments.
  
  =item $prot->collect($arg, $response, $collector)
  
  Called to collect the content of a request, and process it
  appropriately into a scalar, file, or by calling a callback.  If $arg
  is undefined, then the content is stored within the $response.  If
  $arg is a simple scalar, then $arg is interpreted as a file name and
  the content is written to this file.  If $arg is a reference to a
  routine, then content is passed to this routine.
  
  The $collector is a routine that will be called and which is
  responsible for returning pieces (as ref to scalar) of the content to
  process.  The $collector signals EOF by returning a reference to an
  empty string.
  
  The return value from collect() is the $response object reference.
  
  B<Note:> We will only use the callback or file argument if
  $response->is_success().  This avoids sending content data for
  redirects and authentication responses to the callback which would be
  confusing.
  
  =item $prot->collect_once($arg, $response, $content)
  
  Can be called when the whole response content is available as
  $content.  This will invoke collect() with a collector callback that
  returns a reference to $content the first time and an empty string the
  next.
  
  =back
  
  =head1 SEE ALSO
  
  Inspect the F<LWP/Protocol/file.pm> and F<LWP/Protocol/http.pm> files
  for examples of usage.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_PROTOCOL

$fatpacked{"LWP/Protocol/GHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GHTTP';
  package LWP::Protocol::GHTTP;
  
  # You can tell LWP to use this module for 'http' requests by running
  # code like this before you make requests:
  #
  #    require LWP::Protocol::GHTTP;
  #    LWP::Protocol::implementor('http', 'LWP::Protocol::GHTTP');
  #
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA=qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  
  use HTTP::GHTTP qw(METHOD_GET METHOD_HEAD METHOD_POST);
  
  my %METHOD =
  (
   GET  => METHOD_GET,
   HEAD => METHOD_HEAD,
   POST => METHOD_POST,
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $method = $request->method;
      unless (exists $METHOD{$method}) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Bad method '$method'");
      }
  
      my $r = HTTP::GHTTP->new($request->uri);
  
      # XXX what headers for repeated headers here?
      $request->headers->scan(sub { $r->set_header(@_)});
  
      $r->set_type($METHOD{$method});
  
      # XXX should also deal with subroutine content.
      my $cref = $request->content_ref;
      $r->set_body($$cref) if length($$cref);
  
      # XXX is this right
      $r->set_proxy($proxy->as_string) if $proxy;
  
      $r->process_request;
  
      my $response = HTTP::Response->new($r->get_status);
  
      # XXX How can get the headers out of $r??  This way is too stupid.
      my @headers;
      eval {
  	# Wrapped in eval because this method is not always available
  	@headers = $r->get_headers;
      };
      @headers = qw(Date Connection Server Content-type
                    Accept-Ranges Server
                    Content-Length Last-Modified ETag) if $@;
      for (@headers) {
  	my $v = $r->get_header($_);
  	$response->header($_ => $v) if defined $v;
      }
  
      return $self->collect_once($arg, $response, $r->get_body);
  }
  
  1;
LWP_PROTOCOL_GHTTP

$fatpacked{"LWP/Protocol/cpan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_CPAN';
  package LWP::Protocol::cpan;
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require URI;
  require HTTP::Status;
  require HTTP::Response;
  
  our $CPAN;
  
  unless ($CPAN) {
      # Try to find local CPAN mirror via $CPAN::Config
      eval {
  	require CPAN::Config;
  	if($CPAN::Config) {
  	    my $urls = $CPAN::Config->{urllist};
  	    if (ref($urls) eq "ARRAY") {
  		my $file;
  		for (@$urls) {
  		    if (/^file:/) {
  			$file = $_;
  			last;
  		    }
  		}
  
  		if ($file) {
  		    $CPAN = $file;
  		}
  		else {
  		    $CPAN = $urls->[0];
  		}
  	    }
  	}
      };
  
      $CPAN ||= "http://cpan.org/";  # last resort
  }
  
  # ensure that we don't chop of last part
  $CPAN .= "/" unless $CPAN =~ m,/$,;
  
  
  sub request {
      my($self, $request, $proxy, $arg, $size) = @_;
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy with cpan');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'cpan:' URLs");
      }
  
      my $path = $request->uri->path;
      $path =~ s,^/,,;
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_FOUND);
      $response->header("Location" => URI->new_abs($path, $CPAN));
      $response;
  }
  
  1;
LWP_PROTOCOL_CPAN

$fatpacked{"LWP/Protocol/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_DATA';
  package LWP::Protocol::data;
  
  # Implements access to data:-URLs as specified in RFC 2397
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use HTTP::Date qw(time2str);
  require LWP;  # needs version number
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with data');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'data:' URLs");
      }
  
      my $url = $request->uri;
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK, "Document follows");
  
      my $media_type = $url->media_type;
  
      my $data = $url->data;
      $response->header('Content-Type'   => $media_type,
  		      'Content-Length' => length($data),
  		      'Date'           => time2str(time),
  		      'Server'         => "libwww-perl-internal/$LWP::VERSION"
  		     );
  
      $data = "" if $method eq "HEAD";
      return $self->collect_once($arg, $response, $data);
  }
  
  1;
LWP_PROTOCOL_DATA

$fatpacked{"LWP/Protocol/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FILE';
  package LWP::Protocol::file;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  
  require LWP::MediaTypes;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  require HTTP::Date;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      $size = 4096 unless defined $size and $size > 0;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy through the filesystem');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'file:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'file') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "LWP::Protocol::file::request called for '$scheme'");
      }
  
      # URL OK, look at file
      my $path  = $url->file;
  
      # test file exists and is readable
      unless (-e $path) {
  	return HTTP::Response->new( &HTTP::Status::RC_NOT_FOUND,
  				  "File `$path' does not exist");
      }
      unless (-r _) {
  	return HTTP::Response->new( &HTTP::Status::RC_FORBIDDEN,
  				  'User does not have read permission');
      }
  
      # looks like file exists
      my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$filesize,
         $atime,$mtime,$ctime,$blksize,$blocks)
  	    = stat(_);
  
      # XXX should check Accept headers?
  
      # check if-modified-since
      my $ims = $request->header('If-Modified-Since');
      if (defined $ims) {
  	my $time = HTTP::Date::str2time($ims);
  	if (defined $time and $time >= $mtime) {
  	    return HTTP::Response->new( &HTTP::Status::RC_NOT_MODIFIED,
  				      "$method $path");
  	}
      }
  
      # Ok, should be an OK response by now...
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK );
  
      # fill in response headers
      $response->header('Last-Modified', HTTP::Date::time2str($mtime));
  
      if (-d _) {         # If the path is a directory, process it
  	# generate the HTML for directory
  	opendir(D, $path) or
  	   return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				     "Cannot read directory '$path': $!");
  	my(@files) = sort readdir(D);
  	closedir(D);
  
  	# Make directory listing
  	require URI::Escape;
  	require HTML::Entities;
          my $pathe = $path . ( $^O eq 'MacOS' ? ':' : '/');
  	for (@files) {
  	    my $furl = URI::Escape::uri_escape($_);
              if ( -d "$pathe$_" ) {
                  $furl .= '/';
                  $_ .= '/';
              }
  	    my $desc = HTML::Entities::encode($_);
  	    $_ = qq{<LI><A HREF="$furl">$desc</A>};
  	}
  	# Ensure that the base URL is "/" terminated
  	my $base = $url->clone;
  	unless ($base->path =~ m|/$|) {
  	    $base->path($base->path . "/");
  	}
  	my $html = join("\n",
  			"<HTML>\n<HEAD>",
  			"<TITLE>Directory $path</TITLE>",
  			"<BASE HREF=\"$base\">",
  			"</HEAD>\n<BODY>",
  			"<H1>Directory listing of $path</H1>",
  			"<UL>", @files, "</UL>",
  			"</BODY>\n</HTML>\n");
  
  	$response->header('Content-Type',   'text/html');
  	$response->header('Content-Length', length $html);
  	$html = "" if $method eq "HEAD";
  
  	return $self->collect_once($arg, $response, $html);
  
      }
  
      # path is a regular file
      $response->header('Content-Length', $filesize);
      LWP::MediaTypes::guess_media_type($path, $response);
  
      # read the file
      if ($method ne "HEAD") {
  	open(F, $path) or return new
  	    HTTP::Response(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "Cannot read file '$path': $!");
  	binmode(F);
  	$response =  $self->collect($arg, $response, sub {
  	    my $content = "";
  	    my $bytes = sysread(F, $content, $size);
  	    return \$content if $bytes > 0;
  	    return \ "";
  	});
  	close(F);
      }
  
      $response;
  }
  
  1;
LWP_PROTOCOL_FILE

$fatpacked{"LWP/Protocol/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FTP';
  package LWP::Protocol::ftp;
  
  # Implementation of the ftp protocol (RFC 959). We let the Net::FTP
  # package do all the dirty work.
  
  use Carp ();
  
  use HTTP::Status ();
  use HTTP::Negotiate ();
  use HTTP::Response ();
  use LWP::MediaTypes ();
  use File::Listing ();
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  eval {
      package LWP::Protocol::MyFTP;
  
      require Net::FTP;
      Net::FTP->require_version(2.00);
  
      use vars qw(@ISA);
      @ISA=qw(Net::FTP);
  
      sub new {
  	my $class = shift;
  
  	my $self = $class->SUPER::new(@_) || return undef;
  
  	my $mess = $self->message;  # welcome message
  	$mess =~ s|\n.*||s; # only first line left
  	$mess =~ s|\s*ready\.?$||;
  	# Make the version number more HTTP like
  	$mess =~ s|\s*\(Version\s*|/| and $mess =~ s|\)$||;
  	${*$self}{myftp_server} = $mess;
  	#$response->header("Server", $mess);
  
  	$self;
      }
  
      sub http_server {
  	my $self = shift;
  	${*$self}{myftp_server};
      }
  
      sub home {
  	my $self = shift;
  	my $old = ${*$self}{myftp_home};
  	if (@_) {
  	    ${*$self}{myftp_home} = shift;
  	}
  	$old;
      }
  
      sub go_home {
  	my $self = shift;
  	$self->cwd(${*$self}{myftp_home});
      }
  
      sub request_count {
  	my $self = shift;
  	++${*$self}{myftp_reqcount};
      }
  
      sub ping {
  	my $self = shift;
  	return $self->go_home;
      }
  
  };
  my $init_failed = $@;
  
  
  sub _connect {
      my($self, $host, $port, $user, $account, $password, $timeout) = @_;
  
      my $key;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	$key = "$host:$port:$user";
  	$key .= ":$account" if defined($account);
  	if (my $ftp = $conn_cache->withdraw("ftp", $key)) {
  	    if ($ftp->ping) {
  		# save it again
  		$conn_cache->deposit("ftp", $key, $ftp);
  		return $ftp;
  	    }
  	}
      }
  
      # try to make a connection
      my $ftp = LWP::Protocol::MyFTP->new($host,
  					Port => $port,
  					Timeout => $timeout,
  					LocalAddr => $self->{ua}{local_address},
  				       );
      # XXX Should be some what to pass on 'Passive' (header??)
      unless ($ftp) {
  	$@ =~ s/^Net::FTP: //;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR, $@);
      }
  
      unless ($ftp->login($user, $password, $account)) {
  	# Unauthorized.  Let's fake a RC_UNAUTHORIZED response
  	my $mess = scalar($ftp->message);
  	$mess =~ s/\n$//;
  	my $res =  HTTP::Response->new(&HTTP::Status::RC_UNAUTHORIZED, $mess);
  	$res->header("Server", $ftp->http_server);
  	$res->header("WWW-Authenticate", qq(Basic Realm="FTP login"));
  	return $res;
      }
  
      my $home = $ftp->pwd;
      $ftp->home($home);
  
      $conn_cache->deposit("ftp", $key, $ftp) if $conn_cache;
  
      return $ftp;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the ftp');
      }
  
      my $url = $request->uri;
      if ($url->scheme ne 'ftp') {
  	my $scheme = $url->scheme;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  		       "LWP::Protocol::ftp::request called for '$scheme'");
      }
  
      # check method
      my $method = $request->method;
  
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'PUT') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'ftp:' URLs");
      }
  
      if ($init_failed) {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   $init_failed);
      }
  
      my $host     = $url->host;
      my $port     = $url->port;
      my $user     = $url->user;
      my $password = $url->password;
  
      # If a basic authorization header is present than we prefer these over
      # the username/password specified in the URL.
      {
  	my($u,$p) = $request->authorization_basic;
  	if (defined $u) {
  	    $user = $u;
  	    $password = $p;
  	}
      }
  
      # We allow the account to be specified in the "Account" header
      my $account = $request->header('Account');
  
      my $ftp = $self->_connect($host, $port, $user, $account, $password, $timeout);
      return $ftp if ref($ftp) eq "HTTP::Response"; # ugh!
  
      # Create an initial response object
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header(Server => $ftp->http_server);
      $response->header('Client-Request-Num' => $ftp->request_count);
      $response->request($request);
  
      # Get & fix the path
      my @path =  grep { length } $url->path_segments;
      my $remote_file = pop(@path);
      $remote_file = '' unless defined $remote_file;
  
      my $type;
      if (ref $remote_file) {
  	my @params;
  	($remote_file, @params) = @$remote_file;
  	for (@params) {
  	    $type = $_ if s/^type=//;
  	}
      }
  
      if ($type && $type eq 'a') {
  	$ftp->ascii;
      }
      else {
  	$ftp->binary;
      }
  
      for (@path) {
  	unless ($ftp->cwd($_)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  				       "Can't chdir to $_");
  	}
      }
  
      if ($method eq 'GET' || $method eq 'HEAD') {
  	if (my $mod_time = $ftp->mdtm($remote_file)) {
  	    $response->last_modified($mod_time);
  	    if (my $ims = $request->if_modified_since) {
  		if ($mod_time <= $ims) {
  		    $response->code(&HTTP::Status::RC_NOT_MODIFIED);
  		    $response->message("Not modified");
  		    return $response;
  		}
  	    }
  	}
  
  	# We'll use this later to abort the transfer if necessary. 
  	# if $max_size is defined, we need to abort early. Otherwise, it's
        # a normal transfer
  	my $max_size = undef;
  
  	# Set resume location, if the client requested it
  	if ($request->header('Range') && $ftp->supported('REST'))
  	{
  		my $range_info = $request->header('Range');
  
  		# Change bytes=2772992-6781209 to just 2772992
  		my ($start_byte,$end_byte) = $range_info =~ /.*=\s*(\d+)-(\d+)?/;
  		if ( defined $start_byte && !defined $end_byte ) {
  
  		  # open range -- only the start is specified
  
  		  $ftp->restart( $start_byte );
  		  # don't define $max_size, we don't want to abort early
  		}
  		elsif ( defined $start_byte && defined $end_byte &&
  			$start_byte >= 0 && $end_byte >= $start_byte ) {
  
  		  $ftp->restart( $start_byte );
  		  $max_size = $end_byte - $start_byte;
  		}
  		else {
  
  		  return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  		     'Incorrect syntax for Range request');
  		}
  	}
  	elsif ($request->header('Range') && !$ftp->supported('REST'))
  	{
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  	         "Server does not support resume.");
  	}
  
  	my $data;  # the data handle
  	if (length($remote_file) and $data = $ftp->retr($remote_file)) {
  	    my($type, @enc) = LWP::MediaTypes::guess_media_type($remote_file);
  	    $response->header('Content-Type',   $type) if $type;
  	    for (@enc) {
  		$response->push_header('Content-Encoding', $_);
  	    }
  	    my $mess = $ftp->message;
  	    if ($mess =~ /\((\d+)\s+bytes\)/) {
  		$response->header('Content-Length', "$1");
  	    }
  
  	    if ($method ne 'HEAD') {
  		# Read data from server
  		$response = $self->collect($arg, $response, sub {
  		    my $content = '';
  		    my $result = $data->read($content, $size);
  
                      # Stop early if we need to.
                      if (defined $max_size)
                      {
                        # We need an interface to Net::FTP::dataconn for getting
                        # the number of bytes already read
                        my $bytes_received = $data->bytes_read();
  
                        # We were already over the limit. (Should only happen
                        # once at the end.)
                        if ($bytes_received - length($content) > $max_size)
                        {
                          $content = '';
                        }
                        # We just went over the limit
                        elsif ($bytes_received  > $max_size)
                        {
                          # Trim content
                          $content = substr($content, 0,
                            $max_size - ($bytes_received - length($content)) );
                        }
                        # We're under the limit
                        else
                        {
                        }
                      }
  
  		    return \$content;
  		} );
  	    }
  	    # abort is needed for HEAD, it's == close if the transfer has
  	    # already completed.
  	    unless ($data->abort) {
  		# Something did not work too well.  Note that we treat
  		# responses to abort() with code 0 in case of HEAD as ok
  		# (at least wu-ftpd 2.6.1(1) does that).
  		if ($method ne 'HEAD' || $ftp->code != 0) {
  		    $response->code(&HTTP::Status::RC_INTERNAL_SERVER_ERROR);
  		    $response->message("FTP close response: " . $ftp->code .
  				       " " . $ftp->message);
  		}
  	    }
  	}
  	elsif (!length($remote_file) || ( $ftp->code >= 400 && $ftp->code < 600 )) {
  	    # not a plain file, try to list instead
  	    if (length($remote_file) && !$ftp->cwd($remote_file)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  					   "File '$remote_file' not found");
  	    }
  
  	    # It should now be safe to try to list the directory
  	    my @lsl = $ftp->dir;
  
  	    # Try to figure out if the user want us to convert the
  	    # directory listing to HTML.
  	    my @variants =
  	      (
  	       ['html',  0.60, 'text/html'            ],
  	       ['dir',   1.00, 'text/ftp-dir-listing' ]
  	      );
  	    #$HTTP::Negotiate::DEBUG=1;
  	    my $prefer = HTTP::Negotiate::choose(\@variants, $request);
  
  	    my $content = '';
  
  	    if (!defined($prefer)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_ACCEPTABLE,
  			       "Neither HTML nor directory listing wanted");
  	    }
  	    elsif ($prefer eq 'html') {
  		$response->header('Content-Type' => 'text/html');
  		$content = "<HEAD><TITLE>File Listing</TITLE>\n";
  		my $base = $request->uri->clone;
  		my $path = $base->path;
  		$base->path("$path/") unless $path =~ m|/$|;
  		$content .= qq(<BASE HREF="$base">\n</HEAD>\n);
  		$content .= "<BODY>\n<UL>\n";
  		for (File::Listing::parse_dir(\@lsl, 'GMT')) {
  		    my($name, $type, $size, $mtime, $mode) = @$_;
  		    $content .= qq(  <LI> <a href="$name">$name</a>);
  		    $content .= " $size bytes" if $type eq 'f';
  		    $content .= "\n";
  		}
  		$content .= "</UL></body>\n";
  	    }
  	    else {
  		$response->header('Content-Type', 'text/ftp-dir-listing');
  		$content = join("\n", @lsl, '');
  	    }
  
  	    $response->header('Content-Length', length($content));
  
  	    if ($method ne 'HEAD') {
  		$response = $self->collect_once($arg, $response, $content);
  	    }
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  			  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      elsif ($method eq 'PUT') {
  	# method must be PUT
  	unless (length($remote_file)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				       "Must have a file name to PUT to");
  	}
  	my $data;
  	if ($data = $ftp->stor($remote_file)) {
  	    my $content = $request->content;
  	    my $bytes = 0;
  	    if (defined $content) {
  		if (ref($content) eq 'SCALAR') {
  		    $bytes = $data->write($$content, length($$content));
  		}
  		elsif (ref($content) eq 'CODE') {
  		    my($buf, $n);
  		    while (length($buf = &$content)) {
  			$n = $data->write($buf, length($buf));
  			last unless $n;
  			$bytes += $n;
  		    }
  		}
  		elsif (!ref($content)) {
  		    if (defined $content && length($content)) {
  			$bytes = $data->write($content, length($content));
  		    }
  		}
  		else {
  		    die "Bad content";
  		}
  	    }
  	    $data->close;
  
  	    $response->code(&HTTP::Status::RC_CREATED);
  	    $response->header('Content-Type', 'text/plain');
  	    $response->content("$bytes bytes stored as $remote_file on $host\n")
  
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  					  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      else {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Illegal method $method");
      }
  
      $response;
  }
  
  1;
  
  __END__
  
  # This is what RFC 1738 has to say about FTP access:
  # --------------------------------------------------
  #
  # 3.2. FTP
  #
  #    The FTP URL scheme is used to designate files and directories on
  #    Internet hosts accessible using the FTP protocol (RFC959).
  #
  #    A FTP URL follow the syntax described in Section 3.1.  If :<port> is
  #    omitted, the port defaults to 21.
  #
  # 3.2.1. FTP Name and Password
  #
  #    A user name and password may be supplied; they are used in the ftp
  #    "USER" and "PASS" commands after first making the connection to the
  #    FTP server.  If no user name or password is supplied and one is
  #    requested by the FTP server, the conventions for "anonymous" FTP are
  #    to be used, as follows:
  #
  #         The user name "anonymous" is supplied.
  #
  #         The password is supplied as the Internet e-mail address
  #         of the end user accessing the resource.
  #
  #    If the URL supplies a user name but no password, and the remote
  #    server requests a password, the program interpreting the FTP URL
  #    should request one from the user.
  #
  # 3.2.2. FTP url-path
  #
  #    The url-path of a FTP URL has the following syntax:
  #
  #         <cwd1>/<cwd2>/.../<cwdN>/<name>;type=<typecode>
  #
  #    Where <cwd1> through <cwdN> and <name> are (possibly encoded) strings
  #    and <typecode> is one of the characters "a", "i", or "d".  The part
  #    ";type=<typecode>" may be omitted. The <cwdx> and <name> parts may be
  #    empty. The whole url-path may be omitted, including the "/"
  #    delimiting it from the prefix containing user, password, host, and
  #    port.
  #
  #    The url-path is interpreted as a series of FTP commands as follows:
  #
  #       Each of the <cwd> elements is to be supplied, sequentially, as the
  #       argument to a CWD (change working directory) command.
  #
  #       If the typecode is "d", perform a NLST (name list) command with
  #       <name> as the argument, and interpret the results as a file
  #       directory listing.
  #
  #       Otherwise, perform a TYPE command with <typecode> as the argument,
  #       and then access the file whose name is <name> (for example, using
  #       the RETR command.)
  #
  #    Within a name or CWD component, the characters "/" and ";" are
  #    reserved and must be encoded. The components are decoded prior to
  #    their use in the FTP protocol.  In particular, if the appropriate FTP
  #    sequence to access a particular file requires supplying a string
  #    containing a "/" as an argument to a CWD or RETR command, it is
  #    necessary to encode each "/".
  #
  #    For example, the URL <URL:ftp://myname@host.dom/%2Fetc/motd> is
  #    interpreted by FTP-ing to "host.dom", logging in as "myname"
  #    (prompting for a password if it is asked for), and then executing
  #    "CWD /etc" and then "RETR motd". This has a different meaning from
  #    <URL:ftp://myname@host.dom/etc/motd> which would "CWD etc" and then
  #    "RETR motd"; the initial "CWD" might be executed relative to the
  #    default directory for "myname". On the other hand,
  #    <URL:ftp://myname@host.dom//etc/motd>, would "CWD " with a null
  #    argument, then "CWD etc", and then "RETR motd".
  #
  #    FTP URLs may also be used for other operations; for example, it is
  #    possible to update a file on a remote file server, or infer
  #    information about it from the directory listings. The mechanism for
  #    doing so is not spelled out here.
  #
  # 3.2.3. FTP Typecode is Optional
  #
  #    The entire ;type=<typecode> part of a FTP URL is optional. If it is
  #    omitted, the client program interpreting the URL must guess the
  #    appropriate mode to use. In general, the data content type of a file
  #    can only be guessed from the name, e.g., from the suffix of the name;
  #    the appropriate type code to be used for transfer of the file can
  #    then be deduced from the data content of the file.
  #
  # 3.2.4 Hierarchy
  #
  #    For some file systems, the "/" used to denote the hierarchical
  #    structure of the URL corresponds to the delimiter used to construct a
  #    file name hierarchy, and thus, the filename will look similar to the
  #    URL path. This does NOT mean that the URL is a Unix filename.
  #
  # 3.2.5. Optimization
  #
  #    Clients accessing resources via FTP may employ additional heuristics
  #    to optimize the interaction. For some FTP servers, for example, it
  #    may be reasonable to keep the control connection open while accessing
  #    multiple URLs from the same server. However, there is no common
  #    hierarchical model to the FTP protocol, so if a directory change
  #    command has been given, it is impossible in general to deduce what
  #    sequence should be given to navigate to another directory for a
  #    second retrieval, if the paths are different.  The only reliable
  #    algorithm is to disconnect and reestablish the control connection.
LWP_PROTOCOL_FTP

$fatpacked{"LWP/Protocol/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GOPHER';
  package LWP::Protocol::gopher;
  
  # Implementation of the gopher protocol (RFC 1436)
  #
  # This code is based on 'wwwgopher.pl,v 0.10 1994/10/17 18:12:34 shelden'
  # which in turn is a vastly modified version of Oscar's http'get()
  # dated 28/3/94 in <ftp://cui.unige.ch/PUBLIC/oscar/scripts/http.pl>
  # including contributions from Marc van Heyningen and Martijn Koster.
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  
  my %gopher2mimetype = (
      '0' => 'text/plain',                # 0 file
      '1' => 'text/html',                 # 1 menu
  					# 2 CSO phone-book server
  					# 3 Error
      '4' => 'application/mac-binhex40',  # 4 BinHexed Macintosh file
      '5' => 'application/zip',           # 5 DOS binary archive of some sort
      '6' => 'application/octet-stream',  # 6 UNIX uuencoded file.
      '7' => 'text/html',                 # 7 Index-Search server
  					# 8 telnet session
      '9' => 'application/octet-stream',  # 9 binary file
      'h' => 'text/html',                 # html
      'g' => 'image/gif',                 # gif
      'I' => 'image/*',                   # some kind of image
  );
  
  my %gopher2encoding = (
      '6' => 'x_uuencode',                # 6 UNIX uuencoded file.
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the gopher');
      }
  
      my $url = $request->uri;
      die "bad scheme" if $url->scheme ne 'gopher';
  
  
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'gopher:' URLs");
      }
  
      my $gophertype = $url->gopher_type;
      unless (exists $gopher2mimetype{$gophertype}) {
  	return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  				   'Library does not support gophertype ' .
  				   $gophertype);
      }
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header('Content-type' => $gopher2mimetype{$gophertype}
  					|| 'text/plain');
      $response->header('Content-Encoding' => $gopher2encoding{$gophertype})
  	if exists $gopher2encoding{$gophertype};
  
      if ($method eq 'HEAD') {
  	# XXX: don't even try it so we set this header
  	$response->header('Client-Warning' => 'Client answer only');
  	return $response;
      }
      
      if ($gophertype eq '7' && ! $url->search) {
        # the url is the prompt for a gopher search; supply boiler-plate
        return $self->collect_once($arg, $response, <<"EOT");
  <HEAD>
  <TITLE>Gopher Index</TITLE>
  <ISINDEX>
  </HEAD>
  <BODY>
  <H1>$url<BR>Gopher Search</H1>
  This is a searchable Gopher index.
  Use the search function of your browser to enter search terms.
  </BODY>
  EOT
      }
  
      my $host = $url->host;
      my $port = $url->port;
  
      my $requestLine = "";
  
      my $selector = $url->selector;
      if (defined $selector) {
  	$requestLine .= $selector;
  	my $search = $url->search;
  	if (defined $search) {
  	    $requestLine .= "\t$search";
  	    my $string = $url->string;
  	    if (defined $string) {
  		$requestLine .= "\t$string";
  	    }
  	}
      }
      $requestLine .= "\015\012";
  
      # potential request headers are just ignored
  
      # Ok, lets make the request
      my $socket = IO::Socket::INET->new(PeerAddr => $host,
  				       PeerPort => $port,
  				       LocalAddr => $self->{ua}{local_address},
  				       Proto    => 'tcp',
  				       Timeout  => $timeout);
      die "Can't connect to $host:$port" unless $socket;
      my $sel = IO::Select->new($socket);
  
      {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	my $n = syswrite($socket, $requestLine, length($requestLine));
  	die $! unless defined($n);
  	die "short write" if $n != length($requestLine);
      }
  
      my $user_arg = $arg;
  
      # must handle menus in a special way since they are to be
      # converted to HTML.  Undefing $arg ensures that the user does
      # not see the data before we get a change to convert it.
      $arg = undef if $gophertype eq '1' || $gophertype eq '7';
  
      # collect response
      my $buf = '';
      $response = $self->collect($arg, $response, sub {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
          my $n = sysread($socket, $buf, $size);
  	die $! unless defined($n);
  	return \$buf;
        } );
  
      # Convert menu to HTML and return data to user.
      if ($gophertype eq '1' || $gophertype eq '7') {
  	my $content = menu2html($response->content);
  	if (defined $user_arg) {
  	    $response = $self->collect_once($user_arg, $response, $content);
  	}
  	else {
  	    $response->content($content);
  	}
      }
  
      $response;
  }
  
  
  sub gopher2url
  {
      my($gophertype, $path, $host, $port) = @_;
  
      my $url;
  
      if ($gophertype eq '8' || $gophertype eq 'T') {
  	# telnet session
  	$url = $HTTP::URI_CLASS->new($gophertype eq '8' ? 'telnet:':'tn3270:');
  	$url->user($path) if defined $path;
      }
      else {
  	$path = URI::Escape::uri_escape($path);
  	$url = $HTTP::URI_CLASS->new("gopher:/$gophertype$path");
      }
      $url->host($host);
      $url->port($port);
      $url;
  }
  
  sub menu2html {
      my($menu) = @_;
  
      $menu =~ s/\015//g;  # remove carriage return
      my $tmp = <<"EOT";
  <HTML>
  <HEAD>
     <TITLE>Gopher menu</TITLE>
  </HEAD>
  <BODY>
  <H1>Gopher menu</H1>
  EOT
      for (split("\n", $menu)) {
  	last if /^\./;
  	my($pretty, $path, $host, $port) = split("\t");
  
  	$pretty =~ s/^(.)//;
  	my $type = $1;
  
  	my $url = gopher2url($type, $path, $host, $port)->as_string;
  	$tmp .= qq{<A HREF="$url">$pretty</A><BR>\n};
      }
      $tmp .= "</BODY>\n</HTML>\n";
      $tmp;
  }
  
  1;
LWP_PROTOCOL_GOPHER

$fatpacked{"LWP/Protocol/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_HTTP';
  package LWP::Protocol::http;
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::HTTP;
  
  use vars qw(@ISA @EXTRA_SOCK_OPTS);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  my $CRLF = "\015\012";
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
  
      # IPv6 literal IP address should be [bracketed] to remove
      # ambiguity between ip address and port number.
      # Extra cautious to ensure that $host is _just_ an IPv6 address
      # (at least as best as we can tell).
      if ( ($host =~ /:/) && ($host =~ /^[0-9a-f:.]+$/i) ) {
        $host = "[$host]";
      }
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $self->socket_class->new(PeerAddr => $host,
  					PeerPort => $port,
  					LocalAddr => $self->{ua}{local_address},
  					Proto    => 'tcp',
  					Timeout  => $timeout,
  					KeepAlive => !!$self->{ua}{conn_cache},
  					SendTE    => 1,
  					$self->_extra_sock_opts($host, $port),
  				       );
  
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	my $status = "Can't connect to $host:$port";
  	if ($@ =~ /\bconnect: (.*)/ ||
  	    $@ =~ /\b(Bad hostname)\b/ ||
  	    $@ =~ /\b(certificate verify failed)\b/ ||
  	    $@ =~ /\b(Crypt-SSLeay can't verify hostnames)\b/
  	) {
  	    $status .= " ($1)";
  	}
  	die "$status\n\n$@";
      }
  
      # perl 5.005's IO::Socket does not have the blocking method.
      eval { $sock->blocking(0); };
  
      $sock;
  }
  
  sub socket_type
  {
      return "http";
  }
  
  sub socket_class
  {
      my $self = shift;
      (ref($self) || $self) . "::Socket";
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
          $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      # Extract 'Host' header
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy && $url->scheme ne 'https') {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port".
  	# For https only the initial CONNECT requests needs authorization.
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  sub hlist_remove {
      my($hlist, $k) = @_;
      $k = lc $k;
      for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
  	next unless lc($hlist->[$i]) eq $k;
  	splice(@$hlist, $i, 2);
      }
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
  
      # Proxying SSL with a http proxy needs issues a CONNECT request to build a
      # tunnel and then upgrades the tunnel to SSL. But when doing keep-alive the
      # https request does not need to be the first request in the connection, so
      # we need to distinguish between
      # - not yet connected (create socket and ssl upgrade)
      # - connected but not inside ssl tunnel (ssl upgrade)
      # - inside ssl tunnel to the target - once we are in the tunnel to the
      #   target we cannot only reuse the tunnel for more https requests with the
      #   same target
  
      my $ssl_tunnel = $proxy && $url->scheme eq 'https'
  	&& $url->host.":".$url->port;
  
      my ($host,$port) = $proxy
  	? ($proxy->host,$proxy->port)
  	: ($url->host,$url->port);
      my $fullpath =
  	$method eq 'CONNECT' ? $url->host . ":" . $url->port :
  	$proxy && ! $ssl_tunnel ? $url->as_string :
  	do {
  	    my $path = $url->path_query;
  	    $path = "/$path" if $path !~m{^/};
  	    $path
  	};
  
      my $socket;
      my $conn_cache = $self->{ua}{conn_cache};
      my $cache_key;
      if ( $conn_cache ) {
  	$cache_key = "$host:$port";
  	# For https we reuse the socket immediatly only if it has an established
  	# tunnel to the target. Otherwise a CONNECT request followed by an SSL
  	# upgrade need to be done first. The request itself might reuse an
  	# existing non-ssl connection to the proxy
  	$cache_key .= "!".$ssl_tunnel if $ssl_tunnel;
  	if ( $socket = $conn_cache->withdraw($self->socket_type,$cache_key)) {
  	    if ($socket->can_read(0)) {
  		# if the socket is readable, then either the peer has closed the
  		# connection or there are some garbage bytes on it.  In either
  		# case we abandon it.
  		$socket->close;
  		$socket = undef;
  	    } # else use $socket
  	}
      }
  
      if ( ! $socket && $ssl_tunnel ) {
  	my $proto_https = LWP::Protocol::create('https',$self->{ua})
  	    or die "no support for scheme https found";
  
  	# only if ssl socket class is IO::Socket::SSL we can upgrade
  	# a plain socket to SSL. In case of Net::SSL we fall back to
  	# the old version
  	if ( my $upgrade_sub = $proto_https->can('_upgrade_sock')) {
  	    my $response = $self->request(
  		HTTP::Request->new('CONNECT',"http://$ssl_tunnel"),
  		$proxy,
  		undef,$size,$timeout
  	    );
  	    $response->is_success or die
  		"establishing SSL tunnel failed: ".$response->status_line;
  	    $socket = $upgrade_sub->($proto_https,
  		$response->{client_socket},$url)
  		or die "SSL upgrade failed: $@";
  	} else {
  	    $socket = $proto_https->_new_socket($url->host,$url->port,$timeout);
  	}
      }
  
      if ( ! $socket ) {
  	# connect to remote site w/o reusing established socket
  	$socket = $self->_new_socket($host, $port, $timeout );
      }
  
      my $http_version = "";
      if (my $proto = $request->protocol) {
  	if ($proto =~ /^(?:HTTP\/)?(1.\d+)$/) {
  	    $http_version = $1;
  	    $socket->http_version($http_version);
  	    $socket->send_te(0) if $http_version eq "1.0";
  	}
      }
  
      $self->_check_sock($request, $socket);
  
      my @h;
      my $request_headers = $request->headers->clone;
      $self->_fixup_header($request_headers, $url, $proxy);
  
      $request_headers->scan(sub {
  			       my($k, $v) = @_;
  			       $k =~ s/^://;
  			       $v =~ s/\n/ /g;
  			       push(@h, $k, $v);
  			   });
  
      my $content_ref = $request->content_ref;
      $content_ref = $$content_ref if ref($$content_ref);
      my $chunked;
      my $has_content;
  
      if (ref($content_ref) eq 'CODE') {
  	my $clen = $request_headers->header('Content-Length');
  	$has_content++ if $clen;
  	unless (defined $clen) {
  	    push(@h, "Transfer-Encoding" => "chunked");
  	    $has_content++;
  	    $chunked++;
  	}
      }
      else {
  	# Set (or override) Content-Length header
  	my $clen = $request_headers->header('Content-Length');
  	if (defined($$content_ref) && length($$content_ref)) {
  	    $has_content = length($$content_ref);
  	    if (!defined($clen) || $clen ne $has_content) {
  		if (defined $clen) {
  		    warn "Content-Length header value was wrong, fixed";
  		    hlist_remove(\@h, 'Content-Length');
  		}
  		push(@h, 'Content-Length' => $has_content);
  	    }
  	}
  	elsif ($clen) {
  	    warn "Content-Length set when there is no content, fixed";
  	    hlist_remove(\@h, 'Content-Length');
  	}
      }
  
      my $write_wait = 0;
      $write_wait = 2
  	if ($request_headers->header("Expect") || "") =~ /100-continue/;
  
      my $req_buf = $socket->format_request($method, $fullpath, @h);
      #print "------\n$req_buf\n------\n";
  
      if (!$has_content || $write_wait || $has_content > 8*1024) {
        WRITE:
          {
              # Since this just writes out the header block it should almost
              # always succeed to send the whole buffer in a single write call.
              my $n = $socket->syswrite($req_buf, length($req_buf));
              unless (defined $n) {
                  redo WRITE if $!{EINTR};
                  if ($!{EAGAIN}) {
                      select(undef, undef, undef, 0.1);
                      redo WRITE;
                  }
                  die "write failed: $!";
              }
              if ($n) {
                  substr($req_buf, 0, $n, "");
              }
              else {
                  select(undef, undef, undef, 0.5);
              }
              redo WRITE if length $req_buf;
          }
      }
  
      my($code, $mess, @junk);
      my $drop_connection;
  
      if ($has_content) {
  	my $eof;
  	my $wbuf;
  	my $woffset = 0;
        INITIAL_READ:
  	if ($write_wait) {
  	    # skip filling $wbuf when waiting for 100-continue
  	    # because if the response is a redirect or auth required
  	    # the request will be cloned and there is no way
  	    # to reset the input stream
  	    # return here via the label after the 100-continue is read
  	}
  	elsif (ref($content_ref) eq 'CODE') {
  	    my $buf = &$content_ref();
  	    $buf = "" unless defined($buf);
  	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  		if $chunked;
  	    substr($buf, 0, 0) = $req_buf if $req_buf;
  	    $wbuf = \$buf;
  	}
  	else {
  	    if ($req_buf) {
  		my $buf = $req_buf . $$content_ref;
  		$wbuf = \$buf;
  	    }
  	    else {
  		$wbuf = $content_ref;
  	    }
  	    $eof = 1;
  	}
  
  	my $fbits = '';
  	vec($fbits, fileno($socket), 1) = 1;
  
        WRITE:
  	while ($write_wait || $woffset < length($$wbuf)) {
  
  	    my $sel_timeout = $timeout;
  	    if ($write_wait) {
  		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
  	    }
  	    my $time_before;
              $time_before = time if $sel_timeout;
  
  	    my $rbits = $fbits;
  	    my $wbits = $write_wait ? undef : $fbits;
              my $sel_timeout_before = $sel_timeout;
            SELECT:
              {
                  my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                  if ($nfound < 0) {
                      if ($!{EINTR} || $!{EAGAIN}) {
                          if ($time_before) {
                              $sel_timeout = $sel_timeout_before - (time - $time_before);
                              $sel_timeout = 0 if $sel_timeout < 0;
                          }
                          redo SELECT;
                      }
                      die "select failed: $!";
                  }
  	    }
  
  	    if ($write_wait) {
  		$write_wait -= time - $time_before;
  		$write_wait = 0 if $write_wait < 0;
  	    }
  
  	    if (defined($rbits) && $rbits =~ /[^\0]/) {
  		# readable
  		my $buf = $socket->_rbuf;
  		my $n = $socket->sysread($buf, 1024, length($buf));
                  unless (defined $n) {
                      die "read failed: $!" unless  $!{EINTR} || $!{EAGAIN};
                      # if we get here the rest of the block will do nothing
                      # and we will retry the read on the next round
                  }
  		elsif ($n == 0) {
                      # the server closed the connection before we finished
                      # writing all the request content.  No need to write any more.
                      $drop_connection++;
                      last WRITE;
  		}
  		$socket->_rbuf($buf);
  		if (!$code && $buf =~ /\015?\012\015?\012/) {
  		    # a whole response header is present, so we can read it without blocking
  		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
  									junk_out => \@junk,
  								       );
  		    if ($code eq "100") {
  			$write_wait = 0;
  			undef($code);
  			goto INITIAL_READ;
  		    }
  		    else {
  			$drop_connection++;
  			last WRITE;
  			# XXX should perhaps try to abort write in a nice way too
  		    }
  		}
  	    }
  	    if (defined($wbits) && $wbits =~ /[^\0]/) {
  		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                  unless (defined $n) {
                      die "write failed: $!" unless $!{EINTR} || $!{EAGAIN};
                      $n = 0;  # will retry write on the next round
                  }
                  elsif ($n == 0) {
  		    die "write failed: no bytes written";
  		}
  		$woffset += $n;
  
  		if (!$eof && $woffset >= length($$wbuf)) {
  		    # need to refill buffer from $content_ref code
  		    my $buf = &$content_ref();
  		    $buf = "" unless defined($buf);
  		    $eof++ unless length($buf);
  		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  			if $chunked;
  		    $wbuf = \$buf;
  		    $woffset = 0;
  		}
  	    }
  	} # WRITE
      }
  
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	unless $code;
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	if $code eq "100";
  
      my $response = HTTP::Response->new($code, $mess);
      my $peer_http_version = $socket->peer_http_version;
      $response->protocol("HTTP/$peer_http_version");
      {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
      $response->push_header("Client-Junk" => \@junk) if @junk;
  
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	return $response;
      }
  
      if (my @te = $response->remove_header('Transfer-Encoding')) {
  	$response->push_header('Client-Transfer-Encoding', \@te);
      }
      $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);
  
      my $complete;
      $response = $self->collect($arg, $response, sub {
  	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
  	my $n;
        READ:
  	{
  	    $n = $socket->read_entity_body($buf, $size);
              unless (defined $n) {
                  redo READ if $!{EINTR} || $!{EAGAIN} || $!{ENOTTY};
                  die "read failed: $!";
              }
  	    redo READ if $n == -1;
  	}
  	$complete++ if !$n;
          return \$buf;
      } );
      $drop_connection++ unless $complete;
  
      @h = $socket->get_trailers;
      if (@h) {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
  
      # keep-alive support
      unless ($drop_connection) {
  	if ($cache_key) {
  	    my %connection = map { (lc($_) => 1) }
  		             split(/\s*,\s*/, ($response->header("Connection") || ""));
  	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
  		$connection{"keep-alive"})
  	    {
  		$conn_cache->deposit($self->socket_type, $cache_key, $socket);
  	    }
  	}
      }
  
      $response;
  }
  
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::SocketMethods;
  
  sub ping {
      my $self = shift;
      !$self->can_read(0);
  }
  
  sub increment_response_count {
      my $self = shift;
      return ++${*$self}{'myhttp_response_count'};
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::Socket;
  use vars qw(@ISA);
  @ISA = qw(LWP::Protocol::http::SocketMethods Net::HTTP);
  
  1;
LWP_PROTOCOL_HTTP

$fatpacked{"LWP/Protocol/loopback.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_LOOPBACK';
  package LWP::Protocol::loopback;
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $response = HTTP::Response->new(200, "OK");
      $response->content_type("message/http; msgtype=request");
  
      $response->header("Via", "loopback/1.0 $proxy")
  	if $proxy;
  
      $response->header("X-Arg", $arg);
      $response->header("X-Read-Size", $size);
      $response->header("X-Timeout", $timeout);
  
      return $self->collect_once($arg, $response, $request->as_string);
  }
  
  1;
LWP_PROTOCOL_LOOPBACK

$fatpacked{"LWP/Protocol/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_MAILTO';
  package LWP::Protocol::mailto;
  
  # This module implements the mailto protocol.  It is just a simple
  # frontend to the Unix sendmail program except on MacOS, where it uses
  # Mail::Internet.
  
  require LWP::Protocol;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  
  use Carp;
  use strict;
  use vars qw(@ISA $SENDMAIL);
  
  @ISA = qw(LWP::Protocol);
  
  unless ($SENDMAIL = $ENV{SENDMAIL}) {
      for my $sm (qw(/usr/sbin/sendmail
  		   /usr/lib/sendmail
  		   /usr/ucblib/sendmail
  		  ))
      {
  	if (-x $sm) {
  	    $SENDMAIL = $sm;
  	    last;
  	}
      }
      die "Can't find the 'sendmail' program" unless $SENDMAIL;
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      my ($mail, $addr) if $^O eq "MacOS";
      my @text = () if $^O eq "MacOS";
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with mail');
      }
  
      # check method
      my $method = $request->method;
  
      if ($method ne 'POST') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'mailto:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'mailto') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			 "LWP::Protocol::mailto::request called for '$scheme'");
      }
      if ($^O eq "MacOS") {
  	eval {
  	    require Mail::Internet;
  	};
  	if($@) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have MailTools installed");
  	}
  	unless ($ENV{SMTPHOSTS}) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have SMTPHOSTS defined");
  	}
      }
      else {
  	unless (-x $SENDMAIL) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have $SENDMAIL");
      }
      }
      if ($^O eq "MacOS") {
  	    $mail = Mail::Internet->new or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	    "Can't get a Mail::Internet object");
      }
      else {
  	open(SENDMAIL, "| $SENDMAIL -oi -t") or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "Can't run $SENDMAIL: $!");
      }
      if ($^O eq "MacOS") {
  	$addr = $url->encoded822addr;
      }
      else {
  	$request = $request->clone;  # we modify a copy
  	my @h = $url->headers;  # URL headers override those in the request
  	while (@h) {
  	    my $k = shift @h;
  	    my $v = shift @h;
  	    next unless defined $v;
  	    if (lc($k) eq "body") {
  		$request->content($v);
  	    }
  	    else {
  		$request->push_header($k => $v);
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->add(To => $addr);
  	$mail->add(split(/[:\n]/,$request->headers_as_string));
      }
      else {
  	print SENDMAIL $request->headers_as_string;
  	print SENDMAIL "\n";
      }
      my $content = $request->content;
      if (defined $content) {
  	my $contRef = ref($content) ? $content : \$content;
  	if (ref($contRef) eq 'SCALAR') {
  	    if ($^O eq "MacOS") {
  		@text = split("\n",$$contRef);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  	    print SENDMAIL $$contRef;
  	    }
  
  	}
  	elsif (ref($contRef) eq 'CODE') {
  	    # Callback provides data
  	    my $d;
  	    if ($^O eq "MacOS") {
  		my $stuff = "";
  		while (length($d = &$contRef)) {
  		    $stuff .= $d;
  		}
  		@text = split("\n",$stuff);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  		print SENDMAIL $d;
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->body(\@text);
  	unless ($mail->smtpsend) {
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "Mail::Internet->smtpsend unable to send message to <$addr>");
  	}
      }
      else {
  	unless (close(SENDMAIL)) {
  	    my $err = $! ? "$!" : "Exit status $?";
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "$SENDMAIL: $err");
  	}
      }
  
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_ACCEPTED,
  				       "Mail accepted");
      $response->header('Content-Type', 'text/plain');
      if ($^O eq "MacOS") {
  	$response->header('Server' => "Mail::Internet $Mail::Internet::VERSION");
  	$response->content("Message sent to <$addr>\n");
      }
      else {
  	$response->header('Server' => $SENDMAIL);
  	my $to = $request->header("To");
  	$response->content("Message sent to <$to>\n");
      }
  
      return $response;
  }
  
  1;
LWP_PROTOCOL_MAILTO

$fatpacked{"LWP/Protocol/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NNTP';
  package LWP::Protocol::nntp;
  
  # Implementation of the Network News Transfer Protocol (RFC 977)
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::NNTP;
  
  use strict;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # Check for proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through NNTP');
      }
  
      # Check that the scheme is as expected
      my $url = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme eq 'news' || $scheme eq 'nntp') {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   "LWP::Protocol::nntp::request called for '$scheme'");
      }
  
      # check for a valid method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for '$scheme:' URLs");
      }
  
      # extract the identifier and check against posting to an article
      my $groupart = $url->_group;
      my $is_art = $groupart =~ /@/;
  
      if ($is_art && $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Can't post to an article <$groupart>");
      }
  
      my $nntp = Net::NNTP->new($url->host,
  			      #Port    => 18574,
  			      Timeout => $timeout,
  			      #Debug   => 1,
  			     );
      die "Can't connect to nntp server" unless $nntp;
  
      # Check the initial welcome message from the NNTP server
      if ($nntp->status != 2) {
  	return HTTP::Response->new(&HTTP::Status::RC_SERVICE_UNAVAILABLE,
  				   $nntp->message);
      }
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
  
      my $mess = $nntp->message;
  
      # Try to extract server name from greeting message.
      # Don't know if this works well for a large class of servers, but
      # this works for our server.
      $mess =~ s/\s+ready\b.*//;
      $mess =~ s/^\S+\s+//;
      $response->header(Server => $mess);
  
      # First we handle posting of articles
      if ($method eq 'POST') {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	$response->message("POST not implemented yet");
  	return $response;
      }
  
      # The method must be "GET" or "HEAD" by now
      if (!$is_art) {
  	if (!$nntp->group($groupart)) {
  	    $response->code(&HTTP::Status::RC_NOT_FOUND);
  	    $response->message($nntp->message);
  	}
  	$nntp->quit; $nntp = undef;
  	# HEAD: just check if the group exists
  	if ($method eq 'GET' && $response->is_success) {
  	    $response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	    $response->message("GET newsgroup not implemented yet");
  	}
  	return $response;
      }
  
      # Send command to server to retrieve an article (or just the headers)
      my $get = $method eq 'HEAD' ? "head" : "article";
      my $art = $nntp->$get("<$groupart>");
      unless ($art) {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_FOUND);
  	$response->message($nntp->message);
  	return $response;
      }
  
      # Parse headers
      my($key, $val);
      local $_;
      while ($_ = shift @$art) {
  	if (/^\s+$/) {
  	    last;  # end of headers
  	}
  	elsif (/^(\S+):\s*(.*)/) {
  	    $response->push_header($key, $val) if $key;
  	    ($key, $val) = ($1, $2);
  	}
  	elsif (/^\s+(.*)/) {
  	    next unless $key;
  	    $val .= $1;
  	}
  	else {
  	    unshift(@$art, $_);
  	    last;
  	}
      }
      $response->push_header($key, $val) if $key;
  
      # Ensure that there is a Content-Type header
      $response->header("Content-Type", "text/plain")
  	unless $response->header("Content-Type");
  
      # Collect the body
      $response = $self->collect_once($arg, $response, join("", @$art))
        if @$art;
  
      # Say goodbye to the server
      $nntp->quit;
      $nntp = undef;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_NNTP

$fatpacked{"LWP/Protocol/nogo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NOGO';
  package LWP::Protocol::nogo;
  # If you want to disable access to a particular scheme, use this
  # class and then call
  #   LWP::Protocol::implementor(that_scheme, 'LWP::Protocol::nogo');
  # For then on, attempts to access URLs with that scheme will generate
  # a 500 error.
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  require HTTP::Status;
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request) = @_;
      my $scheme = $request->uri->scheme;
      
      return HTTP::Response->new(
        &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
        "Access to \'$scheme\' URIs has been disabled"
      );
  }
  1;
LWP_PROTOCOL_NOGO

$fatpacked{"LWP/RobotUA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_ROBOTUA';
  package LWP::RobotUA;
  
  require LWP::UserAgent;
  @ISA = qw(LWP::UserAgent);
  $VERSION = "6.06";
  
  require WWW::RobotRules;
  require HTTP::Request;
  require HTTP::Response;
  
  use Carp ();
  use HTTP::Status ();
  use HTTP::Date qw(time2str);
  use strict;
  
  
  #
  # Additional attributes in addition to those found in LWP::UserAgent:
  #
  # $self->{'delay'}    Required delay between request to the same
  #                     server in minutes.
  #
  # $self->{'rules'}     A WWW::RobotRules object
  #
  
  sub new
  {
      my $class = shift;
      my %cnf;
      if (@_ < 4) {
  	# legacy args
  	@cnf{qw(agent from rules)} = @_;
      }
      else {
  	%cnf = @_;
      }
  
      Carp::croak('LWP::RobotUA agent required') unless $cnf{agent};
      Carp::croak('LWP::RobotUA from address required')
  	unless $cnf{from} && $cnf{from} =~ m/\@/;
  
      my $delay = delete $cnf{delay} || 1;
      my $use_sleep = delete $cnf{use_sleep};
      $use_sleep = 1 unless defined($use_sleep);
      my $rules = delete $cnf{rules};
  
      my $self = LWP::UserAgent->new(%cnf);
      $self = bless $self, $class;
  
      $self->{'delay'} = $delay;   # minutes
      $self->{'use_sleep'} = $use_sleep;
  
      if ($rules) {
  	$rules->agent($cnf{agent});
  	$self->{'rules'} = $rules;
      }
      else {
  	$self->{'rules'} = WWW::RobotRules->new($cnf{agent});
      }
  
      $self;
  }
  
  
  sub delay     { shift->_elem('delay',     @_); }
  sub use_sleep { shift->_elem('use_sleep', @_); }
  
  
  sub agent
  {
      my $self = shift;
      my $old = $self->SUPER::agent(@_);
      if (@_) {
  	# Changing our name means to start fresh
  	$self->{'rules'}->agent($self->{'agent'}); 
      }
      $old;
  }
  
  
  sub rules {
      my $self = shift;
      my $old = $self->_elem('rules', @_);
      $self->{'rules'}->agent($self->{'agent'}) if @_;
      $old;
  }
  
  
  sub no_visits
  {
      my($self, $netloc) = @_;
      $self->{'rules'}->no_visits($netloc) || 0;
  }
  
  *host_count = \&no_visits;  # backwards compatibility with LWP-5.02
  
  
  sub host_wait
  {
      my($self, $netloc) = @_;
      return undef unless defined $netloc;
      my $last = $self->{'rules'}->last_visit($netloc);
      if ($last) {
  	my $wait = int($self->{'delay'} * 60 - (time - $last));
  	$wait = 0 if $wait < 0;
  	return $wait;
      }
      return 0;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # Do we try to access a new server?
      my $allowed = $self->{'rules'}->allowed($request->uri);
  
      if ($allowed < 0) {
  	# Host is not visited before, or robots.txt expired; fetch "robots.txt"
  	my $robot_url = $request->uri->clone;
  	$robot_url->path("robots.txt");
  	$robot_url->query(undef);
  
  	# make access to robot.txt legal since this will be a recursive call
  	$self->{'rules'}->parse($robot_url, ""); 
  
  	my $robot_req = HTTP::Request->new('GET', $robot_url);
  	my $parse_head = $self->parse_head(0);
  	my $robot_res = $self->request($robot_req);
  	$self->parse_head($parse_head);
  	my $fresh_until = $robot_res->fresh_until;
  	my $content = "";
  	if ($robot_res->is_success && $robot_res->content_is_text) {
  	    $content = $robot_res->decoded_content;
  	    $content = "" unless $content && $content =~ /^\s*Disallow\s*:/mi;
  	}
  	$self->{'rules'}->parse($robot_url, $content, $fresh_until);
  
  	# recalculate allowed...
  	$allowed = $self->{'rules'}->allowed($request->uri);
      }
  
      # Check rules
      unless ($allowed) {
  	my $res = HTTP::Response->new(
  	  &HTTP::Status::RC_FORBIDDEN, 'Forbidden by robots.txt');
  	$res->request( $request ); # bind it to that request
  	return $res;
      }
  
      my $netloc = eval { local $SIG{__DIE__}; $request->uri->host_port; };
      my $wait = $self->host_wait($netloc);
  
      if ($wait) {
  	if ($self->{'use_sleep'}) {
  	    sleep($wait)
  	}
  	else {
  	    my $res = HTTP::Response->new(
  	      &HTTP::Status::RC_SERVICE_UNAVAILABLE, 'Please, slow down');
  	    $res->header('Retry-After', time2str(time + $wait));
  	    $res->request( $request ); # bind it to that request
  	    return $res;
  	}
      }
  
      # Perform the request
      my $res = $self->SUPER::simple_request($request, $arg, $size);
  
      $self->{'rules'}->visit($netloc);
  
      $res;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my @s;
      push(@s, "Robot: $self->{'agent'} operated by $self->{'from'}  [$self]");
      push(@s, "    Minimum delay: " . int($self->{'delay'}*60) . "s");
      push(@s, "    Will sleep if too early") if $self->{'use_sleep'};
      push(@s, "    Rules = $self->{'rules'}");
      join("\n", @s, '');
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::RobotUA - a class for well-behaved Web robots
  
  =head1 SYNOPSIS
  
    use LWP::RobotUA;
    my $ua = LWP::RobotUA->new('my-robot/0.1', 'me@foo.com');
    $ua->delay(10);  # be very nice -- max one hit every ten minutes!
    ...
  
    # Then just use it just like a normal LWP::UserAgent:
    my $response = $ua->get('http://whatever.int/...');
    ...
  
  =head1 DESCRIPTION
  
  This class implements a user agent that is suitable for robot
  applications.  Robots should be nice to the servers they visit.  They
  should consult the F</robots.txt> file to ensure that they are welcomed
  and they should not make requests too frequently.
  
  But before you consider writing a robot, take a look at
  <URL:http://www.robotstxt.org/>.
  
  When you use an I<LWP::RobotUA> object as your user agent, then you do not
  really have to think about these things yourself; C<robots.txt> files
  are automatically consulted and obeyed, the server isn't queried
  too rapidly, and so on.  Just send requests
  as you do when you are using a normal I<LWP::UserAgent>
  object (using C<< $ua->get(...) >>, C<< $ua->head(...) >>,
  C<< $ua->request(...) >>, etc.), and this
  special agent will make sure you are nice.
  
  =head1 METHODS
  
  The LWP::RobotUA is a sub-class of LWP::UserAgent and implements the
  same methods. In addition the following methods are provided:
  
  =over 4
  
  =item $ua = LWP::RobotUA->new( %options )
  
  =item $ua = LWP::RobotUA->new( $agent, $from )
  
  =item $ua = LWP::RobotUA->new( $agent, $from, $rules )
  
  The LWP::UserAgent options C<agent> and C<from> are mandatory.  The
  options C<delay>, C<use_sleep> and C<rules> initialize attributes
  private to the RobotUA.  If C<rules> are not provided, then
  C<WWW::RobotRules> is instantiated providing an internal database of
  F<robots.txt>.
  
  It is also possible to just pass the value of C<agent>, C<from> and
  optionally C<rules> as plain positional arguments.
  
  =item $ua->delay
  
  =item $ua->delay( $minutes )
  
  Get/set the minimum delay between requests to the same server, in
  I<minutes>.  The default is 1 minute.  Note that this number doesn't
  have to be an integer; for example, this sets the delay to 10 seconds:
  
      $ua->delay(10/60);
  
  =item $ua->use_sleep
  
  =item $ua->use_sleep( $boolean )
  
  Get/set a value indicating whether the UA should sleep() if requests
  arrive too fast, defined as $ua->delay minutes not passed since
  last request to the given server.  The default is TRUE.  If this value is
  FALSE then an internal SERVICE_UNAVAILABLE response will be generated.
  It will have a Retry-After header that indicates when it is OK to
  send another request to this server.
  
  =item $ua->rules
  
  =item $ua->rules( $rules )
  
  Set/get which I<WWW::RobotRules> object to use.
  
  =item $ua->no_visits( $netloc )
  
  Returns the number of documents fetched from this server host. Yeah I
  know, this method should probably have been named num_visits() or
  something like that. :-(
  
  =item $ua->host_wait( $netloc )
  
  Returns the number of I<seconds> (from now) you must wait before you can
  make a new request to this host.
  
  =item $ua->as_string
  
  Returns a string that describes the state of the UA.
  Mainly useful for debugging.
  
  =back
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>, L<WWW::RobotRules>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_ROBOTUA

$fatpacked{"LWP/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_SIMPLE';
  package LWP::Simple;
  
  use strict;
  use vars qw($ua %loop_check $FULL_LWP @EXPORT @EXPORT_OK $VERSION);
  
  require Exporter;
  
  @EXPORT = qw(get head getprint getstore mirror);
  @EXPORT_OK = qw($ua);
  
  # I really hate this.  I was a bad idea to do it in the first place.
  # Wonder how to get rid of it???  (It even makes LWP::Simple 7% slower
  # for trivial tests)
  use HTTP::Status;
  push(@EXPORT, @HTTP::Status::EXPORT);
  
  $VERSION = "6.00";
  
  sub import
  {
      my $pkg = shift;
      my $callpkg = caller;
      Exporter::export($pkg, $callpkg, @_);
  }
  
  use LWP::UserAgent ();
  use HTTP::Status ();
  use HTTP::Date ();
  $ua = LWP::UserAgent->new;  # we create a global UserAgent object
  $ua->agent("LWP::Simple/$VERSION ");
  $ua->env_proxy;
  
  
  sub get ($)
  {
      my $response = $ua->get(shift);
      return $response->decoded_content if $response->is_success;
      return undef;
  }
  
  
  sub head ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(HEAD => $url);
      my $response = $ua->request($request);
  
      if ($response->is_success) {
  	return $response unless wantarray;
  	return (scalar $response->header('Content-Type'),
  		scalar $response->header('Content-Length'),
  		HTTP::Date::str2time($response->header('Last-Modified')),
  		HTTP::Date::str2time($response->header('Expires')),
  		scalar $response->header('Server'),
  	       );
      }
      return;
  }
  
  
  sub getprint ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(GET => $url);
      local($\) = ""; # ensure standard $OUTPUT_RECORD_SEPARATOR
      my $callback = sub { print $_[0] };
      if ($^O eq "MacOS") {
  	$callback = sub { $_[0] =~ s/\015?\012/\n/g; print $_[0] }
      }
      my $response = $ua->request($request, $callback);
      unless ($response->is_success) {
  	print STDERR $response->status_line, " <URL:$url>\n";
      }
      $response->code;
  }
  
  
  sub getstore ($$)
  {
      my($url, $file) = @_;
      my $request = HTTP::Request->new(GET => $url);
      my $response = $ua->request($request, $file);
  
      $response->code;
  }
  
  
  sub mirror ($$)
  {
      my($url, $file) = @_;
      my $response = $ua->mirror($url, $file);
      $response->code;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Simple - simple procedural interface to LWP
  
  =head1 SYNOPSIS
  
   perl -MLWP::Simple -e 'getprint "http://www.sn.no"'
  
   use LWP::Simple;
   $content = get("http://www.sn.no/");
   die "Couldn't get it!" unless defined $content;
  
   if (mirror("http://www.sn.no/", "foo") == RC_NOT_MODIFIED) {
       ...
   }
  
   if (is_success(getprint("http://www.sn.no/"))) {
       ...
   }
  
  =head1 DESCRIPTION
  
  This module is meant for people who want a simplified view of the
  libwww-perl library.  It should also be suitable for one-liners.  If
  you need more control or access to the header fields in the requests
  sent and responses received, then you should use the full object-oriented
  interface provided by the C<LWP::UserAgent> module.
  
  The following functions are provided (and exported) by this module:
  
  =over 3
  
  =item get($url)
  
  The get() function will fetch the document identified by the given URL
  and return it.  It returns C<undef> if it fails.  The $url argument can
  be either a string or a reference to a URI object.
  
  You will not be able to examine the response code or response headers
  (like 'Content-Type') when you are accessing the web using this
  function.  If you need that information you should use the full OO
  interface (see L<LWP::UserAgent>).
  
  =item head($url)
  
  Get document headers. Returns the following 5 values if successful:
  ($content_type, $document_length, $modified_time, $expires, $server)
  
  Returns an empty list if it fails.  In scalar context returns TRUE if
  successful.
  
  =item getprint($url)
  
  Get and print a document identified by a URL. The document is printed
  to the selected default filehandle for output (normally STDOUT) as
  data is received from the network.  If the request fails, then the
  status code and message are printed on STDERR.  The return value is
  the HTTP response code.
  
  =item getstore($url, $file)
  
  Gets a document identified by a URL and stores it in the file. The
  return value is the HTTP response code.
  
  =item mirror($url, $file)
  
  Get and store a document identified by a URL, using
  I<If-modified-since>, and checking the I<Content-Length>.  Returns
  the HTTP response code.
  
  =back
  
  This module also exports the HTTP::Status constants and procedures.
  You can use them when you check the response code from getprint(),
  getstore() or mirror().  The constants are:
  
     RC_CONTINUE
     RC_SWITCHING_PROTOCOLS
     RC_OK
     RC_CREATED
     RC_ACCEPTED
     RC_NON_AUTHORITATIVE_INFORMATION
     RC_NO_CONTENT
     RC_RESET_CONTENT
     RC_PARTIAL_CONTENT
     RC_MULTIPLE_CHOICES
     RC_MOVED_PERMANENTLY
     RC_MOVED_TEMPORARILY
     RC_SEE_OTHER
     RC_NOT_MODIFIED
     RC_USE_PROXY
     RC_BAD_REQUEST
     RC_UNAUTHORIZED
     RC_PAYMENT_REQUIRED
     RC_FORBIDDEN
     RC_NOT_FOUND
     RC_METHOD_NOT_ALLOWED
     RC_NOT_ACCEPTABLE
     RC_PROXY_AUTHENTICATION_REQUIRED
     RC_REQUEST_TIMEOUT
     RC_CONFLICT
     RC_GONE
     RC_LENGTH_REQUIRED
     RC_PRECONDITION_FAILED
     RC_REQUEST_ENTITY_TOO_LARGE
     RC_REQUEST_URI_TOO_LARGE
     RC_UNSUPPORTED_MEDIA_TYPE
     RC_INTERNAL_SERVER_ERROR
     RC_NOT_IMPLEMENTED
     RC_BAD_GATEWAY
     RC_SERVICE_UNAVAILABLE
     RC_GATEWAY_TIMEOUT
     RC_HTTP_VERSION_NOT_SUPPORTED
  
  The HTTP::Status classification functions are:
  
  =over 3
  
  =item is_success($rc)
  
  True if response code indicated a successful request.
  
  =item is_error($rc)
  
  True if response code indicated that an error occurred.
  
  =back
  
  The module will also export the LWP::UserAgent object as C<$ua> if you
  ask for it explicitly.
  
  The user agent created by this module will identify itself as
  "LWP::Simple/#.##"
  and will initialize its proxy defaults from the environment (by
  calling $ua->env_proxy).
  
  =head1 CAVEAT
  
  Note that if you are using both LWP::Simple and the very popular CGI.pm
  module, you may be importing a C<head> function from each module,
  producing a warning like "Prototype mismatch: sub main::head ($) vs
  none". Get around this problem by just not importing LWP::Simple's
  C<head> function, like so:
  
          use LWP::Simple qw(!head);
          use CGI qw(:standard);  # then only CGI.pm defines a head()
  
  Then if you do need LWP::Simple's C<head> function, you can just call
  it as C<LWP::Simple::head($url)>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<lwpcook>, L<LWP::UserAgent>, L<HTTP::Status>, L<lwp-request>,
  L<lwp-mirror>
LWP_SIMPLE

$fatpacked{"LWP/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_USERAGENT';
  package LWP::UserAgent;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.06";
  
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date ();
  
  use LWP ();
  use LWP::Protocol ();
  
  use Carp ();
  
  
  sub new
  {
      # Check for common user mistake
      Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference") 
          if ref($_[1]) eq 'HASH'; 
  
      my($class, %cnf) = @_;
  
      my $agent = delete $cnf{agent};
      my $from  = delete $cnf{from};
      my $def_headers = delete $cnf{default_headers};
      my $timeout = delete $cnf{timeout};
      $timeout = 3*60 unless defined $timeout;
      my $local_address = delete $cnf{local_address};
      my $ssl_opts = delete $cnf{ssl_opts} || {};
      unless (exists $ssl_opts->{verify_hostname}) {
  	# The processing of HTTPS_CA_* below is for compatibility with Crypt::SSLeay
  	if (exists $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}) {
  	    $ssl_opts->{verify_hostname} = $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME};
  	}
  	elsif ($ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR}) {
  	    # Crypt-SSLeay compatibility (verify peer certificate; but not the hostname)
  	    $ssl_opts->{verify_hostname} = 0;
  	    $ssl_opts->{SSL_verify_mode} = 1;
  	}
  	else {
  	    $ssl_opts->{verify_hostname} = 1;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_file}) {
  	if (my $ca_file = $ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
  	    $ssl_opts->{SSL_ca_file} = $ca_file;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_path}) {
  	if (my $ca_path = $ENV{PERL_LWP_SSL_CA_PATH} || $ENV{HTTPS_CA_DIR}) {
  	    $ssl_opts->{SSL_ca_path} = $ca_path;
  	}
      }
      my $use_eval = delete $cnf{use_eval};
      $use_eval = 1 unless defined $use_eval;
      my $parse_head = delete $cnf{parse_head};
      $parse_head = 1 unless defined $parse_head;
      my $show_progress = delete $cnf{show_progress};
      my $max_size = delete $cnf{max_size};
      my $max_redirect = delete $cnf{max_redirect};
      $max_redirect = 7 unless defined $max_redirect;
      my $env_proxy = exists $cnf{env_proxy} ? delete $cnf{env_proxy} : $ENV{PERL_LWP_ENV_PROXY};
  
      my $cookie_jar = delete $cnf{cookie_jar};
      my $conn_cache = delete $cnf{conn_cache};
      my $keep_alive = delete $cnf{keep_alive};
      
      Carp::croak("Can't mix conn_cache and keep_alive")
  	  if $conn_cache && $keep_alive;
  
      my $protocols_allowed   = delete $cnf{protocols_allowed};
      my $protocols_forbidden = delete $cnf{protocols_forbidden};
      
      my $requests_redirectable = delete $cnf{requests_redirectable};
      $requests_redirectable = ['GET', 'HEAD']
        unless defined $requests_redirectable;
  
      # Actually ""s are just as good as 0's, but for concision we'll just say:
      Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
        if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
      Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
        if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
      Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
        if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';
  
  
      if (%cnf && $^W) {
  	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
      }
  
      my $self = bless {
  		      def_headers  => $def_headers,
  		      timeout      => $timeout,
  		      local_address => $local_address,
  		      ssl_opts     => $ssl_opts,
  		      use_eval     => $use_eval,
                        show_progress=> $show_progress,
  		      max_size     => $max_size,
  		      max_redirect => $max_redirect,
                        proxy        => {},
  		      no_proxy     => [],
                        protocols_allowed     => $protocols_allowed,
                        protocols_forbidden   => $protocols_forbidden,
                        requests_redirectable => $requests_redirectable,
  		     }, $class;
  
      $self->agent(defined($agent) ? $agent : $class->_agent)
  	if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
      $self->from($from) if $from;
      $self->cookie_jar($cookie_jar) if $cookie_jar;
      $self->parse_head($parse_head);
      $self->env_proxy if $env_proxy;
  
      $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
      $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;
  
      if ($keep_alive) {
  	$conn_cache ||= { total_capacity => $keep_alive };
      }
      $self->conn_cache($conn_cache) if $conn_cache;
  
      return $self;
  }
  
  
  sub send_request
  {
      my($self, $request, $arg, $size) = @_;
      my($method, $url) = ($request->method, $request->uri);
      my $scheme = $url->scheme;
  
      local($SIG{__DIE__});  # protect against user defined die handlers
  
      $self->progress("begin", $request);
  
      my $response = $self->run_handlers("request_send", $request);
  
      unless ($response) {
          my $protocol;
  
          {
              # Honor object-specific restrictions by forcing protocol objects
              #  into class LWP::Protocol::nogo.
              my $x;
              if($x = $self->protocols_allowed) {
                  if (grep lc($_) eq $scheme, @$x) {
                  }
                  else {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              elsif ($x = $self->protocols_forbidden) {
                  if(grep lc($_) eq $scheme, @$x) {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              # else fall thru and create the protocol object normally
          }
  
          # Locate protocol to use
          my $proxy = $request->{proxy};
          if ($proxy) {
              $scheme = $proxy->scheme;
          }
  
          unless ($protocol) {
              $protocol = eval { LWP::Protocol::create($scheme, $self) };
              if ($@) {
                  $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                  $response =  _new_response($request, &HTTP::Status::RC_NOT_IMPLEMENTED, $@);
                  if ($scheme eq "https") {
                      $response->message($response->message . " (LWP::Protocol::https not installed)");
                      $response->content_type("text/plain");
                      $response->content(<<EOT);
  LWP will support https URLs if the LWP::Protocol::https module
  is installed.
  EOT
                  }
              }
          }
  
          if (!$response && $self->{use_eval}) {
              # we eval, and turn dies into responses below
              eval {
                  $response = $protocol->request($request, $proxy, $arg, $size, $self->{timeout}) ||
  		    die "No response returned by $protocol";
              };
              if ($@) {
                  if (UNIVERSAL::isa($@, "HTTP::Response")) {
                      $response = $@;
                      $response->request($request);
                  }
                  else {
                      my $full = $@;
                      (my $status = $@) =~ s/\n.*//s;
                      $status =~ s/ at .* line \d+.*//s;  # remove file/line number
                      my $code = ($status =~ s/^(\d\d\d)\s+//) ? $1 : &HTTP::Status::RC_INTERNAL_SERVER_ERROR;
                      $response = _new_response($request, $code, $status, $full);
                  }
              }
          }
          elsif (!$response) {
              $response = $protocol->request($request, $proxy,
                                             $arg, $size, $self->{timeout});
              # XXX: Should we die unless $response->is_success ???
          }
      }
  
      $response->request($request);  # record request for reference
      $response->header("Client-Date" => HTTP::Date::time2str(time));
  
      $self->run_handlers("response_done", $response);
  
      $self->progress("end", $response);
      return $response;
  }
  
  
  sub prepare_request
  {
      my($self, $request) = @_;
      die "Method missing" unless $request->method;
      my $url = $request->uri;
      die "URL missing" unless $url;
      die "URL must be absolute" unless $url->scheme;
  
      $self->run_handlers("request_preprepare", $request);
  
      if (my $def_headers = $self->{def_headers}) {
  	for my $h ($def_headers->header_field_names) {
  	    $request->init_header($h => [$def_headers->header($h)]);
  	}
      }
  
      $self->run_handlers("request_prepare", $request);
  
      return $request;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # sanity check the request passed in
      if (defined $request) {
  	if (ref $request) {
  	    Carp::croak("You need a request object, not a " . ref($request) . " object")
  	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
  		 !$request->can('method') or !$request->can('uri');
  	}
  	else {
  	    Carp::croak("You need a request object, not '$request'");
  	}
      }
      else {
          Carp::croak("No request object passed in");
      }
  
      eval {
  	$request = $self->prepare_request($request);
      };
      if ($@) {
  	$@ =~ s/ at .* line \d+.*//s;  # remove file/line number
  	return _new_response($request, &HTTP::Status::RC_BAD_REQUEST, $@);
      }
      return $self->send_request($request, $arg, $size);
  }
  
  
  sub request
  {
      my($self, $request, $arg, $size, $previous) = @_;
  
      my $response = $self->simple_request($request, $arg, $size);
      $response->previous($previous) if $previous;
  
      if ($response->redirects >= $self->{max_redirect}) {
          $response->header("Client-Warning" =>
                            "Redirect loop detected (max_redirect = $self->{max_redirect})");
          return $response;
      }
  
      if (my $req = $self->run_handlers("response_redirect", $response)) {
          return $self->request($req, $arg, $size, $response);
      }
  
      my $code = $response->code;
  
      if ($code == &HTTP::Status::RC_MOVED_PERMANENTLY or
  	$code == &HTTP::Status::RC_FOUND or
  	$code == &HTTP::Status::RC_SEE_OTHER or
  	$code == &HTTP::Status::RC_TEMPORARY_REDIRECT)
      {
  	my $referral = $request->clone;
  
  	# These headers should never be forwarded
  	$referral->remove_header('Host', 'Cookie');
  	
  	if ($referral->header('Referer') &&
  	    $request->uri->scheme eq 'https' &&
  	    $referral->uri->scheme eq 'http')
  	{
  	    # RFC 2616, section 15.1.3.
  	    # https -> http redirect, suppressing Referer
  	    $referral->remove_header('Referer');
  	}
  
  	if ($code == &HTTP::Status::RC_SEE_OTHER ||
  	    $code == &HTTP::Status::RC_FOUND) 
          {
  	    my $method = uc($referral->method);
  	    unless ($method eq "GET" || $method eq "HEAD") {
  		$referral->method("GET");
  		$referral->content("");
  		$referral->remove_content_headers;
  	    }
  	}
  
  	# And then we update the URL based on the Location:-header.
  	my $referral_uri = $response->header('Location');
  	{
  	    # Some servers erroneously return a relative URL for redirects,
  	    # so make it absolute if it not already is.
  	    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
  	    my $base = $response->base;
  	    $referral_uri = "" unless defined $referral_uri;
  	    $referral_uri = $HTTP::URI_CLASS->new($referral_uri, $base)
  		            ->abs($base);
  	}
  	$referral->uri($referral_uri);
  
  	return $response unless $self->redirect_ok($referral, $response);
  	return $self->request($referral, $arg, $size, $response);
  
      }
      elsif ($code == &HTTP::Status::RC_UNAUTHORIZED ||
  	     $code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED
  	    )
      {
  	my $proxy = ($code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
  	my $ch_header = $proxy || $request->method eq 'CONNECT'
  	    ?  "Proxy-Authenticate" : "WWW-Authenticate";
  	my @challenge = $response->header($ch_header);
  	unless (@challenge) {
  	    $response->header("Client-Warning" => 
  			      "Missing Authenticate header");
  	    return $response;
  	}
  
  	require HTTP::Headers::Util;
  	CHALLENGE: for my $challenge (@challenge) {
  	    $challenge =~ tr/,/;/;  # "," is used to separate auth-params!!
  	    ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
  	    my $scheme = shift(@$challenge);
  	    shift(@$challenge); # no value
  	    $challenge = { @$challenge };  # make rest into a hash
  
  	    unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
  		$response->header("Client-Warning" => 
  				  "Bad authentication scheme '$scheme'");
  		return $response;
  	    }
  	    $scheme = $1;  # untainted now
  	    my $class = "LWP::Authen::\u$scheme";
  	    $class =~ s/-/_/g;
  
  	    no strict 'refs';
  	    unless (%{"$class\::"}) {
  		# try to load it
  		eval "require $class";
  		if ($@) {
  		    if ($@ =~ /^Can\'t locate/) {
  			$response->header("Client-Warning" =>
  					  "Unsupported authentication scheme '$scheme'");
  		    }
  		    else {
  			$response->header("Client-Warning" => $@);
  		    }
  		    next CHALLENGE;
  		}
  	    }
  	    unless ($class->can("authenticate")) {
  		$response->header("Client-Warning" =>
  				  "Unsupported authentication scheme '$scheme'");
  		next CHALLENGE;
  	    }
  	    return $class->authenticate($self, $proxy, $challenge, $response,
  					$request, $arg, $size);
  	}
  	return $response;
      }
      return $response;
  }
  
  
  #
  # Now the shortcuts...
  #
  sub get {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
  }
  
  
  sub post {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::POST( @parameters ), @suff );
  }
  
  
  sub head {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
  }
  
  
  sub put {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::PUT( @parameters ), @suff );
  }
  
  
  sub delete {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::DELETE( @parameters ), @suff );
  }
  
  
  sub _process_colonic_headers {
      # Process :content_cb / :content_file / :read_size_hint headers.
      my($self, $args, $start_index) = @_;
  
      my($arg, $size);
      for(my $i = $start_index; $i < @$args; $i += 2) {
  	next unless defined $args->[$i];
  
  	#printf "Considering %s => %s\n", $args->[$i], $args->[$i + 1];
  
  	if($args->[$i] eq ':content_cb') {
  	    # Some sanity-checking...
  	    $arg = $args->[$i + 1];
  	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
  	    Carp::croak("A :content_cb value must be a coderef")
  		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
  	    
  	}
  	elsif ($args->[$i] eq ':content_file') {
  	    $arg = $args->[$i + 1];
  
  	    # Some sanity-checking...
  	    Carp::croak("A :content_file value can't be undef")
  		unless defined $arg;
  	    Carp::croak("A :content_file value can't be a reference")
  		if ref $arg;
  	    Carp::croak("A :content_file value can't be \"\"")
  		unless length $arg;
  
  	}
  	elsif ($args->[$i] eq ':read_size_hint') {
  	    $size = $args->[$i + 1];
  	    # Bother checking it?
  
  	}
  	else {
  	    next;
  	}
  	splice @$args, $i, 2;
  	$i -= 2;
      }
  
      # And return a suitable suffix-list for request(REQ,...)
  
      return             unless defined $arg;
      return $arg, $size if     defined $size;
      return $arg;
  }
  
  
  sub is_online {
      my $self = shift;
      return 1 if $self->get("http://www.msftncsi.com/ncsi.txt")->content eq "Microsoft NCSI";
      return 1 if $self->get("http://www.apple.com")->content =~ m,<title>Apple</title>,;
      return 0;
  }
  
  
  my @ANI = qw(- \ | /);
  
  sub progress {
      my($self, $status, $m) = @_;
      return unless $self->{show_progress};
  
      local($,, $\);
      if ($status eq "begin") {
          print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
          $self->{progress_start} = time;
          $self->{progress_lastp} = "";
          $self->{progress_ani} = 0;
      }
      elsif ($status eq "end") {
          delete $self->{progress_lastp};
          delete $self->{progress_ani};
          print STDERR $m->status_line;
          my $t = time - delete $self->{progress_start};
          print STDERR " (${t}s)" if $t;
          print STDERR "\n";
      }
      elsif ($status eq "tick") {
          print STDERR "$ANI[$self->{progress_ani}++]\b";
          $self->{progress_ani} %= @ANI;
      }
      else {
          my $p = sprintf "%3.0f%%", $status * 100;
          return if $p eq $self->{progress_lastp};
          print STDERR "$p\b\b\b\b";
          $self->{progress_lastp} = $p;
      }
      STDERR->flush;
  }
  
  
  #
  # This whole allow/forbid thing is based on man 1 at's way of doing things.
  #
  sub is_protocol_supported
  {
      my($self, $scheme) = @_;
      if (ref $scheme) {
  	# assume we got a reference to an URI object
  	$scheme = $scheme->scheme;
      }
      else {
  	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
  	    if $scheme =~ /\W/;
  	$scheme = lc $scheme;
      }
  
      my $x;
      if(ref($self) and $x       = $self->protocols_allowed) {
        return 0 unless grep lc($_) eq $scheme, @$x;
      }
      elsif (ref($self) and $x = $self->protocols_forbidden) {
        return 0 if grep lc($_) eq $scheme, @$x;
      }
  
      local($SIG{__DIE__});  # protect against user defined die handlers
      $x = LWP::Protocol::implementor($scheme);
      return 1 if $x and $x ne 'LWP::Protocol::nogo';
      return 0;
  }
  
  
  sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
  sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
  sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }
  
  
  sub redirect_ok
  {
      # RFC 2616, section 10.3.2 and 10.3.3 say:
      #  If the 30[12] status code is received in response to a request other
      #  than GET or HEAD, the user agent MUST NOT automatically redirect the
      #  request unless it can be confirmed by the user, since this might
      #  change the conditions under which the request was issued.
  
      # Note that this routine used to be just:
      #  return 0 if $_[1]->method eq "POST";  return 1;
  
      my($self, $new_request, $response) = @_;
      my $method = $response->request->method;
      return 0 unless grep $_ eq $method,
        @{ $self->requests_redirectable || [] };
      
      if ($new_request->uri->scheme eq 'file') {
        $response->header("Client-Warning" =>
  			"Can't redirect to a file:// URL!");
        return 0;
      }
      
      # Otherwise it's apparently okay...
      return 1;
  }
  
  
  sub credentials
  {
      my $self = shift;
      my $netloc = lc(shift);
      my $realm = shift || "";
      my $old = $self->{basic_authentication}{$netloc}{$realm};
      if (@_) {
          $self->{basic_authentication}{$netloc}{$realm} = [@_];
      }
      return unless $old;
      return @$old if wantarray;
      return join(":", @$old);
  }
  
  
  sub get_basic_credentials
  {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->credentials($uri->host_port, $realm);
  }
  
  
  sub timeout      { shift->_elem('timeout',      @_); }
  sub local_address{ shift->_elem('local_address',@_); }
  sub max_size     { shift->_elem('max_size',     @_); }
  sub max_redirect { shift->_elem('max_redirect', @_); }
  sub show_progress{ shift->_elem('show_progress', @_); }
  
  sub ssl_opts {
      my $self = shift;
      if (@_ == 1) {
  	my $k = shift;
  	return $self->{ssl_opts}{$k};
      }
      if (@_) {
  	my $old;
  	while (@_) {
  	    my($k, $v) = splice(@_, 0, 2);
  	    $old = $self->{ssl_opts}{$k} unless @_;
  	    if (defined $v) {
  		$self->{ssl_opts}{$k} = $v;
  	    }
  	    else {
  		delete $self->{ssl_opts}{$k};
  	    }
  	}
  	%{$self->{ssl_opts}} = (%{$self->{ssl_opts}}, @_);
  	return $old;
      }
  
      return keys %{$self->{ssl_opts}};
  }
  
  sub parse_head {
      my $self = shift;
      if (@_) {
          my $flag = shift;
          my $parser;
          my $old = $self->set_my_handler("response_header", $flag ? sub {
                 my($response, $ua) = @_;
                 require HTML::HeadParser;
                 $parser = HTML::HeadParser->new;
                 $parser->xml_mode(1) if $response->content_is_xhtml;
                 $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;
  
                 push(@{$response->{handlers}{response_data}}, {
  		   callback => sub {
  		       return unless $parser;
  		       unless ($parser->parse($_[3])) {
  			   my $h = $parser->header;
  			   my $r = $_[0];
  			   for my $f ($h->header_field_names) {
  			       $r->init_header($f, [$h->header($f)]);
  			   }
  			   undef($parser);
  		       }
  		   },
  	       });
  
              } : undef,
              m_media_type => "html",
          );
          return !!$old;
      }
      else {
          return !!$self->get_my_handler("response_header");
      }
  }
  
  sub cookie_jar {
      my $self = shift;
      my $old = $self->{cookie_jar};
      if (@_) {
  	my $jar = shift;
  	if (ref($jar) eq "HASH") {
  	    require HTTP::Cookies;
  	    $jar = HTTP::Cookies->new(%$jar);
  	}
  	$self->{cookie_jar} = $jar;
          $self->set_my_handler("request_prepare",
              $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
          );
          $self->set_my_handler("response_done",
              $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
          );
      }
      $old;
  }
  
  sub default_headers {
      my $self = shift;
      my $old = $self->{def_headers} ||= HTTP::Headers->new;
      if (@_) {
  	Carp::croak("default_headers not set to HTTP::Headers compatible object")
  	    unless @_ == 1 && $_[0]->can("header_field_names");
  	$self->{def_headers} = shift;
      }
      return $old;
  }
  
  sub default_header {
      my $self = shift;
      return $self->default_headers->header(@_);
  }
  
  sub _agent       { "libwww-perl/$LWP::VERSION" }
  
  sub agent {
      my $self = shift;
      if (@_) {
  	my $agent = shift;
          if ($agent) {
              $agent .= $self->_agent if $agent =~ /\s+$/;
          }
          else {
              undef($agent)
          }
          return $self->default_header("User-Agent", $agent);
      }
      return $self->default_header("User-Agent");
  }
  
  sub from {  # legacy
      my $self = shift;
      return $self->default_header("From", @_);
  }
  
  
  sub conn_cache {
      my $self = shift;
      my $old = $self->{conn_cache};
      if (@_) {
  	my $cache = shift;
  	if (ref($cache) eq "HASH") {
  	    require LWP::ConnCache;
  	    $cache = LWP::ConnCache->new(%$cache);
  	}
  	$self->{conn_cache} = $cache;
      }
      $old;
  }
  
  
  sub add_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{line} ||= join(":", (caller)[1,2]);
      my $conf = $self->{handlers}{$phase} ||= do {
          require HTTP::Config;
          HTTP::Config->new;
      };
      $conf->add(%spec, callback => $cb);
  }
  
  sub set_my_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      $self->remove_handler($phase, %spec);
      $spec{line} ||= join(":", (caller)[1,2]);
      $self->add_handler($phase, $cb, %spec) if $cb;
  }
  
  sub get_my_handler {
      my $self = shift;
      my $phase = shift;
      my $init = pop if @_ % 2;
      my %spec = @_;
      my $conf = $self->{handlers}{$phase};
      unless ($conf) {
          return unless $init;
          require HTTP::Config;
          $conf = $self->{handlers}{$phase} = HTTP::Config->new;
      }
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      my @h = $conf->find(%spec);
      if (!@h && $init) {
          if (ref($init) eq "CODE") {
              $init->(\%spec);
          }
          elsif (ref($init) eq "HASH") {
              while (my($k, $v) = each %$init) {
                  $spec{$k} = $v;
              }
          }
          $spec{callback} ||= sub {};
          $spec{line} ||= join(":", (caller)[1,2]);
          $conf->add(\%spec);
          return \%spec;
      }
      return wantarray ? @h : $h[0];
  }
  
  sub remove_handler {
      my($self, $phase, %spec) = @_;
      if ($phase) {
          my $conf = $self->{handlers}{$phase} || return;
          my @h = $conf->remove(%spec);
          delete $self->{handlers}{$phase} if $conf->empty;
          return @h;
      }
  
      return unless $self->{handlers};
      return map $self->remove_handler($_), sort keys %{$self->{handlers}};
  }
  
  sub handlers {
      my($self, $phase, $o) = @_;
      my @h;
      if ($o->{handlers} && $o->{handlers}{$phase}) {
          push(@h, @{$o->{handlers}{$phase}});
      }
      if (my $conf = $self->{handlers}{$phase}) {
          push(@h, $conf->matching($o));
      }
      return @h;
  }
  
  sub run_handlers {
      my($self, $phase, $o) = @_;
      if (defined(wantarray)) {
          for my $h ($self->handlers($phase, $o)) {
              my $ret = $h->{callback}->($o, $self, $h);
              return $ret if $ret;
          }
          return undef;
      }
  
      for my $h ($self->handlers($phase, $o)) {
          $h->{callback}->($o, $self, $h);
      }
  }
  
  
  # deprecated
  sub use_eval   { shift->_elem('use_eval',  @_); }
  sub use_alarm
  {
      Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
  	if @_ > 1 && $^W;
      "";
  }
  
  
  sub clone
  {
      my $self = shift;
      my $copy = bless { %$self }, ref $self;  # copy most fields
  
      delete $copy->{handlers};
      delete $copy->{conn_cache};
  
      # copy any plain arrays and hashes; known not to need recursive copy
      for my $k (qw(proxy no_proxy requests_redirectable ssl_opts)) {
          next unless $copy->{$k};
          if (ref($copy->{$k}) eq "ARRAY") {
              $copy->{$k} = [ @{$copy->{$k}} ];
          }
          elsif (ref($copy->{$k}) eq "HASH") {
              $copy->{$k} = { %{$copy->{$k}} };
          }
      }
  
      if ($self->{def_headers}) {
          $copy->{def_headers} = $self->{def_headers}->clone;
      }
  
      # re-enable standard handlers
      $copy->parse_head($self->parse_head);
  
      # no easy way to clone the cookie jar; so let's just remove it for now
      $copy->cookie_jar(undef);
  
      $copy;
  }
  
  
  sub mirror
  {
      my($self, $url, $file) = @_;
  
      my $request = HTTP::Request->new('GET', $url);
  
      # If the file exists, add a cache-related header
      if ( -e $file ) {
          my ($mtime) = ( stat($file) )[9];
          if ($mtime) {
              $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
          }
      }
      my $tmpfile = "$file-$$";
  
      my $response = $self->request($request, $tmpfile);
      if ( $response->header('X-Died') ) {
  	die $response->header('X-Died');
      }
  
      # Only fetching a fresh copy of the would be considered success.
      # If the file was not modified, "304" would returned, which 
      # is considered by HTTP::Status to be a "redirect", /not/ "success"
      if ( $response->is_success ) {
          my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
          my $file_length = $stat[7];
          my ($content_length) = $response->header('Content-length');
  
          if ( defined $content_length and $file_length < $content_length ) {
              unlink($tmpfile);
              die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
          }
          elsif ( defined $content_length and $file_length > $content_length ) {
              unlink($tmpfile);
              die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
          }
          # The file was the expected length. 
          else {
              # Replace the stale file with a fresh copy
              if ( -e $file ) {
                  # Some DOSish systems fail to rename if the target exists
                  chmod 0777, $file;
                  unlink $file;
              }
              rename( $tmpfile, $file )
                  or die "Cannot rename '$tmpfile' to '$file': $!\n";
  
              # make sure the file has the same last modification time
              if ( my $lm = $response->last_modified ) {
                  utime $lm, $lm, $file;
              }
          }
      }
      # The local copy is fresh enough, so just delete the temp file  
      else {
  	unlink($tmpfile);
      }
      return $response;
  }
  
  
  sub _need_proxy {
      my($req, $ua) = @_;
      return if exists $req->{proxy};
      my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
      if ($ua->{no_proxy}) {
          if (my $host = eval { $req->uri->host }) {
              for my $domain (@{$ua->{no_proxy}}) {
                  if ($host =~ /\Q$domain\E$/) {
                      return;
                  }
              }
          }
      }
      $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
  }
  
  
  sub proxy
  {
      my $self = shift;
      my $key  = shift;
      return map $self->proxy($_, @_), @$key if ref $key;
  
      Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
      my $old = $self->{'proxy'}{$key};
      if (@_) {
          my $url = shift;
          if (defined($url) && length($url)) {
              Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
              Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
          }
          $self->{proxy}{$key} = $url;
          $self->set_my_handler("request_preprepare", \&_need_proxy)
      }
      return $old;
  }
  
  
  sub env_proxy {
      my ($self) = @_;
      require Encode;
      require Encode::Locale;
      my($k,$v);
      while(($k, $v) = each %ENV) {
  	if ($ENV{REQUEST_METHOD}) {
  	    # Need to be careful when called in the CGI environment, as
  	    # the HTTP_PROXY variable is under control of that other guy.
  	    next if $k =~ /^HTTP_/;
  	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
  	}
  	$k = lc($k);
  	next unless $k =~ /^(.*)_proxy$/;
  	$k = $1;
  	if ($k eq 'no') {
  	    $self->no_proxy(split(/\s*,\s*/, $v));
  	}
  	else {
              # Ignore random _proxy variables, allow only valid schemes
              next unless $k =~ /^$URI::scheme_re\z/;
              # Ignore xxx_proxy variables if xxx isn't a supported protocol
              next unless LWP::Protocol::implementor($k);
  	    $self->proxy($k, Encode::decode(locale => $v));
  	}
      }
  }
  
  
  sub no_proxy {
      my($self, @no) = @_;
      if (@no) {
  	push(@{ $self->{'no_proxy'} }, @no);
      }
      else {
  	$self->{'no_proxy'} = [];
      }
  }
  
  
  sub _new_response {
      my($request, $code, $message, $content) = @_;
      $message ||= HTTP::Status::status_message($code);
      my $response = HTTP::Response->new($code, $message);
      $response->request($request);
      $response->header("Client-Date" => HTTP::Date::time2str(time));
      $response->header("Client-Warning" => "Internal response");
      $response->header("Content-Type" => "text/plain");
      $response->content($content || "$code $message\n");
      return $response;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::UserAgent - Web user agent class
  
  =head1 SYNOPSIS
  
   require LWP::UserAgent;
   
   my $ua = LWP::UserAgent->new;
   $ua->timeout(10);
   $ua->env_proxy;
   
   my $response = $ua->get('http://search.cpan.org/');
   
   if ($response->is_success) {
       print $response->decoded_content;  # or whatever
   }
   else {
       die $response->status_line;
   }
  
  =head1 DESCRIPTION
  
  The C<LWP::UserAgent> is a class implementing a web user agent.
  C<LWP::UserAgent> objects can be used to dispatch web requests.
  
  In normal use the application creates an C<LWP::UserAgent> object, and
  then configures it with values for timeouts, proxies, name, etc. It
  then creates an instance of C<HTTP::Request> for the request that
  needs to be performed. This request is then passed to one of the
  request method the UserAgent, which dispatches it using the relevant
  protocol, and returns a C<HTTP::Response> object.  There are
  convenience methods for sending the most common request types: get(),
  head(), post(), put() and delete().  When using these methods then the
  creation of the request object is hidden as shown in the synopsis above.
  
  The basic approach of the library is to use HTTP style communication
  for all protocol schemes.  This means that you will construct
  C<HTTP::Request> objects and receive C<HTTP::Response> objects even
  for non-HTTP resources like I<gopher> and I<ftp>.  In order to achieve
  even more similarity to HTTP style communications, gopher menus and
  file directories are converted to HTML documents.
  
  =head1 CONSTRUCTOR METHODS
  
  The following constructor methods are available:
  
  =over 4
  
  =item $ua = LWP::UserAgent->new( %options )
  
  This method constructs a new C<LWP::UserAgent> object and returns it.
  Key/value pair arguments may be provided to set up the initial state.
  The following options correspond to attribute methods described below:
  
     KEY                     DEFAULT
     -----------             --------------------
     agent                   "libwww-perl/#.###"
     from                    undef
     conn_cache              undef
     cookie_jar              undef
     default_headers         HTTP::Headers->new
     local_address           undef
     ssl_opts		   { verify_hostname => 1 }
     max_size                undef
     max_redirect            7
     parse_head              1
     protocols_allowed       undef
     protocols_forbidden     undef
     requests_redirectable   ['GET', 'HEAD']
     timeout                 180
  
  The following additional options are also accepted: If the C<env_proxy> option
  is passed in with a TRUE value, then proxy settings are read from environment
  variables (see env_proxy() method below).  If C<env_proxy> isn't provided the
  C<PERL_LWP_ENV_PROXY> environment variable controls if env_proxy() is called
  during initialization.  If the C<keep_alive> option is passed in, then a
  C<LWP::ConnCache> is set up (see conn_cache() method below).  The C<keep_alive>
  value is passed on as the C<total_capacity> for the connection cache.
  
  =item $ua->clone
  
  Returns a copy of the LWP::UserAgent object.
  
  =back
  
  =head1 ATTRIBUTES
  
  The settings of the configuration attributes modify the behaviour of the
  C<LWP::UserAgent> when it dispatches requests.  Most of these can also
  be initialized by options passed to the constructor method.
  
  The following attribute methods are provided.  The attribute value is
  left unchanged if no argument is given.  The return value from each
  method is the old attribute value.
  
  =over
  
  =item $ua->agent
  
  =item $ua->agent( $product_id )
  
  Get/set the product token that is used to identify the user agent on
  the network.  The agent value is sent as the "User-Agent" header in
  the requests.  The default is the string returned by the _agent()
  method (see below).
  
  If the $product_id ends with space then the _agent() string is
  appended to it.
  
  The user agent string should be one or more simple product identifiers
  with an optional version number separated by the "/" character.
  Examples are:
  
    $ua->agent('Checkbot/0.4 ' . $ua->_agent);
    $ua->agent('Checkbot/0.4 ');    # same as above
    $ua->agent('Mozilla/5.0');
    $ua->agent("");                 # don't identify
  
  =item $ua->_agent
  
  Returns the default agent identifier.  This is a string of the form
  "libwww-perl/#.###", where "#.###" is substituted with the version number
  of this library.
  
  =item $ua->from
  
  =item $ua->from( $email_address )
  
  Get/set the e-mail address for the human user who controls
  the requesting user agent.  The address should be machine-usable, as
  defined in RFC 822.  The C<from> value is send as the "From" header in
  the requests.  Example:
  
    $ua->from('gaas@cpan.org');
  
  The default is to not send a "From" header.  See the default_headers()
  method for the more general interface that allow any header to be defaulted.
  
  =item $ua->cookie_jar
  
  =item $ua->cookie_jar( $cookie_jar_obj )
  
  Get/set the cookie jar object to use.  The only requirement is that
  the cookie jar object must implement the extract_cookies($response) and
  add_cookie_header($request) methods.  These methods will then be
  invoked by the user agent as requests are sent and responses are
  received.  Normally this will be a C<HTTP::Cookies> object or some
  subclass.
  
  The default is to have no cookie_jar, i.e. never automatically add
  "Cookie" headers to the requests.
  
  Shortcut: If a reference to a plain hash is passed in as the
  $cookie_jar_object, then it is replaced with an instance of
  C<HTTP::Cookies> that is initialized based on the hash.  This form also
  automatically loads the C<HTTP::Cookies> module.  It means that:
  
    $ua->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
  
  is really just a shortcut for:
  
    require HTTP::Cookies;
    $ua->cookie_jar(HTTP::Cookies->new(file => "$ENV{HOME}/.cookies.txt"));
  
  =item $ua->default_headers
  
  =item $ua->default_headers( $headers_obj )
  
  Get/set the headers object that will provide default header values for
  any requests sent.  By default this will be an empty C<HTTP::Headers>
  object.
  
  =item $ua->default_header( $field )
  
  =item $ua->default_header( $field => $value )
  
  This is just a short-cut for $ua->default_headers->header( $field =>
  $value ). Example:
  
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
    $ua->default_header('Accept-Language' => "no, en");
  
  =item $ua->conn_cache
  
  =item $ua->conn_cache( $cache_obj )
  
  Get/set the C<LWP::ConnCache> object to use.  See L<LWP::ConnCache>
  for details.
  
  =item $ua->credentials( $netloc, $realm )
  
  =item $ua->credentials( $netloc, $realm, $uname, $pass )
  
  Get/set the user name and password to be used for a realm.
  
  The $netloc is a string of the form "<host>:<port>".  The username and
  password will only be passed to this server.  Example:
  
    $ua->credentials("www.example.com:80", "Some Realm", "foo", "secret");
  
  =item $ua->local_address
  
  =item $ua->local_address( $address )
  
  Get/set the local interface to bind to for network connections.  The interface
  can be specified as a hostname or an IP address.  This value is passed as the
  C<LocalAddr> argument to L<IO::Socket::INET>.
  
  =item $ua->max_size
  
  =item $ua->max_size( $bytes )
  
  Get/set the size limit for response content.  The default is C<undef>,
  which means that there is no limit.  If the returned response content
  is only partial, because the size limit was exceeded, then a
  "Client-Aborted" header will be added to the response.  The content
  might end up longer than C<max_size> as we abort once appending a
  chunk of data makes the length exceed the limit.  The "Content-Length"
  header, if present, will indicate the length of the full content and
  will normally not be the same as C<< length($res->content) >>.
  
  =item $ua->max_redirect
  
  =item $ua->max_redirect( $n )
  
  This reads or sets the object's limit of how many times it will obey
  redirection responses in a given request cycle.
  
  By default, the value is 7. This means that if you call request()
  method and the response is a redirect elsewhere which is in turn a
  redirect, and so on seven times, then LWP gives up after that seventh
  request.
  
  =item $ua->parse_head
  
  =item $ua->parse_head( $boolean )
  
  Get/set a value indicating whether we should initialize response
  headers from the E<lt>head> section of HTML documents. The default is
  TRUE.  Do not turn this off, unless you know what you are doing.
  
  =item $ua->protocols_allowed
  
  =item $ua->protocols_allowed( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request methods will exclusively allow.  The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_allowed( [ 'http', 'https'] );>
  means that this user agent will I<allow only> those protocols,
  and attempts to use this user agent to access URLs with any other
  schemes (like "ftp://...") will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_allowed(undef)>
  
  By default, an object has neither a C<protocols_allowed> list, nor a
  C<protocols_forbidden> list.
  
  Note that having a C<protocols_allowed> list causes any
  C<protocols_forbidden> list to be ignored.
  
  =item $ua->protocols_forbidden
  
  =item $ua->protocols_forbidden( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request method will I<not> allow. The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_forbidden( [ 'file', 'mailto'] );>
  means that this user agent will I<not> allow those protocols, and
  attempts to use this user agent to access URLs with those schemes
  will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_forbidden(undef)>
  
  =item $ua->requests_redirectable
  
  =item $ua->requests_redirectable( \@requests )
  
  This reads or sets the object's list of request names that
  C<$ua-E<gt>redirect_ok(...)> will allow redirection for.  By
  default, this is C<['GET', 'HEAD']>, as per RFC 2616.  To
  change to include 'POST', consider:
  
     push @{ $ua->requests_redirectable }, 'POST';
  
  =item $ua->show_progress
  
  =item $ua->show_progress( $boolean )
  
  Get/set a value indicating whether a progress bar should be displayed
  on the terminal as requests are processed. The default is FALSE.
  
  =item $ua->timeout
  
  =item $ua->timeout( $secs )
  
  Get/set the timeout value in seconds. The default timeout() value is
  180 seconds, i.e. 3 minutes.
  
  The requests is aborted if no activity on the connection to the server
  is observed for C<timeout> seconds.  This means that the time it takes
  for the complete transaction and the request() method to actually
  return might be longer.
  
  =item $ua->ssl_opts
  
  =item $ua->ssl_opts( $key )
  
  =item $ua->ssl_opts( $key => $value )
  
  Get/set the options for SSL connections.  Without argument return the list
  of options keys currently set.  With a single argument return the current
  value for the given option.  With 2 arguments set the option value and return
  the old.  Setting an option to the value C<undef> removes this option.
  
  The options that LWP relates to are:
  
  =over
  
  =item C<verify_hostname> => $bool
  
  When TRUE LWP will for secure protocol schemes ensure it connects to servers
  that have a valid certificate matching the expected hostname.  If FALSE no
  checks are made and you can't be sure that you communicate with the expected peer.
  The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.
  
  This option is initialized from the L<PERL_LWP_SSL_VERIFY_HOSTNAME> environment
  variable.  If this environment variable isn't set; then C<verify_hostname>
  defaults to 1.
  
  =item C<SSL_ca_file> => $path
  
  The path to a file containing Certificate Authority certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_FILE> and C<HTTPS_CA_FILE> in order.
  
  =item C<SSL_ca_path> => $path
  
  The path to a directory containing files containing Certificate Authority
  certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_PATH> and C<HTTPS_CA_DIR> in order.
  
  =back
  
  Other options can be set and are processed directly by the SSL Socket implementation
  in use.  See L<IO::Socket::SSL> or L<Net::SSL> for details.
  
  The libwww-perl core no longer bundles protocol plugins for SSL.  You will need
  to install L<LWP::Protocol::https> separately to enable support for processing
  https-URLs.
  
  =back
  
  =head2 Proxy attributes
  
  The following methods set up when requests should be passed via a
  proxy server.
  
  =over
  
  =item $ua->proxy(\@schemes, $proxy_url)
  
  =item $ua->proxy($scheme, $proxy_url)
  
  Set/retrieve proxy URL for a scheme:
  
   $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
   $ua->proxy('gopher', 'http://proxy.sn.no:8001/');
  
  The first form specifies that the URL is to be used for proxying of
  access methods listed in the list in the first method argument,
  i.e. 'http' and 'ftp'.
  
  The second form shows a shorthand form for specifying
  proxy URL for a single access scheme.
  
  =item $ua->no_proxy( $domain, ... )
  
  Do not proxy requests to the given domains.  Calling no_proxy without
  any domains clears the list of domains. Eg:
  
   $ua->no_proxy('localhost', 'example.com');
  
  =item $ua->env_proxy
  
  Load proxy settings from *_proxy environment variables.  You might
  specify proxies like this (sh-syntax):
  
    gopher_proxy=http://proxy.my.place/
    wais_proxy=http://proxy.my.place/
    no_proxy="localhost,example.com"
    export gopher_proxy wais_proxy no_proxy
  
  csh or tcsh users should use the C<setenv> command to define these
  environment variables.
  
  On systems with case insensitive environment variables there exists a
  name clash between the CGI environment variables and the C<HTTP_PROXY>
  environment variable normally picked up by env_proxy().  Because of
  this C<HTTP_PROXY> is not honored for CGI scripts.  The
  C<CGI_HTTP_PROXY> environment variable can be used instead.
  
  =back
  
  =head2 Handlers
  
  Handlers are code that injected at various phases during the
  processing of requests.  The following methods are provided to manage
  the active handlers:
  
  =over
  
  =item $ua->add_handler( $phase => \&cb, %matchspec )
  
  Add handler to be invoked in the given processing phase.  For how to
  specify %matchspec see L<HTTP::Config/"Matching">.
  
  The possible values $phase and the corresponding callback signatures are:
  
  =over
  
  =item request_preprepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the C<request_prepare> and other standard
  initialization of the request.  This can be used to set up headers
  and attributes that the C<request_prepare> handler depends on.  Proxy
  initialization should take place here; but in general don't register
  handlers for this phase.
  
  =item request_prepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the request is sent and can modify the
  request any way it see fit.  This can for instance be used to add
  certain headers to specific requests.
  
  The method can assign a new request object to $_[0] to replace the
  request that is sent fully.
  
  The return value from the callback is ignored.  If an exception is
  raised it will abort the request and make the request method return a
  "400 Bad request" response.
  
  =item request_send => sub { my($request, $ua, $h) = @_; ... }
  
  This handler gets a chance of handling requests before they're sent to the
  protocol handlers.  It should return an HTTP::Response object if it
  wishes to terminate the processing; otherwise it should return nothing.
  
  The C<response_header> and C<response_data> handlers will not be
  invoked for this response, but the C<response_done> will be.
  
  =item response_header => sub { my($response, $ua, $h) = @_; ... }
  
  This handler is called right after the response headers have been
  received, but before any content data.  The handler might set up
  handlers for data and might croak to abort the request.
  
  The handler might set the $response->{default_add_content} value to
  control if any received data should be added to the response object
  directly.  This will initially be false if the $ua->request() method
  was called with a $content_file or $content_cb argument; otherwise true.
  
  =item response_data => sub { my($response, $ua, $h, $data) = @_; ... }
  
  This handler is called for each chunk of data received for the
  response.  The handler might croak to abort the request.
  
  This handler needs to return a TRUE value to be called again for
  subsequent chunks for the same request.
  
  =item response_done => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called after the response has been fully received, but
  before any redirect handling is attempted.  The handler can be used to
  extract information or modify the response.
  
  =item response_redirect => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called in $ua->request after C<response_done>.  If the
  handler returns an HTTP::Request object we'll start over with processing
  this request instead.
  
  =back
  
  =item $ua->remove_handler( undef, %matchspec )
  
  =item $ua->remove_handler( $phase, %matchspec )
  
  Remove handlers that match the given %matchspec.  If $phase is not
  provided remove handlers from all phases.
  
  Be careful as calling this function with %matchspec that is not
  specific enough can remove handlers not owned by you.  It's probably
  better to use the set_my_handler() method instead.
  
  The removed handlers are returned.
  
  =item $ua->set_my_handler( $phase, $cb, %matchspec )
  
  Set handlers private to the executing subroutine.  Works by defaulting
  an C<owner> field to the %matchspec that holds the name of the called
  subroutine.  You might pass an explicit C<owner> to override this.
  
  If $cb is passed as C<undef>, remove the handler.
  
  =item $ua->get_my_handler( $phase, %matchspec )
  
  =item $ua->get_my_handler( $phase, %matchspec, $init )
  
  Will retrieve the matching handler as hash ref.
  
  If C<$init> is passed as a TRUE value, create and add the
  handler if it's not found.  If $init is a subroutine reference, then
  it's called with the created handler hash as argument.  This sub might
  populate the hash with extra fields; especially the callback.  If
  $init is a hash reference, merge the hashes.
  
  =item $ua->handlers( $phase, $request )
  
  =item $ua->handlers( $phase, $response )
  
  Returns the handlers that apply to the given request or response at
  the given processing phase.
  
  =back
  
  =head1 REQUEST METHODS
  
  The methods described in this section are used to dispatch requests
  via the user agent.  The following request methods are provided:
  
  =over
  
  =item $ua->get( $url )
  
  =item $ua->get( $url , $field_name => $value, ... )
  
  This method will dispatch a C<GET> request on the given $url.  Further
  arguments can be given to initialize the headers of the request. These
  are given as separate name/value pairs.  The return value is a
  response object.  See L<HTTP::Response> for a description of the
  interface it provides.
  
  There will still be a response object returned when LWP can't connect to the
  server specified in the URL or when other failures in protocol handlers occur.
  These internal responses use the standard HTTP status codes, so the responses
  can't be differentiated by testing the response status code alone.  Error
  responses that LWP generates internally will have the "Client-Warning" header
  set to the value "Internal response".  If you need to differentiate these
  internal responses from responses that a remote server actually generates, you
  need to test this header value.
  
  Fields names that start with ":" are special.  These will not
  initialize headers of the request but will determine how the response
  content is treated.  The following special field names are recognized:
  
      :content_file   => $filename
      :content_cb     => \&callback
      :read_size_hint => $bytes
  
  If a $filename is provided with the C<:content_file> option, then the
  response content will be saved here instead of in the response
  object.  If a callback is provided with the C<:content_cb> option then
  this function will be called for each chunk of the response content as
  it is received from the server.  If neither of these options are
  given, then the response content will accumulate in the response
  object itself.  This might not be suitable for very large response
  bodies.  Only one of C<:content_file> or C<:content_cb> can be
  specified.  The content of unsuccessful responses will always
  accumulate in the response object itself, regardless of the
  C<:content_file> or C<:content_cb> options passed in.
  
  The C<:read_size_hint> option is passed to the protocol module which
  will try to read data from the server in chunks of this size.  A
  smaller value for the C<:read_size_hint> will result in a higher
  number of callback invocations.
  
  The callback function is called with 3 arguments: a chunk of data, a
  reference to the response object, and a reference to the protocol
  object.  The callback can abort the request by invoking die().  The
  exception message will show up as the "X-Died" header field in the
  response returned by the get() function.
  
  =item $ua->head( $url )
  
  =item $ua->head( $url , $field_name => $value, ... )
  
  This method will dispatch a C<HEAD> request on the given $url.
  Otherwise it works like the get() method described above.
  
  =item $ua->post( $url, \%form )
  
  =item $ua->post( $url, \@form )
  
  =item $ua->post( $url, \%form, $field_name => $value, ... )
  
  =item $ua->post( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->post( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->post( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<POST> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the POST() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->put( $url, \%form )
  
  =item $ua->put( $url, \@form )
  
  =item $ua->put( $url, \%form, $field_name => $value, ... )
  
  =item $ua->put( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->put( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->put( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<PUT> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the PUT() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->delete( $url )
  
  =item $ua->delete( $url, $field_name => $value, ... )
  
  This method will dispatch a C<DELETE> request on the given $url.  Additional
  headers and content options are the same as for the get() method.
  
  This method will use the DELETE() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->mirror( $url, $filename )
  
  This method will get the document identified by $url and store it in
  file called $filename.  If the file already exists, then the request
  will contain an "If-Modified-Since" header matching the modification
  time of the file.  If the document on the server has not changed since
  this time, then nothing happens.  If the document has been updated, it
  will be downloaded again.  The modification time of the file will be
  forced to match that of the server.
  
  The return value is the response object.
  
  =item $ua->request( $request )
  
  =item $ua->request( $request, $content_file )
  
  =item $ua->request( $request, $content_cb )
  
  =item $ua->request( $request, $content_cb, $read_size_hint )
  
  This method will dispatch the given $request object.  Normally this
  will be an instance of the C<HTTP::Request> class, but any object with
  a similar interface will do.  The return value is a response object.
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  interface provided by these classes.
  
  The request() method will process redirects and authentication
  responses transparently.  This means that it may actually send several
  simple requests via the simple_request() method described below.
  
  The request methods described above; get(), head(), post() and
  mirror(), will all dispatch the request they build via this method.
  They are convenience methods that simply hides the creation of the
  request object for you.
  
  The $content_file, $content_cb and $read_size_hint all correspond to
  options described with the get() method above.
  
  You are allowed to use a CODE reference as C<content> in the request
  object passed in.  The C<content> function should return the content
  when called.  The content can be returned in chunks.  The content
  function will be invoked repeatedly until it return an empty string to
  signal that there is no more content.
  
  =item $ua->simple_request( $request )
  
  =item $ua->simple_request( $request, $content_file )
  
  =item $ua->simple_request( $request, $content_cb )
  
  =item $ua->simple_request( $request, $content_cb, $read_size_hint )
  
  This method dispatches a single request and returns the response
  received.  Arguments are the same as for request() described above.
  
  The difference from request() is that simple_request() will not try to
  handle redirects or authentication responses.  The request() method
  will in fact invoke this method for each simple request it sends.
  
  =item $ua->is_online
  
  Tries to determine if you have access to the Internet.  Returns
  TRUE if the built-in heuristics determine that the user agent is
  able to access the Internet (over HTTP).  See also L<LWP::Online>.
  
  =item $ua->is_protocol_supported( $scheme )
  
  You can use this method to test whether this user agent object supports the
  specified C<scheme>.  (The C<scheme> might be a string (like 'http' or
  'ftp') or it might be an URI object reference.)
  
  Whether a scheme is supported, is determined by the user agent's
  C<protocols_allowed> or C<protocols_forbidden> lists (if any), and by
  the capabilities of LWP.  I.e., this will return TRUE only if LWP
  supports this protocol I<and> it's permitted for this particular
  object.
  
  =back
  
  =head2 Callback methods
  
  The following methods will be invoked as requests are processed. These
  methods are documented here because subclasses of C<LWP::UserAgent>
  might want to override their behaviour.
  
  =over
  
  =item $ua->prepare_request( $request )
  
  This method is invoked by simple_request().  Its task is to modify the
  given $request object by setting up various headers based on the
  attributes of the user agent. The return value should normally be the
  $request object passed in.  If a different request object is returned
  it will be the one actually processed.
  
  The headers affected by the base implementation are; "User-Agent",
  "From", "Range" and "Cookie".
  
  =item $ua->redirect_ok( $prospective_request, $response )
  
  This method is called by request() before it tries to follow a
  redirection to the request in $response.  This should return a TRUE
  value if this redirection is permissible.  The $prospective_request
  will be the request to be sent if this method returns TRUE.
  
  The base implementation will return FALSE unless the method
  is in the object's C<requests_redirectable> list,
  FALSE if the proposed redirection is to a "file://..."
  URL, and TRUE otherwise.
  
  =item $ua->get_basic_credentials( $realm, $uri, $isproxy )
  
  This is called by request() to retrieve credentials for documents
  protected by Basic or Digest Authentication.  The arguments passed in
  is the $realm provided by the server, the $uri requested and a boolean
  flag to indicate if this is authentication against a proxy server.
  
  The method should return a username and password.  It should return an
  empty list to abort the authentication resolution attempt.  Subclasses
  can override this method to prompt the user for the information. An
  example of this can be found in C<lwp-request> program distributed
  with this library.
  
  The base implementation simply checks a set of pre-stored member
  variables, set up with the credentials() method.
  
  =item $ua->progress( $status, $request_or_response )
  
  This is called frequently as the response is received regardless of
  how the content is processed.  The method is called with $status
  "begin" at the start of processing the request and with $state "end"
  before the request method returns.  In between these $status will be
  the fraction of the response currently received or the string "tick"
  if the fraction can't be calculated.
  
  When $status is "begin" the second argument is the request object,
  otherwise it is the response object.
  
  =back
  
  =head1 SEE ALSO
  
  See L<LWP> for a complete overview of libwww-perl5.  See L<lwpcook>
  and the scripts F<lwp-request> and F<lwp-download> for examples of
  usage.
  
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  message objects dispatched and received.  See L<HTTP::Request::Common>
  and L<HTML::Form> for other ways to build request objects.
  
  See L<WWW::Mechanize> and L<WWW::Search> for examples of more
  specialized user agents based on C<LWP::UserAgent>.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_USERAGENT

$fatpacked{"Test/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER';
  package Test::Builder;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN {
      if( $] < 5.008 ) {
          require Test::Builder::IO::Scalar;
      }
  }
  
  use Scalar::Util qw/blessed reftype weaken/;
  
  use Test2::Util qw/USE_THREADS try get_tid/;
  use Test2::API qw/context release/;
  # Make Test::Builder thread-safe for ithreads.
  BEGIN {
      warn "Test::Builder was loaded after Test2 initialization, this is not recommended."
          if Test2::API::test2_init_done() || Test2::API::test2_load_done();
  
      if (USE_THREADS && ! Test2::API::test2_ipc_disabled()) {
          require Test2::IPC;
          require Test2::IPC::Driver::Files;
          Test2::IPC::Driver::Files->import;
          Test2::API::test2_ipc_enable_polling();
          Test2::API::test2_no_wait(1);
          Test2::API::test2_ipc_enable_shm();
      }
  }
  
  use Test2::Event::Subtest;
  use Test2::Hub::Subtest;
  
  use Test::Builder::Formatter;
  use Test::Builder::TodoDiag;
  
  our $Level = 1;
  our $Test = $ENV{TB_NO_EARLY_INIT} ? undef : Test::Builder->new;
  
  sub _add_ts_hooks {
      my $self = shift;
  
      my $hub = $self->{Stack}->top;
  
      # Take a reference to the hash key, we do this to avoid closing over $self
      # which is the singleton. We use a reference because the value could change
      # in rare cases.
      my $epkgr = \$self->{Exported_To};
  
      #$hub->add_context_aquire(sub {$_[0]->{level} += $Level - 1});
  
      $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          my $epkg = $$epkgr;
          my $cpkg = $e->{trace} ? $e->{trace}->{frame}->[0] : undef;
  
          no strict 'refs';
          no warnings 'once';
          my $todo;
          $todo = ${"$cpkg\::TODO"} if $cpkg;
          $todo = ${"$epkg\::TODO"} if $epkg && !$todo;
  
          return $e unless $todo;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          if ($active_hub == $hub) {
              $e->set_todo($todo) if $e->can('set_todo');
              $e->add_amnesty({tag => 'TODO', details => $todo});
          }
          else {
              $e->add_amnesty({tag => 'TODO', details => $todo, inherited => 1});
          }
  
          # Set todo on ok's
          if ($e->isa('Test2::Event::Ok')) {
              $e->set_effective_pass(1);
  
              if (my $result = $e->get_meta(__PACKAGE__)) {
                  $result->{reason} ||= $todo;
                  $result->{type}   ||= 'todo';
                  $result->{ok}       = 1;
              }
          }
  
          return $e;
      }, inherit => 1);
  }
  
  {
      no warnings;
      INIT {
          use warnings;
          Test2::API::test2_load() unless Test2::API::test2_in_preload();
      }
  }
  
  sub new {
      my($class) = shift;
      unless($Test) {
          $Test = $class->create(singleton => 1);
  
          Test2::API::test2_add_callback_post_load(
              sub {
                  $Test->{Original_Pid} = $$ if !$Test->{Original_Pid} || $Test->{Original_Pid} == 0;
                  $Test->reset(singleton => 1);
                  $Test->_add_ts_hooks;
              }
          );
  
          # Non-TB tools normally expect 0 added to the level. $Level is normally 1. So
          # we only want the level to change if $Level != 1.
          # TB->ctx compensates for this later.
          Test2::API::test2_add_callback_context_aquire(sub { $_[0]->{level} += $Level - 1 });
  
          Test2::API::test2_add_callback_exit(sub { $Test->_ending(@_) });
  
          Test2::API::test2_ipc()->set_no_fatal(1) if Test2::API::test2_has_ipc();
      }
      return $Test;
  }
  
  sub create {
      my $class = shift;
      my %params = @_;
  
      my $self = bless {}, $class;
      if ($params{singleton}) {
          $self->{Stack} = Test2::API::test2_stack();
      }
      else {
          $self->{Stack} = Test2::API::Stack->new;
          $self->{Stack}->new_hub(
              formatter => Test::Builder::Formatter->new,
              ipc       => Test2::API::test2_ipc(),
          );
  
          $self->reset(%params);
          $self->_add_ts_hooks;
      }
  
      return $self;
  }
  
  sub ctx {
      my $self = shift;
      context(
          # 1 for our frame, another for the -1 off of $Level in our hook at the top.
          level   => 2,
          fudge   => 1,
          stack   => $self->{Stack},
          hub     => $self->{Hub},
          wrapped => 1,
          @_
      );
  }
  
  sub parent {
      my $self = shift;
      my $ctx = $self->ctx;
      my $chub = $self->{Hub} || $ctx->hub;
      $ctx->release;
  
      my $meta = $chub->meta(__PACKAGE__, {});
      my $parent = $meta->{parent};
  
      return undef unless $parent;
  
      return bless {
          Original_Pid => $$,
          Stack => $self->{Stack},
          Hub => $parent,
      }, blessed($self);
  }
  
  sub child {
      my( $self, $name ) = @_;
  
      $name ||= "Child of " . $self->name;
      my $ctx = $self->ctx;
  
      my $parent = $ctx->hub;
      my $pmeta = $parent->meta(__PACKAGE__, {});
      $self->croak("You already have a child named ($pmeta->{child}) running")
          if $pmeta->{child};
  
      $pmeta->{child} = $name;
  
      # Clear $TODO for the child.
      my $orig_TODO = $self->find_TODO(undef, 1, undef);
  
      my $subevents = [];
  
      my $hub = $ctx->stack->new_hub(
          class => 'Test2::Hub::Subtest',
      );
  
      $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          return $e;
      }, inherit => 1) if $orig_TODO;
  
      $hub->listen(sub { push @$subevents => $_[1] });
  
      $hub->set_nested( $parent->nested + 1 );
  
      my $meta = $hub->meta(__PACKAGE__, {});
      $meta->{Name} = $name;
      $meta->{TODO} = $orig_TODO;
      $meta->{TODO_PKG} = $ctx->trace->package;
      $meta->{parent} = $parent;
      $meta->{Test_Results} = [];
      $meta->{subevents} = $subevents;
      $meta->{subtest_id} = $hub->id;
      $meta->{subtest_uuid} = $hub->uuid;
      $meta->{subtest_buffered} = $parent->format ? 0 : 1;
  
      $self->_add_ts_hooks;
  
      $ctx->release;
      return bless { Original_Pid => $$, Stack => $self->{Stack}, Hub => $hub, no_log_results => $self->{no_log_results} }, blessed($self);
  }
  
  sub finalize {
      my $self = shift;
      my $ok = 1;
      ($ok) = @_ if @_;
  
      my $st_ctx = $self->ctx;
      my $chub = $self->{Hub} || return $st_ctx->release;
  
      my $meta = $chub->meta(__PACKAGE__, {});
      if ($meta->{child}) {
          $self->croak("Can't call finalize() with child ($meta->{child}) active");
      }
  
      local $? = 0;     # don't fail if $subtests happened to set $? nonzero
  
      $self->{Stack}->pop($chub);
  
      $self->find_TODO($meta->{TODO_PKG}, 1, $meta->{TODO});
  
      my $parent = $self->parent;
      my $ctx = $parent->ctx;
      my $trace = $ctx->trace;
      delete $ctx->hub->meta(__PACKAGE__, {})->{child};
  
      $chub->finalize($trace->snapshot(hid => $chub->hid, nested => $chub->nested), 1)
          if $ok
          && $chub->count
          && !$chub->no_ending
          && !$chub->ended;
  
      my $plan   = $chub->plan || 0;
      my $count  = $chub->count;
      my $failed = $chub->failed;
      my $passed = $chub->is_passing;
  
      my $num_extra = $plan =~ m/\D/ ? 0 : $count - $plan;
      if ($count && $num_extra != 0) {
          my $s = $plan == 1 ? '' : 's';
          $st_ctx->diag(<<"FAIL");
  Looks like you planned $plan test$s but ran $count.
  FAIL
      }
  
      if ($failed) {
          my $s = $failed == 1 ? '' : 's';
  
          my $qualifier = $num_extra == 0 ? '' : ' run';
  
          $st_ctx->diag(<<"FAIL");
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
      }
  
      if (!$passed && !$failed && $count && !$num_extra) {
          $st_ctx->diag(<<"FAIL");
  All assertions inside the subtest passed, but errors were encountered.
  FAIL
      }
  
      $st_ctx->release;
  
      unless ($chub->bailed_out) {
          my $plan = $chub->plan;
          if ( $plan && $plan eq 'SKIP' ) {
              $parent->skip($chub->skip_reason, $meta->{Name});
          }
          elsif ( !$chub->count ) {
              $parent->ok( 0, sprintf q[No tests run for subtest "%s"], $meta->{Name} );
          }
          else {
              $parent->{subevents}  = $meta->{subevents};
              $parent->{subtest_id} = $meta->{subtest_id};
              $parent->{subtest_uuid} = $meta->{subtest_uuid};
              $parent->{subtest_buffered} = $meta->{subtest_buffered};
              $parent->ok( $chub->is_passing, $meta->{Name} );
          }
      }
  
      $ctx->release;
      return $chub->is_passing;
  }
  
  sub subtest {
      my $self = shift;
      my ($name, $code, @args) = @_;
      my $ctx = $self->ctx;
      $ctx->throw("subtest()'s second argument must be a code ref")
          unless $code && reftype($code) eq 'CODE';
  
      $name ||= "Child of " . $self->name;
  
  
      $_->($name,$code,@args)
          for Test2::API::test2_list_pre_subtest_callbacks();
  
      $ctx->note("Subtest: $name");
  
      my $child = $self->child($name);
  
      my $start_pid = $$;
      my $st_ctx;
      my ($ok, $err, $finished, $child_error);
      T2_SUBTEST_WRAPPER: {
          my $ctx = $self->ctx;
          $st_ctx = $ctx->snapshot;
          $ctx->release;
          $ok = eval { local $Level = 1; $code->(@args); 1 };
          ($err, $child_error) = ($@, $?);
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && blessed($err) eq 'Test::Builder::Exception')) {
              $ok  = undef;
              $err = undef;
          }
          else {
              $finished = 1;
          }
      }
  
      if ($start_pid != $$ && !$INC{'Test2/IPC.pm'}) {
          warn $ok ? "Forked inside subtest, but subtest never finished!\n" : $err;
          exit 255;
      }
  
      my $trace = $ctx->trace;
  
      if (!$finished) {
          if(my $bailed = $st_ctx->hub->bailed_out) {
              my $chub = $child->{Hub};
              $self->{Stack}->pop($chub);
              $ctx->bail($bailed->reason);
          }
          my $code = $st_ctx->hub->exit_code;
          $ok = !$code;
          $err = "Subtest ended with exit code $code" if $code;
      }
  
      my $st_hub  = $st_ctx->hub;
      my $plan  = $st_hub->plan;
      my $count = $st_hub->count;
  
      if (!$count && (!defined($plan) || "$plan" ne 'SKIP')) {
          $st_ctx->plan(0) unless defined $plan;
          $st_ctx->diag('No tests run!');
      }
  
      $child->finalize($st_ctx->trace);
  
      $ctx->release;
  
      die $err unless $ok;
  
      $? = $child_error if defined $child_error;
  
      return $st_hub->is_passing;
  }
  
  sub name {
      my $self = shift;
      my $ctx = $self->ctx;
      release $ctx, $ctx->hub->meta(__PACKAGE__, {})->{Name};
  }
  
  sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my ($self, %params) = @_;
  
      Test2::API::test2_set_is_end(0);
  
      # We leave this a global because it has to be localized and localizing
      # hash keys is just asking for pain.  Also, it was documented.
      $Level = 1;
  
      $self->{no_log_results} = $ENV{TEST_NO_LOG_RESULTS} ? 1 : 0
          unless $params{singleton};
  
      $self->{Original_Pid} = Test2::API::test2_in_preload() ? -1 : $$;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
      $ctx->release;
      unless ($params{singleton}) {
          $hub->reset_state();
          $hub->_tb_reset();
      }
  
      $ctx = $self->ctx;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {});
      %$meta = (
          Name         => $0,
          Ending       => 0,
          Done_Testing => undef,
          Skip_All     => 0,
          Test_Results => [],
          parent       => $meta->{parent},
      );
  
      $self->{Exported_To} = undef unless $params{singleton};
  
      $self->{Orig_Handles} ||= do {
          my $format = $ctx->hub->format;
          my $out;
          if ($format && $format->isa('Test2::Formatter::TAP')) {
              $out = $format->handles;
          }
          $out ? [@$out] : [];
      };
  
      $self->use_numbers(1);
      $self->no_header(0) unless $params{singleton};
      $self->no_ending(0) unless $params{singleton};
      $self->reset_outputs;
  
      $ctx->release;
  
      return;
  }
  
  
  my %plan_cmds = (
      no_plan  => \&no_plan,
      skip_all => \&skip_all,
      tests    => \&_plan_tests,
  );
  
  sub plan {
      my( $self, $cmd, $arg ) = @_;
  
      return unless $cmd;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      $ctx->throw("You tried to plan twice") if $hub->plan;
  
      local $Level = $Level + 1;
  
      if( my $method = $plan_cmds{$cmd} ) {
          local $Level = $Level + 1;
          $self->$method($arg);
      }
      else {
          my @args = grep { defined } ( $cmd, $arg );
          $ctx->throw("plan() doesn't understand @args");
      }
  
      release $ctx, 1;
  }
  
  
  sub _plan_tests {
      my($self, $arg) = @_;
  
      my $ctx = $self->ctx;
  
      if($arg) {
          local $Level = $Level + 1;
          $self->expected_tests($arg);
      }
      elsif( !defined $arg ) {
          $ctx->throw("Got an undefined number of tests");
      }
      else {
          $ctx->throw("You said to run 0 tests");
      }
  
      $ctx->release;
  }
  
  
  sub expected_tests {
      my $self = shift;
      my($max) = @_;
  
      my $ctx = $self->ctx;
  
      if(@_) {
          $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
            unless $max =~ /^\+?\d+$/;
  
          $ctx->plan($max);
      }
  
      my $hub = $ctx->hub;
  
      $ctx->release;
  
      my $plan = $hub->plan;
      return 0 unless $plan;
      return 0 if $plan =~ m/\D/;
      return $plan;
  }
  
  
  sub no_plan {
      my($self, $arg) = @_;
  
      my $ctx = $self->ctx;
  
      if (defined $ctx->hub->plan) {
          warn "Plan already set, no_plan() is a no-op, this will change to a hard failure in the future.";
          $ctx->release;
          return;
      }
  
      $ctx->alert("no_plan takes no arguments") if $arg;
  
      $ctx->hub->plan('NO PLAN');
  
      release $ctx, 1;
  }
  
  
  sub done_testing {
      my($self, $num_tests) = @_;
  
      my $ctx = $self->ctx;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {});
  
      if ($meta->{Done_Testing}) {
          my ($file, $line) = @{$meta->{Done_Testing}}[1,2];
          local $ctx->hub->{ended}; # OMG This is awful.
          $self->ok(0, "done_testing() was already called at $file line $line");
          $ctx->release;
          return;
      }
      $meta->{Done_Testing} = [$ctx->trace->call];
  
      my $plan = $ctx->hub->plan;
      my $count = $ctx->hub->count;
  
      # If done_testing() specified the number of tests, shut off no_plan
      if( defined $num_tests ) {
          $ctx->plan($num_tests) if !$plan || $plan eq 'NO PLAN';
      }
      elsif ($count && defined $num_tests && $count != $num_tests) {
          $self->ok(0, "planned to run @{[ $self->expected_tests ]} but done_testing() expects $num_tests");
      }
      else {
          $num_tests = $self->current_test;
      }
  
      if( $self->expected_tests && $num_tests != $self->expected_tests ) {
          $self->ok(0, "planned to run @{[ $self->expected_tests ]} ".
                       "but done_testing() expects $num_tests");
      }
  
      $ctx->plan($num_tests) if $ctx->hub->plan && $ctx->hub->plan eq 'NO PLAN';
  
      $ctx->hub->finalize($ctx->trace, 1);
  
      release $ctx, 1;
  }
  
  
  sub has_plan {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $plan = $ctx->hub->plan;
      $ctx->release;
  
      return( $plan ) if $plan && $plan !~ m/\D/;
      return('no_plan') if $plan && $plan eq 'NO PLAN';
      return(undef);
  }
  
  
  sub skip_all {
      my( $self, $reason ) = @_;
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Skip_All} = $reason || 1;
  
      # Work around old perl bug
      if ($] < 5.020000) {
          my $begin = 0;
          my $level = 0;
          while (my @call = caller($level++)) {
              last unless @call && $call[0];
              next unless $call[3] =~ m/::BEGIN$/;
              $begin++;
              last;
          }
          # HACK!
          die 'Label not found for "last T2_SUBTEST_WRAPPER"' if $begin && $ctx->hub->meta(__PACKAGE__, {})->{parent};
      }
  
      $ctx->plan(0, SKIP => $reason);
  }
  
  
  sub exported_to {
      my( $self, $pack ) = @_;
  
      if( defined $pack ) {
          $self->{Exported_To} = $pack;
      }
      return $self->{Exported_To};
  }
  
  
  sub ok {
      my( $self, $test, $name ) = @_;
  
      my $ctx = $self->ctx;
  
      # $test might contain an object which we don't want to accidentally
      # store, so we turn it into a boolean.
      $test = $test ? 1 : 0;
  
      # In case $name is a string overloaded object, force it to stringify.
      no  warnings qw/uninitialized numeric/;
      $name = "$name" if defined $name;
  
      # Profiling showed that the regex here was a huge time waster, doing the
      # numeric addition first cuts our profile time from ~300ms to ~50ms
      $self->diag(<<"    ERR") if 0 + $name && $name =~ /^[\d\s]+$/;
      You named your test '$name'.  You shouldn't use numbers for your test names.
      Very confusing.
      ERR
      use warnings qw/uninitialized numeric/;
  
      my $trace = $ctx->{trace};
      my $hub   = $ctx->{hub};
  
      my $result = {
          ok => $test,
          actual_ok => $test,
          reason => '',
          type => '',
          (name => defined($name) ? $name : ''),
      };
  
      $hub->{_meta}->{+__PACKAGE__}->{Test_Results}[ $hub->{count} ] = $result unless $self->{no_log_results};
  
      my $orig_name = $name;
  
      my @attrs;
      my $subevents  = delete $self->{subevents};
      my $subtest_id = delete $self->{subtest_id};
      my $subtest_uuid = delete $self->{subtest_uuid};
      my $subtest_buffered = delete $self->{subtest_buffered};
      my $epkg = 'Test2::Event::Ok';
      if ($subevents) {
          $epkg = 'Test2::Event::Subtest';
          push @attrs => (subevents => $subevents, subtest_id => $subtest_id, subtest_uuid => $subtest_uuid, buffered => $subtest_buffered);
      }
  
      my $e = bless {
          trace => bless( {%$trace}, 'Test2::EventFacet::Trace'),
          pass  => $test,
          name  => $name,
          _meta => {'Test::Builder' => $result},
          effective_pass => $test,
          @attrs,
      }, $epkg;
      $hub->send($e);
  
      $self->_ok_debug($trace, $orig_name) unless($test);
  
      $ctx->release;
      return $test;
  }
  
  sub _ok_debug {
      my $self = shift;
      my ($trace, $orig_name) = @_;
  
      my $is_todo = defined($self->todo);
  
      my $msg = $is_todo ? "Failed (TODO)" : "Failed";
  
      my (undef, $file, $line) = $trace->call;
      if (defined $orig_name) {
          $self->diag(qq[  $msg test '$orig_name'\n  at $file line $line.\n]);
      }
      else {
          $self->diag(qq[  $msg test at $file line $line.\n]);
      }
  }
  
  sub _diag_fh {
      my $self = shift;
      local $Level = $Level + 1;
      return $self->in_todo ? $self->todo_output : $self->failure_output;
  }
  
  sub _unoverload {
      my ($self, $type, $thing) = @_;
  
      return unless ref $$thing;
      return unless blessed($$thing) || scalar $self->_try(sub{ $$thing->isa('UNIVERSAL') });
      {
          local ($!, $@);
          require overload;
      }
      my $string_meth = overload::Method( $$thing, $type ) || return;
      $$thing = $$thing->$string_meth();
  }
  
  sub _unoverload_str {
      my $self = shift;
  
      $self->_unoverload( q[""], $_ ) for @_;
  }
  
  sub _unoverload_num {
      my $self = shift;
  
      $self->_unoverload( '0+', $_ ) for @_;
  
      for my $val (@_) {
          next unless $self->_is_dualvar($$val);
          $$val = $$val + 0;
      }
  }
  
  # This is a hack to detect a dualvar such as $!
  sub _is_dualvar {
      my( $self, $val ) = @_;
  
      # Objects are not dualvars.
      return 0 if ref $val;
  
      no warnings 'numeric';
      my $numval = $val + 0;
      return ($numval != 0 and $numval ne $val ? 1 : 0);
  }
  
  
  sub is_eq {
      my( $self, $got, $expect, $name ) = @_;
  
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, 'eq', $expect ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, 'eq', $expect, $name );
  }
  
  
  sub is_num {
      my( $self, $got, $expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, '==', $expect ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, '==', $expect, $name );
  }
  
  
  sub _diag_fmt {
      my( $self, $type, $val ) = @_;
  
      if( defined $$val ) {
          if( $type eq 'eq' or $type eq 'ne' ) {
              # quote and force string context
              $$val = "'$$val'";
          }
          else {
              # force numeric context
              $self->_unoverload_num($val);
          }
      }
      else {
          $$val = 'undef';
      }
  
      return;
  }
  
  
  sub _is_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $self->_diag_fmt( $type, $_ ) for \$got, \$expect;
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: $expect
  DIAGNOSTIC
  
  }
  
  sub _isnt_diag {
      my( $self, $got, $type ) = @_;
  
      $self->_diag_fmt( $type, \$got );
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: anything else
  DIAGNOSTIC
  }
  
  
  sub isnt_eq {
      my( $self, $got, $dont_expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, 'ne' ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, 'ne', $dont_expect, $name );
  }
  
  sub isnt_num {
      my( $self, $got, $dont_expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, '!=' ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, '!=', $dont_expect, $name );
  }
  
  
  sub like {
      my( $self, $thing, $regex, $name ) = @_;
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      release $ctx, $self->_regex_ok( $thing, $regex, '=~', $name );
  }
  
  sub unlike {
      my( $self, $thing, $regex, $name ) = @_;
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      release $ctx, $self->_regex_ok( $thing, $regex, '!~', $name );
  }
  
  
  my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );
  
  # Bad, these are not comparison operators. Should we include more?
  my %cmp_ok_bl = map { ( $_, 1 ) } ( "=", "+=", ".=", "x=", "^=", "|=", "||=", "&&=", "...");
  
  sub cmp_ok {
      my( $self, $got, $type, $expect, $name ) = @_;
      my $ctx = $self->ctx;
  
      if ($cmp_ok_bl{$type}) {
          $ctx->throw("$type is not a valid comparison operator in cmp_ok()");
      }
  
      my ($test, $succ);
      my $error;
      {
          ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
          my($pack, $file, $line) = $ctx->trace->call();
  
          # This is so that warnings come out at the caller's level
          $succ = eval qq[
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $type \$expect);
  1;
  ];
          $error = $@;
      }
      local $Level = $Level + 1;
      my $ok = $self->ok( $test, $name );
  
      # Treat overloaded objects as numbers if we're asked to do a
      # numeric comparison.
      my $unoverload
        = $numeric_cmps{$type}
        ? '_unoverload_num'
        : '_unoverload_str';
  
      $self->diag(<<"END") unless $succ;
  An error occurred while using $type:
  ------------------------------------
  $error
  ------------------------------------
  END
  
      unless($ok) {
          $self->$unoverload( \$got, \$expect );
  
          if( $type =~ /^(eq|==)$/ ) {
              $self->_is_diag( $got, $type, $expect );
          }
          elsif( $type =~ /^(ne|!=)$/ ) {
              no warnings;
              my $eq = ($got eq $expect || $got == $expect)
                  && (
                      (defined($got) xor defined($expect))
                   || (length($got)  !=  length($expect))
                  );
              use warnings;
  
              if ($eq) {
                  $self->_cmp_diag( $got, $type, $expect );
              }
              else {
                  $self->_isnt_diag( $got, $type );
              }
          }
          else {
              $self->_cmp_diag( $got, $type, $expect );
          }
      }
      return release $ctx, $ok;
  }
  
  sub _cmp_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $got    = defined $got    ? "'$got'"    : 'undef';
      $expect = defined $expect ? "'$expect'" : 'undef';
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
      $got
          $type
      $expect
  DIAGNOSTIC
  }
  
  sub _caller_context {
      my $self = shift;
  
      my( $pack, $file, $line ) = $self->caller(1);
  
      my $code = '';
      $code .= "#line $line $file\n" if defined $file and defined $line;
  
      return $code;
  }
  
  
  sub BAIL_OUT {
      my( $self, $reason ) = @_;
  
      my $ctx = $self->ctx;
  
      $self->{Bailed_Out} = 1;
  
      $ctx->bail($reason);
  }
  
  
  {
      no warnings 'once';
      *BAILOUT = \&BAIL_OUT;
  }
  
  sub skip {
      my( $self, $why, $name ) = @_;
      $why ||= '';
      $name = '' unless defined $name;
      $self->_unoverload_str( \$why );
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Test_Results}[ $ctx->hub->count ] = {
          'ok'      => 1,
          actual_ok => 1,
          name      => $name,
          type      => 'skip',
          reason    => $why,
      } unless $self->{no_log_results};
  
      $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
      $name =~ s{\n}{\n# }sg;
      $why =~ s{\n}{\n# }sg;
  
      my $tctx = $ctx->snapshot;
      $tctx->skip('', $why);
  
      return release $ctx, 1;
  }
  
  
  sub todo_skip {
      my( $self, $why ) = @_;
      $why ||= '';
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Test_Results}[ $ctx->hub->count ] = {
          'ok'      => 1,
          actual_ok => 0,
          name      => '',
          type      => 'todo_skip',
          reason    => $why,
      } unless $self->{no_log_results};
  
      $why =~ s{\n}{\n# }sg;
      my $tctx = $ctx->snapshot;
      $tctx->send_event( 'Skip', todo => $why, todo_diag => 1, reason => $why, pass => 0);
  
      return release $ctx, 1;
  }
  
  
  sub maybe_regex {
      my( $self, $regex ) = @_;
      my $usable_regex = undef;
  
      return $usable_regex unless defined $regex;
  
      my( $re, $opts );
  
      # Check for qr/foo/
      if( _is_qr($regex) ) {
          $usable_regex = $regex;
      }
      # Check for '/foo/' or 'm,foo,'
      elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
            ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
      )
      {
          $usable_regex = length $opts ? "(?$opts)$re" : $re;
      }
  
      return $usable_regex;
  }
  
  sub _is_qr {
      my $regex = shift;
  
      # is_regexp() checks for regexes in a robust manner, say if they're
      # blessed.
      return re::is_regexp($regex) if defined &re::is_regexp;
      return ref $regex eq 'Regexp';
  }
  
  sub _regex_ok {
      my( $self, $thing, $regex, $cmp, $name ) = @_;
  
      my $ok           = 0;
      my $usable_regex = $self->maybe_regex($regex);
      unless( defined $usable_regex ) {
          local $Level = $Level + 1;
          $ok = $self->ok( 0, $name );
          $self->diag("    '$regex' doesn't look much like a regex to me.");
          return $ok;
      }
  
      {
          my $test;
          my $context = $self->_caller_context;
  
          {
              ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
              local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
              # No point in issuing an uninit warning, they'll see it in the diagnostics
              no warnings 'uninitialized';
  
              $test = eval $context . q{$test = $thing =~ /$usable_regex/ ? 1 : 0};
          }
  
          $test = !$test if $cmp eq '!~';
  
          local $Level = $Level + 1;
          $ok = $self->ok( $test, $name );
      }
  
      unless($ok) {
          $thing = defined $thing ? "'$thing'" : 'undef';
          my $match = $cmp eq '=~' ? "doesn't match" : "matches";
  
          local $Level = $Level + 1;
          $self->diag( sprintf <<'DIAGNOSTIC', $thing, $match, $regex );
                    %s
      %13s '%s'
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  
  sub is_fh {
      my $self     = shift;
      my $maybe_fh = shift;
      return 0 unless defined $maybe_fh;
  
      return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
      return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob
  
      return eval { $maybe_fh->isa("IO::Handle") } ||
             eval { tied($maybe_fh)->can('TIEHANDLE') };
  }
  
  
  sub level {
      my( $self, $level ) = @_;
  
      if( defined $level ) {
          $Level = $level;
      }
      return $Level;
  }
  
  
  sub use_numbers {
      my( $self, $use_nums ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      unless ($format && $format->can('no_numbers') && $format->can('set_no_numbers')) {
          warn "The current formatter does not support 'use_numbers'" if $format;
          return release $ctx, 0;
      }
  
      $format->set_no_numbers(!$use_nums) if defined $use_nums;
  
      return release $ctx, $format->no_numbers ? 0 : 1;
  }
  
  BEGIN {
      for my $method (qw(no_header no_diag)) {
          my $set = "set_$method";
          my $code = sub {
              my( $self, $no ) = @_;
  
              my $ctx = $self->ctx;
              my $format = $ctx->hub->format;
              unless ($format && $format->can($set)) {
                  warn "The current formatter does not support '$method'" if $format;
                  $ctx->release;
                  return
              }
  
              $format->$set($no) if defined $no;
  
              return release $ctx, $format->$method ? 1 : 0;
          };
  
          no strict 'refs';    ## no critic
          *$method = $code;
      }
  }
  
  sub no_ending {
      my( $self, $no ) = @_;
  
      my $ctx = $self->ctx;
  
      $ctx->hub->set_no_ending($no) if defined $no;
  
      return release $ctx, $ctx->hub->no_ending;
  }
  
  sub diag {
      my $self = shift;
      return unless @_;
  
      my $text = join '' => map {defined($_) ? $_ : 'undef'} @_;
  
      if (Test2::API::test2_in_preload()) {
          chomp($text);
          $text =~ s/^/# /msg;
          print STDERR $text, "\n";
          return 0;
      }
  
      my $ctx = $self->ctx;
      $ctx->diag($text);
      $ctx->release;
      return 0;
  }
  
  
  sub note {
      my $self = shift;
      return unless @_;
  
      my $text = join '' => map {defined($_) ? $_ : 'undef'} @_;
  
      if (Test2::API::test2_in_preload()) {
          chomp($text);
          $text =~ s/^/# /msg;
          print STDOUT $text, "\n";
          return 0;
      }
  
      my $ctx = $self->ctx;
      $ctx->note($text);
      $ctx->release;
      return 0;
  }
  
  
  sub explain {
      my $self = shift;
  
      local ($@, $!);
      require Data::Dumper;
  
      return map {
          ref $_
            ? do {
              my $dumper = Data::Dumper->new( [$_] );
              $dumper->Indent(1)->Terse(1);
              $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
              $dumper->Dump;
            }
            : $_
      } @_;
  }
  
  
  sub output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
  
      $format->handles->[Test2::Formatter::TAP::OUT_STD()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test2::Formatter::TAP::OUT_STD()];
  }
  
  sub failure_output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
  
      $format->handles->[Test2::Formatter::TAP::OUT_ERR()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test2::Formatter::TAP::OUT_ERR()];
  }
  
  sub todo_output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test::Builder::Formatter');
  
      $format->handles->[Test::Builder::Formatter::OUT_TODO()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test::Builder::Formatter::OUT_TODO()];
  }
  
  sub _new_fh {
      my $self = shift;
      my($file_or_fh) = shift;
  
      my $fh;
      if( $self->is_fh($file_or_fh) ) {
          $fh = $file_or_fh;
      }
      elsif( ref $file_or_fh eq 'SCALAR' ) {
          # Scalar refs as filehandles was added in 5.8.
          if( $] >= 5.008 ) {
              open $fh, ">>", $file_or_fh
                or $self->croak("Can't open scalar ref $file_or_fh: $!");
          }
          # Emulate scalar ref filehandles with a tie.
          else {
              $fh = Test::Builder::IO::Scalar->new($file_or_fh)
                or $self->croak("Can't tie scalar ref $file_or_fh");
          }
      }
      else {
          open $fh, ">", $file_or_fh
            or $self->croak("Can't open test output log $file_or_fh: $!");
          _autoflush($fh);
      }
  
      return $fh;
  }
  
  sub _autoflush {
      my($fh) = shift;
      my $old_fh = select $fh;
      $| = 1;
      select $old_fh;
  
      return;
  }
  
  
  sub reset_outputs {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
      $format->set_handles([@{$self->{Orig_Handles}}]) if $self->{Orig_Handles};
  
      return;
  }
  
  
  sub carp {
      my $self = shift;
      my $ctx = $self->ctx;
      $ctx->alert(join "", @_);
      $ctx->release;
  }
  
  sub croak {
      my $self = shift;
      my $ctx = $self->ctx;
      $ctx->throw(join "", @_);
      $ctx->release;
  }
  
  
  sub current_test {
      my( $self, $num ) = @_;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      if( defined $num ) {
          $hub->set_count($num);
  
          unless ($self->{no_log_results}) {
              # If the test counter is being pushed forward fill in the details.
              my $test_results = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
              if ($num > @$test_results) {
                  my $start = @$test_results ? @$test_results : 0;
                  for ($start .. $num - 1) {
                      $test_results->[$_] = {
                          'ok'      => 1,
                          actual_ok => undef,
                          reason    => 'incrementing test number',
                          type      => 'unknown',
                          name      => undef
                      };
                  }
              }
              # If backward, wipe history.  Its their funeral.
              elsif ($num < @$test_results) {
                  $#{$test_results} = $num - 1;
              }
          }
      }
      return release $ctx, $hub->count;
  }
  
  
  sub is_passing {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      if( @_ ) {
          my ($bool) = @_;
          $hub->set_failed(0) if $bool;
          $hub->is_passing($bool);
      }
  
      return release $ctx, $hub->is_passing;
  }
  
  
  sub summary {
      my($self) = shift;
  
      return if $self->{no_log_results};
  
      my $ctx = $self->ctx;
      my $data = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
      $ctx->release;
      return map { $_ ? $_->{'ok'} : () } @$data;
  }
  
  
  sub details {
      my $self = shift;
  
      return if $self->{no_log_results};
  
      my $ctx = $self->ctx;
      my $data = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
      $ctx->release;
      return @$data;
  }
  
  
  sub find_TODO {
      my( $self, $pack, $set, $new_value ) = @_;
  
      my $ctx = $self->ctx;
  
      $pack ||= $ctx->trace->package || $self->exported_to;
      $ctx->release;
  
      return unless $pack;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      my $old_value = ${ $pack . '::TODO' };
      $set and ${ $pack . '::TODO' } = $new_value;
      return $old_value;
  }
  
  sub todo {
      my( $self, $pack ) = @_;
  
      local $Level = $Level + 1;
      my $ctx = $self->ctx;
      $ctx->release;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {todo => []})->{todo};
      return $meta->[-1]->[1] if $meta && @$meta;
  
      $pack ||= $ctx->trace->package;
  
      return unless $pack;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      return ${ $pack . '::TODO' };
  }
  
  sub in_todo {
      my $self = shift;
  
      local $Level = $Level + 1;
      my $ctx = $self->ctx;
      $ctx->release;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {todo => []})->{todo};
      return 1 if $meta && @$meta;
  
      my $pack = $ctx->trace->package || return 0;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      my $todo = ${ $pack . '::TODO' };
  
      return 0 unless defined $todo;
      return 0 if "$todo" eq '';
      return 1;
  }
  
  sub todo_start {
      my $self = shift;
      my $message = @_ ? shift : '';
  
      my $ctx = $self->ctx;
  
      my $hub = $ctx->hub;
      my $filter = $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          # Set todo on ok's
          if ($hub == $active_hub && $e->isa('Test2::Event::Ok')) {
              $e->set_todo($message);
              $e->set_effective_pass(1);
  
              if (my $result = $e->get_meta(__PACKAGE__)) {
                  $result->{reason} ||= $message;
                  $result->{type}   ||= 'todo';
                  $result->{ok}       = 1;
              }
          }
  
          return $e;
      }, inherit => 1);
  
      push @{$ctx->hub->meta(__PACKAGE__, {todo => []})->{todo}} => [$filter, $message];
  
      $ctx->release;
  
      return;
  }
  
  sub todo_end {
      my $self = shift;
  
      my $ctx = $self->ctx;
  
      my $set = pop @{$ctx->hub->meta(__PACKAGE__, {todo => []})->{todo}};
  
      $ctx->throw('todo_end() called without todo_start()') unless $set;
  
      $ctx->hub->pre_unfilter($set->[0]);
  
      $ctx->release;
  
      return;
  }
  
  
  sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my( $self ) = @_;
  
      my $ctx = $self->ctx;
  
      my $trace = $ctx->trace;
      $ctx->release;
      return wantarray ? $trace->call : $trace->package;
  }
  
  
  sub _try {
      my( $self, $code, %opts ) = @_;
  
      my $error;
      my $return;
      {
          local $!;               # eval can mess up $!
          local $@;               # don't set $@ in the test
          local $SIG{__DIE__};    # don't trip an outside DIE handler.
          $return = eval { $code->() };
          $error = $@;
      }
  
      die $error if $error and $opts{die_on_fail};
  
      return wantarray ? ( $return, $error ) : $return;
  }
  
  sub _ending {
      my $self = shift;
      my ($ctx, $real_exit_code, $new) = @_;
  
      unless ($ctx) {
          my $octx = $self->ctx;
          $ctx = $octx->snapshot;
          $octx->release;
      }
  
      return if $ctx->hub->no_ending;
      return if $ctx->hub->meta(__PACKAGE__, {})->{Ending}++;
  
      # Don't bother with an ending if this is a forked copy.  Only the parent
      # should do the ending.
      return unless $self->{Original_Pid} == $$;
  
      my $hub = $ctx->hub;
      return if $hub->bailed_out;
  
      my $plan  = $hub->plan;
      my $count = $hub->count;
      my $failed = $hub->failed;
      my $passed = $hub->is_passing;
      return unless $plan || $count || $failed;
  
      # Ran tests but never declared a plan or hit done_testing
      if( !$hub->plan and $hub->count ) {
          $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
  
          if($real_exit_code) {
              $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
              $$new ||= $real_exit_code;
              return;
          }
  
          # But if the tests ran, handle exit code.
          if($failed > 0) {
              my $exit_code = $failed <= 254 ? $failed : 254;
              $$new ||= $exit_code;
              return;
          }
  
          $$new ||= 254;
          return;
      }
  
      if ($real_exit_code && !$count) {
          $self->diag("Looks like your test exited with $real_exit_code before it could output anything.");
          $$new ||= $real_exit_code;
          return;
      }
  
      return if $plan && "$plan" eq 'SKIP';
  
      if (!$count) {
          $self->diag('No tests run!');
          $$new ||= 255;
          return;
      }
  
      if ($real_exit_code) {
          $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
          $$new ||= $real_exit_code;
          return;
      }
  
      if ($plan eq 'NO PLAN') {
          $ctx->plan( $count );
          $plan = $hub->plan;
      }
  
      # Figure out if we passed or failed and print helpful messages.
      my $num_extra = $count - $plan;
  
      if ($num_extra != 0) {
          my $s = $plan == 1 ? '' : 's';
          $self->diag(<<"FAIL");
  Looks like you planned $plan test$s but ran $count.
  FAIL
      }
  
      if ($failed) {
          my $s = $failed == 1 ? '' : 's';
  
          my $qualifier = $num_extra == 0 ? '' : ' run';
  
          $self->diag(<<"FAIL");
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
      }
  
      if (!$passed && !$failed && $count && !$num_extra) {
          $ctx->diag(<<"FAIL");
  All assertions passed, but errors were encountered.
  FAIL
      }
  
      my $exit_code = 0;
      if ($failed) {
          $exit_code = $failed <= 254 ? $failed : 254;
      }
      elsif ($num_extra != 0) {
          $exit_code = 255;
      }
      elsif (!$passed) {
          $exit_code = 255;
      }
  
      $$new ||= $exit_code;
      return;
  }
  
  # Some things used this even though it was private... I am looking at you
  # Test::Builder::Prefix...
  sub _print_comment {
      my( $self, $fh, @msgs ) = @_;
  
      return if $self->no_diag;
      return unless @msgs;
  
      # Prevent printing headers when compiling (i.e. -c)
      return if $^C;
  
      # Smash args together like print does.
      # Convert undef to 'undef' so its readable.
      my $msg = join '', map { defined($_) ? $_ : 'undef' } @msgs;
  
      # Escape the beginning, _print will take care of the rest.
      $msg =~ s/^/# /;
  
      local( $\, $", $, ) = ( undef, ' ', '' );
      print $fh $msg;
  
      return 0;
  }
  
  # This is used by Test::SharedFork to turn on IPC after the fact. Not
  # documenting because I do not want it used. The method name is borrowed from
  # Test::Builder 2
  # Once Test2 stuff goes stable this method will be removed and Test::SharedFork
  # will be made smarter.
  sub coordinate_forks {
      my $self = shift;
  
      {
          local ($@, $!);
          require Test2::IPC;
      }
      Test2::IPC->import;
      Test2::API::test2_ipc_enable_polling();
      Test2::API::test2_load();
      my $ipc = Test2::IPC::apply_ipc($self->{Stack});
      $ipc->set_no_fatal(1);
      Test2::API::test2_no_wait(1);
      Test2::API::test2_ipc_enable_shm();
  }
  
  sub no_log_results { $_[0]->{no_log_results} = 1 }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Builder - Backend for building test libraries
  
  =head1 SYNOPSIS
  
    package My::Test::Module;
    use base 'Test::Builder::Module';
  
    my $CLASS = __PACKAGE__;
  
    sub ok {
        my($test, $name) = @_;
        my $tb = $CLASS->builder;
  
        $tb->ok($test, $name);
    }
  
  
  =head1 DESCRIPTION
  
  L<Test::Simple> and L<Test::More> have proven to be popular testing modules,
  but they're not always flexible enough.  Test::Builder provides a
  building block upon which to write your own test libraries I<which can
  work together>.
  
  =head2 Construction
  
  =over 4
  
  =item B<new>
  
    my $Test = Test::Builder->new;
  
  Returns a Test::Builder object representing the current state of the
  test.
  
  Since you only run one test per program C<new> always returns the same
  Test::Builder object.  No matter how many times you call C<new()>, you're
  getting the same object.  This is called a singleton.  This is done so that
  multiple modules share such global information as the test counter and
  where test output is going.
  
  If you want a completely new Test::Builder object different from the
  singleton, use C<create>.
  
  =item B<create>
  
    my $Test = Test::Builder->create;
  
  Ok, so there can be more than one Test::Builder object and this is how
  you get it.  You might use this instead of C<new()> if you're testing
  a Test::Builder based module, but otherwise you probably want C<new>.
  
  B<NOTE>: the implementation is not complete.  C<level>, for example, is still
  shared by B<all> Test::Builder objects, even ones created using this method.
  Also, the method name may change in the future.
  
  =item B<subtest>
  
      $builder->subtest($name, \&subtests, @args);
  
  See documentation of C<subtest> in Test::More.
  
  C<subtest> also, and optionally, accepts arguments which will be passed to the
  subtests reference.
  
  =item B<name>
  
   diag $builder->name;
  
  Returns the name of the current builder.  Top level builders default to C<$0>
  (the name of the executable).  Child builders are named via the C<child>
  method.  If no name is supplied, will be named "Child of $parent->name".
  
  =item B<reset>
  
    $Test->reset;
  
  Reinitializes the Test::Builder singleton to its original state.
  Mostly useful for tests run in persistent environments where the same
  test might be run multiple times in the same process.
  
  =back
  
  =head2 Setting up tests
  
  These methods are for setting up tests and declaring how many there
  are.  You usually only want to call one of these methods.
  
  =over 4
  
  =item B<plan>
  
    $Test->plan('no_plan');
    $Test->plan( skip_all => $reason );
    $Test->plan( tests => $num_tests );
  
  A convenient way to set up your tests.  Call this and Test::Builder
  will print the appropriate headers and take the appropriate actions.
  
  If you call C<plan()>, don't call any of the other methods below.
  
  =item B<expected_tests>
  
      my $max = $Test->expected_tests;
      $Test->expected_tests($max);
  
  Gets/sets the number of tests we expect this test to run and prints out
  the appropriate headers.
  
  
  =item B<no_plan>
  
    $Test->no_plan;
  
  Declares that this test will run an indeterminate number of tests.
  
  
  =item B<done_testing>
  
    $Test->done_testing();
    $Test->done_testing($num_tests);
  
  Declares that you are done testing, no more tests will be run after this point.
  
  If a plan has not yet been output, it will do so.
  
  $num_tests is the number of tests you planned to run.  If a numbered
  plan was already declared, and if this contradicts, a failing test
  will be run to reflect the planning mistake.  If C<no_plan> was declared,
  this will override.
  
  If C<done_testing()> is called twice, the second call will issue a
  failing test.
  
  If C<$num_tests> is omitted, the number of tests run will be used, like
  no_plan.
  
  C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
  safer. You'd use it like so:
  
      $Test->ok($a == $b);
      $Test->done_testing();
  
  Or to plan a variable number of tests:
  
      for my $test (@tests) {
          $Test->ok($test);
      }
      $Test->done_testing(scalar @tests);
  
  
  =item B<has_plan>
  
    $plan = $Test->has_plan
  
  Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
  has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
  of expected tests).
  
  =item B<skip_all>
  
    $Test->skip_all;
    $Test->skip_all($reason);
  
  Skips all the tests, using the given C<$reason>.  Exits immediately with 0.
  
  =item B<exported_to>
  
    my $pack = $Test->exported_to;
    $Test->exported_to($pack);
  
  Tells Test::Builder what package you exported your functions to.
  
  This method isn't terribly useful since modules which share the same
  Test::Builder object might get exported to different packages and only
  the last one will be honored.
  
  =back
  
  =head2 Running tests
  
  These actually run the tests, analogous to the functions in Test::More.
  
  They all return true if the test passed, false if the test failed.
  
  C<$name> is always optional.
  
  =over 4
  
  =item B<ok>
  
    $Test->ok($test, $name);
  
  Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
  like Test::Simple's C<ok()>.
  
  =item B<is_eq>
  
    $Test->is_eq($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
  string version.
  
  C<undef> only ever matches another C<undef>.
  
  =item B<is_num>
  
    $Test->is_num($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
  numeric version.
  
  C<undef> only ever matches another C<undef>.
  
  =item B<isnt_eq>
  
    $Test->isnt_eq($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the string version.
  
  =item B<isnt_num>
  
    $Test->isnt_num($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the numeric version.
  
  =item B<like>
  
    $Test->like($thing, qr/$regex/, $name);
    $Test->like($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<like()>.  Checks if $thing matches the given C<$regex>.
  
  =item B<unlike>
  
    $Test->unlike($thing, qr/$regex/, $name);
    $Test->unlike($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<unlike()>.  Checks if $thing B<does not match> the
  given C<$regex>.
  
  =item B<cmp_ok>
  
    $Test->cmp_ok($thing, $type, $that, $name);
  
  Works just like L<Test::More>'s C<cmp_ok()>.
  
      $Test->cmp_ok($big_num, '!=', $other_big_num);
  
  =back
  
  =head2 Other Testing Methods
  
  These are methods which are used in the course of writing a test but are not themselves tests.
  
  =over 4
  
  =item B<BAIL_OUT>
  
      $Test->BAIL_OUT($reason);
  
  Indicates to the L<Test::Harness> that things are going so badly all
  testing should terminate.  This includes running any additional test
  scripts.
  
  It will exit with 255.
  
  =for deprecated
  BAIL_OUT() used to be BAILOUT()
  
  =item B<skip>
  
      $Test->skip;
      $Test->skip($why);
  
  Skips the current test, reporting C<$why>.
  
  =item B<todo_skip>
  
    $Test->todo_skip;
    $Test->todo_skip($why);
  
  Like C<skip()>, only it will declare the test as failing and TODO.  Similar
  to
  
      print "not ok $tnum # TODO $why\n";
  
  =begin _unimplemented
  
  =item B<skip_rest>
  
    $Test->skip_rest;
    $Test->skip_rest($reason);
  
  Like C<skip()>, only it skips all the rest of the tests you plan to run
  and terminates the test.
  
  If you're running under C<no_plan>, it skips once and terminates the
  test.
  
  =end _unimplemented
  
  =back
  
  
  =head2 Test building utility methods
  
  These methods are useful when writing your own test methods.
  
  =over 4
  
  =item B<maybe_regex>
  
    $Test->maybe_regex(qr/$regex/);
    $Test->maybe_regex('/$regex/');
  
  This method used to be useful back when Test::Builder worked on Perls
  before 5.6 which didn't have qr//.  Now its pretty useless.
  
  Convenience method for building testing functions that take regular
  expressions as arguments.
  
  Takes a quoted regular expression produced by C<qr//>, or a string
  representing a regular expression.
  
  Returns a Perl value which may be used instead of the corresponding
  regular expression, or C<undef> if its argument is not recognized.
  
  For example, a version of C<like()>, sans the useful diagnostic messages,
  could be written as:
  
    sub laconic_like {
        my ($self, $thing, $regex, $name) = @_;
        my $usable_regex = $self->maybe_regex($regex);
        die "expecting regex, found '$regex'\n"
            unless $usable_regex;
        $self->ok($thing =~ m/$usable_regex/, $name);
    }
  
  
  =item B<is_fh>
  
      my $is_fh = $Test->is_fh($thing);
  
  Determines if the given C<$thing> can be used as a filehandle.
  
  =cut
  
  
  =back
  
  
  =head2 Test style
  
  
  =over 4
  
  =item B<level>
  
      $Test->level($how_high);
  
  How far up the call stack should C<$Test> look when reporting where the
  test failed.
  
  Defaults to 1.
  
  Setting C<$Test::Builder::Level> overrides.  This is typically useful
  localized:
  
      sub my_ok {
          my $test = shift;
  
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          $TB->ok($test);
      }
  
  To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.
  
  =item B<use_numbers>
  
      $Test->use_numbers($on_or_off);
  
  Whether or not the test should output numbers.  That is, this if true:
  
    ok 1
    ok 2
    ok 3
  
  or this if false
  
    ok
    ok
    ok
  
  Most useful when you can't depend on the test output order, such as
  when threads or forking is involved.
  
  Defaults to on.
  
  =item B<no_diag>
  
      $Test->no_diag($no_diag);
  
  If set true no diagnostics will be printed.  This includes calls to
  C<diag()>.
  
  =item B<no_ending>
  
      $Test->no_ending($no_ending);
  
  Normally, Test::Builder does some extra diagnostics when the test
  ends.  It also changes the exit code as described below.
  
  If this is true, none of that will be done.
  
  =item B<no_header>
  
      $Test->no_header($no_header);
  
  If set to true, no "1..N" header will be printed.
  
  =back
  
  =head2 Output
  
  Controlling where the test output goes.
  
  It's ok for your test to change where STDOUT and STDERR point to,
  Test::Builder's default output settings will not be affected.
  
  =over 4
  
  =item B<diag>
  
      $Test->diag(@msgs);
  
  Prints out the given C<@msgs>.  Like C<print>, arguments are simply
  appended together.
  
  Normally, it uses the C<failure_output()> handle, but if this is for a
  TODO test, the C<todo_output()> handle is used.
  
  Output will be indented and marked with a # so as not to interfere
  with test output.  A newline will be put on the end if there isn't one
  already.
  
  We encourage using this rather than calling print directly.
  
  Returns false.  Why?  Because C<diag()> is often used in conjunction with
  a failing test (C<ok() || diag()>) it "passes through" the failure.
  
      return ok(...) || diag(...);
  
  =for blame transfer
  Mark Fowler <mark@twoshortplanks.com>
  
  =item B<note>
  
      $Test->note(@msgs);
  
  Like C<diag()>, but it prints to the C<output()> handle so it will not
  normally be seen by the user except in verbose mode.
  
  =item B<explain>
  
      my @dump = $Test->explain(@msgs);
  
  Will dump the contents of any references in a human readable format.
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      is_deeply($have, $want) || note explain $have;
  
  =item B<output>
  
  =item B<failure_output>
  
  =item B<todo_output>
  
      my $filehandle = $Test->output;
      $Test->output($filehandle);
      $Test->output($filename);
      $Test->output(\$scalar);
  
  These methods control where Test::Builder will print its output.
  They take either an open C<$filehandle>, a C<$filename> to open and write to
  or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.
  
  B<output> is where normal "ok/not ok" test output goes.
  
  Defaults to STDOUT.
  
  B<failure_output> is where diagnostic output on test failures and
  C<diag()> goes.  It is normally not read by Test::Harness and instead is
  displayed to the user.
  
  Defaults to STDERR.
  
  C<todo_output> is used instead of C<failure_output()> for the
  diagnostics of a failing TODO test.  These will not be seen by the
  user.
  
  Defaults to STDOUT.
  
  =item reset_outputs
  
    $tb->reset_outputs;
  
  Resets all the output filehandles back to their defaults.
  
  =item carp
  
    $tb->carp(@message);
  
  Warns with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  =item croak
  
    $tb->croak(@message);
  
  Dies with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  
  =back
  
  
  =head2 Test Status and Info
  
  =over 4
  
  =item B<no_log_results>
  
  This will turn off result long-term storage. Calling this method will make
  C<details> and C<summary> useless. You may want to use this if you are running
  enough tests to fill up all available memory.
  
      Test::Builder->new->no_log_results();
  
  There is no way to turn it back on.
  
  =item B<current_test>
  
      my $curr_test = $Test->current_test;
      $Test->current_test($num);
  
  Gets/sets the current test number we're on.  You usually shouldn't
  have to set this.
  
  If set forward, the details of the missing tests are filled in as 'unknown'.
  if set backward, the details of the intervening tests are deleted.  You
  can erase history if you really want to.
  
  
  =item B<is_passing>
  
     my $ok = $builder->is_passing;
  
  Indicates if the test suite is currently passing.
  
  More formally, it will be false if anything has happened which makes
  it impossible for the test suite to pass.  True otherwise.
  
  For example, if no tests have run C<is_passing()> will be true because
  even though a suite with no tests is a failure you can add a passing
  test to it and start passing.
  
  Don't think about it too much.
  
  
  =item B<summary>
  
      my @tests = $Test->summary;
  
  A simple summary of the tests so far.  True for pass, false for fail.
  This is a logical pass/fail, so todos are passes.
  
  Of course, test #1 is $tests[0], etc...
  
  
  =item B<details>
  
      my @tests = $Test->details;
  
  Like C<summary()>, but with a lot more detail.
  
      $tests[$test_num - 1] =
              { 'ok'       => is the test considered a pass?
                actual_ok  => did it literally say 'ok'?
                name       => name of the test (if any)
                type       => type of test (if any, see below).
                reason     => reason for the above (if any)
              };
  
  'ok' is true if Test::Harness will consider the test to be a pass.
  
  'actual_ok' is a reflection of whether or not the test literally
  printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
  tests.
  
  'name' is the name of the test.
  
  'type' indicates if it was a special test.  Normal tests have a type
  of ''.  Type can be one of the following:
  
      skip        see skip()
      todo        see todo()
      todo_skip   see todo_skip()
      unknown     see below
  
  Sometimes the Test::Builder test counter is incremented without it
  printing any test output, for example, when C<current_test()> is changed.
  In these cases, Test::Builder doesn't know the result of the test, so
  its type is 'unknown'.  These details for these tests are filled in.
  They are considered ok, but the name and actual_ok is left C<undef>.
  
  For example "not ok 23 - hole count # TODO insufficient donuts" would
  result in this structure:
  
      $tests[22] =    # 23 - 1, since arrays start from 0.
        { ok        => 1,   # logically, the test passed since its todo
          actual_ok => 0,   # in absolute terms, it failed
          name      => 'hole count',
          type      => 'todo',
          reason    => 'insufficient donuts'
        };
  
  
  =item B<todo>
  
      my $todo_reason = $Test->todo;
      my $todo_reason = $Test->todo($pack);
  
  If the current tests are considered "TODO" it will return the reason,
  if any.  This reason can come from a C<$TODO> variable or the last call
  to C<todo_start()>.
  
  Since a TODO test does not need a reason, this function can return an
  empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
  to determine if you are currently inside a TODO block.
  
  C<todo()> is about finding the right package to look for C<$TODO> in.  It's
  pretty good at guessing the right package to look at.  It first looks for
  the caller based on C<$Level + 1>, since C<todo()> is usually called inside
  a test function.  As a last resort it will use C<exported_to()>.
  
  Sometimes there is some confusion about where C<todo()> should be looking
  for the C<$TODO> variable.  If you want to be sure, tell it explicitly
  what $pack to use.
  
  =item B<find_TODO>
  
      my $todo_reason = $Test->find_TODO();
      my $todo_reason = $Test->find_TODO($pack);
  
  Like C<todo()> but only returns the value of C<$TODO> ignoring
  C<todo_start()>.
  
  Can also be used to set C<$TODO> to a new value while returning the
  old value:
  
      my $old_reason = $Test->find_TODO($pack, 1, $new_reason);
  
  =item B<in_todo>
  
      my $in_todo = $Test->in_todo;
  
  Returns true if the test is currently inside a TODO block.
  
  =item B<todo_start>
  
      $Test->todo_start();
      $Test->todo_start($message);
  
  This method allows you declare all subsequent tests as TODO tests, up until
  the C<todo_end> method has been called.
  
  The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
  whether or not we're in a TODO test.  However, often we find that this is not
  possible to determine (such as when we want to use C<$TODO> but
  the tests are being executed in other packages which can't be inferred
  beforehand).
  
  Note that you can use this to nest "todo" tests
  
   $Test->todo_start('working on this');
   # lots of code
   $Test->todo_start('working on that');
   # more code
   $Test->todo_end;
   $Test->todo_end;
  
  This is generally not recommended, but large testing systems often have weird
  internal needs.
  
  We've tried to make this also work with the TODO: syntax, but it's not
  guaranteed and its use is also discouraged:
  
   TODO: {
       local $TODO = 'We have work to do!';
       $Test->todo_start('working on this');
       # lots of code
       $Test->todo_start('working on that');
       # more code
       $Test->todo_end;
       $Test->todo_end;
   }
  
  Pick one style or another of "TODO" to be on the safe side.
  
  
  =item C<todo_end>
  
   $Test->todo_end;
  
  Stops running tests as "TODO" tests.  This method is fatal if called without a
  preceding C<todo_start> method call.
  
  =item B<caller>
  
      my $package = $Test->caller;
      my($pack, $file, $line) = $Test->caller;
      my($pack, $file, $line) = $Test->caller($height);
  
  Like the normal C<caller()>, except it reports according to your C<level()>.
  
  C<$height> will be added to the C<level()>.
  
  If C<caller()> winds up off the top of the stack it report the highest context.
  
  =back
  
  =head1 EXIT CODES
  
  If all your tests passed, Test::Builder will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Builder
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  =head1 THREADS
  
  In perl 5.8.1 and later, Test::Builder is thread-safe.  The test number is
  shared by all threads.  This means if one thread sets the test number using
  C<current_test()> they will all be effected.
  
  While versions earlier than 5.8.1 had threads they contain too many
  bugs to support.
  
  Test::Builder is only thread-aware if threads.pm is loaded I<before>
  Test::Builder.
  
  You can directly disable thread support with one of the following:
  
      $ENV{T2_NO_IPC} = 1
  
  or
  
      no Test2::IPC;
  
  or
  
      Test2::API::test2_ipc_disable()
  
  =head1 MEMORY
  
  An informative hash, accessible via C<details()>, is stored for each
  test you perform.  So memory usage will scale linearly with each test
  run. Although this is not a problem for most test suites, it can
  become an issue if you do large (hundred thousands to million)
  combinatorics tests in the same run.
  
  In such cases, you are advised to either split the test file into smaller
  ones, or use a reverse approach, doing "normal" (code) compares and
  triggering C<fail()> should anything go unexpected.
  
  Future versions of Test::Builder will have a way to turn history off.
  
  
  =head1 EXAMPLES
  
  CPAN can provide the best examples.  L<Test::Simple>, L<Test::More>,
  L<Test::Exception> and L<Test::Differences> all use Test::Builder.
  
  =head1 SEE ALSO
  
  L<Test::Simple>, L<Test::More>, L<Test::Harness>
  
  =head1 AUTHORS
  
  Original code by chromatic, maintained by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by chromatic E<lt>chromatic@wgz.orgE<gt> and
                         Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
TEST_BUILDER

$fatpacked{"Test/Builder/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_FORMATTER';
  package Test::Builder::Formatter;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Formatter::TAP; our @ISA = qw(Test2::Formatter::TAP) }
  
  use Test2::Util::HashBase qw/no_header no_diag/;
  
  BEGIN {
      *OUT_STD = Test2::Formatter::TAP->can('OUT_STD');
      *OUT_ERR = Test2::Formatter::TAP->can('OUT_ERR');
  
      my $todo = OUT_ERR() + 1;
      *OUT_TODO = sub() { $todo };
  }
  
  sub init {
      my $self = shift;
      $self->SUPER::init(@_);
      $self->{+HANDLES}->[OUT_TODO] = $self->{+HANDLES}->[OUT_STD];
  }
  
  sub plan_tap {
      my ($self, $f) = @_;
  
      return if $self->{+NO_HEADER};
      return $self->SUPER::plan_tap($f);
  }
  
  sub debug_tap {
      my ($self, $f, $num) = @_;
      return if $self->{+NO_DIAG};
      my @out = $self->SUPER::debug_tap($f, $num);
      $self->redirect(\@out) if @out && $f->{about}->{package} eq 'Test::Builder::TodoDiag';
      return @out;
  }
  
  sub info_tap {
      my ($self, $f) = @_;
      return if $self->{+NO_DIAG};
      my @out = $self->SUPER::info_tap($f);
      $self->redirect(\@out) if @out && $f->{about}->{package} eq 'Test::Builder::TodoDiag';
      return @out;
  }
  
  sub redirect {
      my ($self, $out) = @_;
      $_->[0] = OUT_TODO for @$out;
  }
  
  sub no_subtest_space { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Builder::Formatter - Test::Builder subclass of Test2::Formatter::TAP
  
  =head1 DESCRIPTION
  
  This is what takes events and turns them into TAP.
  
  =head1 SYNOPSIS
  
      use Test::Builder; # Loads Test::Builder::Formatter for you
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST_BUILDER_FORMATTER

$fatpacked{"Test/Builder/IO/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_IO_SCALAR';
  package Test::Builder::IO::Scalar;
  
  
  =head1 NAME
  
  Test::Builder::IO::Scalar - A copy of IO::Scalar for Test::Builder
  
  =head1 DESCRIPTION
  
  This is a copy of L<IO::Scalar> which ships with L<Test::Builder> to
  support scalar references as filehandles on Perl 5.6.  Newer
  versions of Perl simply use C<open()>'s built in support.
  
  L<Test::Builder> can not have dependencies on other modules without
  careful consideration, so its simply been copied into the distribution.
  
  =head1 COPYRIGHT and LICENSE
  
  This file came from the "IO-stringy" Perl5 toolkit.
  
  Copyright (c) 1996 by Eryq.  All rights reserved.
  Copyright (c) 1999,2001 by ZeeGee Software Inc.  All rights reserved.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =cut
  
  # This is copied code, I don't care.
  ##no critic
  
  use Carp;
  use strict;
  use vars qw($VERSION @ISA);
  use IO::Handle;
  
  use 5.005;
  
  ### The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.114";
  
  ### Inheritance:
  @ISA = qw(IO::Handle);
  
  #==============================
  
  =head2 Construction
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item new [ARGS...]
  
  I<Class method.>
  Return a new, unattached scalar handle.
  If any arguments are given, they're sent to open().
  
  =cut
  
  sub new {
      my $proto = shift;
      my $class = ref($proto) || $proto;
      my $self = bless \do { local *FH }, $class;
      tie *$self, $class, $self;
      $self->open(@_);   ### open on anonymous by default
      $self;
  }
  sub DESTROY {
      shift->close;
  }
  
  #------------------------------
  
  =item open [SCALARREF]
  
  I<Instance method.>
  Open the scalar handle on a new scalar, pointed to by SCALARREF.
  If no SCALARREF is given, a "private" scalar is created to hold
  the file data.
  
  Returns the self object on success, undefined on error.
  
  =cut
  
  sub open {
      my ($self, $sref) = @_;
  
      ### Sanity:
      defined($sref) or do {my $s = ''; $sref = \$s};
      (ref($sref) eq "SCALAR") or croak "open() needs a ref to a scalar";
  
      ### Setup:
      *$self->{Pos} = 0;          ### seek position
      *$self->{SR}  = $sref;      ### scalar reference
      $self;
  }
  
  #------------------------------
  
  =item opened
  
  I<Instance method.>
  Is the scalar handle opened on something?
  
  =cut
  
  sub opened {
      *{shift()}->{SR};
  }
  
  #------------------------------
  
  =item close
  
  I<Instance method.>
  Disassociate the scalar handle from its underlying scalar.
  Done automatically on destroy.
  
  =cut
  
  sub close {
      my $self = shift;
      %{*$self} = ();
      1;
  }
  
  =back
  
  =cut
  
  
  
  #==============================
  
  =head2 Input and output
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item flush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub flush { "0 but true" }
  
  #------------------------------
  
  =item getc
  
  I<Instance method.>
  Return the next character, or undef if none remain.
  
  =cut
  
  sub getc {
      my $self = shift;
  
      ### Return undef right away if at EOF; else, move pos forward:
      return undef if $self->eof;
      substr(${*$self->{SR}}, *$self->{Pos}++, 1);
  }
  
  #------------------------------
  
  =item getline
  
  I<Instance method.>
  Return the next line, or undef on end of string.
  Can safely be called in an array context.
  Currently, lines are delimited by "\n".
  
  =cut
  
  sub getline {
      my $self = shift;
  
      ### Return undef right away if at EOF:
      return undef if $self->eof;
  
      ### Get next line:
      my $sr = *$self->{SR};
      my $i  = *$self->{Pos};	        ### Start matching at this point.
  
      ### Minimal impact implementation!
      ### We do the fast fast thing (no regexps) if using the
      ### classic input record separator.
  
      ### Case 1: $/ is undef: slurp all...
      if    (!defined($/)) {
  	*$self->{Pos} = length $$sr;
          return substr($$sr, $i);
      }
  
      ### Case 2: $/ is "\n": zoom zoom zoom...
      elsif ($/ eq "\012") {
  
          ### Seek ahead for "\n"... yes, this really is faster than regexps.
          my $len = length($$sr);
          for (; $i < $len; ++$i) {
             last if ord (substr ($$sr, $i, 1)) == 10;
          }
  
          ### Extract the line:
          my $line;
          if ($i < $len) {                ### We found a "\n":
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos} + 1);
              *$self->{Pos} = $i+1;            ### Remember where we finished up.
          }
          else {                          ### No "\n"; slurp the remainder:
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos});
              *$self->{Pos} = $len;
          }
          return $line;
      }
  
      ### Case 3: $/ is ref to int. Do fixed-size records.
      ###        (Thanks to Dominique Quatravaux.)
      elsif (ref($/)) {
          my $len = length($$sr);
  		my $i = ${$/} + 0;
  		my $line = substr ($$sr, *$self->{Pos}, $i);
  		*$self->{Pos} += $i;
          *$self->{Pos} = $len if (*$self->{Pos} > $len);
  		return $line;
      }
  
      ### Case 4: $/ is either "" (paragraphs) or something weird...
      ###         This is Graham's general-purpose stuff, which might be
      ###         a tad slower than Case 2 for typical data, because
      ###         of the regexps.
      else {
          pos($$sr) = $i;
  
  	### If in paragraph mode, skip leading lines (and update i!):
          length($/) or
  	    (($$sr =~ m/\G\n*/g) and ($i = pos($$sr)));
  
          ### If we see the separator in the buffer ahead...
          if (length($/)
  	    ?  $$sr =~ m,\Q$/\E,g          ###   (ordinary sep) TBD: precomp!
              :  $$sr =~ m,\n\n,g            ###   (a paragraph)
              ) {
              *$self->{Pos} = pos $$sr;
              return substr($$sr, $i, *$self->{Pos}-$i);
          }
          ### Else if no separator remains, just slurp the rest:
          else {
              *$self->{Pos} = length $$sr;
              return substr($$sr, $i);
          }
      }
  }
  
  #------------------------------
  
  =item getlines
  
  I<Instance method.>
  Get all remaining lines.
  It will croak() if accidentally called in a scalar context.
  
  =cut
  
  sub getlines {
      my $self = shift;
      wantarray or croak("can't call getlines in scalar context!");
      my ($line, @lines);
      push @lines, $line while (defined($line = $self->getline));
      @lines;
  }
  
  #------------------------------
  
  =item print ARGS...
  
  I<Instance method.>
  Print ARGS to the underlying scalar.
  
  B<Warning:> this continues to always cause a seek to the end
  of the string, but if you perform seek()s and tell()s, it is
  still safer to explicitly seek-to-end before subsequent print()s.
  
  =cut
  
  sub print {
      my $self = shift;
      *$self->{Pos} = length(${*$self->{SR}} .= join('', @_) . (defined($\) ? $\ : ""));
      1;
  }
  sub _unsafe_print {
      my $self = shift;
      my $append = join('', @_) . $\;
      ${*$self->{SR}} .= $append;
      *$self->{Pos}   += length($append);
      1;
  }
  sub _old_print {
      my $self = shift;
      ${*$self->{SR}} .= join('', @_) . $\;
      *$self->{Pos} = length(${*$self->{SR}});
      1;
  }
  
  
  #------------------------------
  
  =item read BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub read {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $read = substr(${*$self->{SR}}, *$self->{Pos}, $n);
      $n = length($read);
      *$self->{Pos} += $n;
      ($off ? substr($_[1], $off) : $_[1]) = $read;
      return $n;
  }
  
  #------------------------------
  
  =item write BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub write {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $data = substr($_[1], $off, $n);
      $n = length($data);
      $self->print($data);
      return $n;
  }
  
  #------------------------------
  
  =item sysread BUF, LEN, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub sysread {
    my $self = shift;
    $self->read(@_);
  }
  
  #------------------------------
  
  =item syswrite BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub syswrite {
    my $self = shift;
    $self->write(@_);
  }
  
  =back
  
  =cut
  
  
  #==============================
  
  =head2 Seeking/telling and other attributes
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item autoflush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub autoflush {}
  
  #------------------------------
  
  =item binmode
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub binmode {}
  
  #------------------------------
  
  =item clearerr
  
  I<Instance method.>  Clear the error and EOF flags.  A no-op.
  
  =cut
  
  sub clearerr { 1 }
  
  #------------------------------
  
  =item eof
  
  I<Instance method.>  Are we at end of file?
  
  =cut
  
  sub eof {
      my $self = shift;
      (*$self->{Pos} >= length(${*$self->{SR}}));
  }
  
  #------------------------------
  
  =item seek OFFSET, WHENCE
  
  I<Instance method.>  Seek to a given position in the stream.
  
  =cut
  
  sub seek {
      my ($self, $pos, $whence) = @_;
      my $eofpos = length(${*$self->{SR}});
  
      ### Seek:
      if    ($whence == 0) { *$self->{Pos} = $pos }             ### SEEK_SET
      elsif ($whence == 1) { *$self->{Pos} += $pos }            ### SEEK_CUR
      elsif ($whence == 2) { *$self->{Pos} = $eofpos + $pos}    ### SEEK_END
      else                 { croak "bad seek whence ($whence)" }
  
      ### Fixup:
      if (*$self->{Pos} < 0)       { *$self->{Pos} = 0 }
      if (*$self->{Pos} > $eofpos) { *$self->{Pos} = $eofpos }
      return 1;
  }
  
  #------------------------------
  
  =item sysseek OFFSET, WHENCE
  
  I<Instance method.> Identical to C<seek OFFSET, WHENCE>, I<q.v.>
  
  =cut
  
  sub sysseek {
      my $self = shift;
      $self->seek (@_);
  }
  
  #------------------------------
  
  =item tell
  
  I<Instance method.>
  Return the current position in the stream, as a numeric offset.
  
  =cut
  
  sub tell { *{shift()}->{Pos} }
  
  #------------------------------
  
  =item  use_RS [YESNO]
  
  I<Instance method.>
  B<Deprecated and ignored.>
  Obey the current setting of $/, like IO::Handle does?
  Default is false in 1.x, but cold-welded true in 2.x and later.
  
  =cut
  
  sub use_RS {
      my ($self, $yesno) = @_;
      carp "use_RS is deprecated and ignored; \$/ is always consulted\n";
   }
  
  #------------------------------
  
  =item setpos POS
  
  I<Instance method.>
  Set the current position, using the opaque value returned by C<getpos()>.
  
  =cut
  
  sub setpos { shift->seek($_[0],0) }
  
  #------------------------------
  
  =item getpos
  
  I<Instance method.>
  Return the current position in the string, as an opaque object.
  
  =cut
  
  *getpos = \&tell;
  
  
  #------------------------------
  
  =item sref
  
  I<Instance method.>
  Return a reference to the underlying scalar.
  
  =cut
  
  sub sref { *{shift()}->{SR} }
  
  
  #------------------------------
  # Tied handle methods...
  #------------------------------
  
  # Conventional tiehandle interface:
  sub TIEHANDLE {
      ((defined($_[1]) && UNIVERSAL::isa($_[1], __PACKAGE__))
       ? $_[1]
       : shift->new(@_));
  }
  sub GETC      { shift->getc(@_) }
  sub PRINT     { shift->print(@_) }
  sub PRINTF    { shift->print(sprintf(shift, @_)) }
  sub READ      { shift->read(@_) }
  sub READLINE  { wantarray ? shift->getlines(@_) : shift->getline(@_) }
  sub WRITE     { shift->write(@_); }
  sub CLOSE     { shift->close(@_); }
  sub SEEK      { shift->seek(@_); }
  sub TELL      { shift->tell(@_); }
  sub EOF       { shift->eof(@_); }
  sub FILENO    { -1 }
  
  #------------------------------------------------------------
  
  1;
  
  __END__
  
  
  
  =back
  
  =cut
  
  
  =head1 WARNINGS
  
  Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
  it was missing support for C<seek()>, C<tell()>, and C<eof()>.
  Attempting to use these functions with an IO::Scalar will not work
  prior to 5.005_57. IO::Scalar will not have the relevant methods
  invoked; and even worse, this kind of bug can lie dormant for a while.
  If you turn warnings on (via C<$^W> or C<perl -w>),
  and you see something like this...
  
      attempt to seek on unopened filehandle
  
  ...then you are probably trying to use one of these functions
  on an IO::Scalar with an old Perl.  The remedy is to simply
  use the OO version; e.g.:
  
      $SH->seek(0,0);    ### GOOD: will work on any 5.005
      seek($SH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
  
  
  =head1 VERSION
  
  $Id: Scalar.pm,v 1.6 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHORS
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Principal author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head2 Other contributors
  
  The full set of contributors always includes the folks mentioned
  in L<IO::Stringy/"CHANGE LOG">.  But just the same, special
  thanks to the following individuals for their invaluable contributions
  (if I've forgotten or misspelled your name, please email me!):
  
  I<Andy Glew,>
  for contributing C<getc()>.
  
  I<Brandon Browning,>
  for suggesting C<opened()>.
  
  I<David Richter,>
  for finding and fixing the bug in C<PRINTF()>.
  
  I<Eric L. Brine,>
  for his offset-using read() and write() implementations.
  
  I<Richard Jones,>
  for his patches to massively improve the performance of C<getline()>
  and add C<sysread> and C<syswrite>.
  
  I<B. K. Oxley (binkley),>
  for stringification and inheritance improvements,
  and sundry good ideas.
  
  I<Doug Wilson,>
  for the IO::Handle inheritance and automatic tie-ing.
  
  
  =head1 SEE ALSO
  
  L<IO::String>, which is quite similar but which was designed
  more-recently and with an IO::Handle-like interface in mind,
  so you could mix OO- and native-filehandle usage without using tied().
  
  I<Note:> as of version 2.x, these classes all work like
  their IO::Handle counterparts, so we have comparable
  functionality to IO::String.
  
  =cut
  
TEST_BUILDER_IO_SCALAR

$fatpacked{"Test/Builder/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_MODULE';
  package Test::Builder::Module;
  
  use strict;
  
  use Test::Builder;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = '1.302136';
  
  
  =head1 NAME
  
  Test::Builder::Module - Base class for test modules
  
  =head1 SYNOPSIS
  
    # Emulates Test::Simple
    package Your::Module;
  
    my $CLASS = __PACKAGE__;
  
    use parent 'Test::Builder::Module';
    @EXPORT = qw(ok);
  
    sub ok ($;$) {
        my $tb = $CLASS->builder;
        return $tb->ok(@_);
    }
    
    1;
  
  
  =head1 DESCRIPTION
  
  This is a superclass for L<Test::Builder>-based modules.  It provides a
  handful of common functionality and a method of getting at the underlying
  L<Test::Builder> object.
  
  
  =head2 Importing
  
  Test::Builder::Module is a subclass of L<Exporter> which means your
  module is also a subclass of Exporter.  @EXPORT, @EXPORT_OK, etc...
  all act normally.
  
  A few methods are provided to do the C<< use Your::Module tests => 23 >> part
  for you.
  
  =head3 import
  
  Test::Builder::Module provides an C<import()> method which acts in the
  same basic way as L<Test::More>'s, setting the plan and controlling
  exporting of functions and variables.  This allows your module to set
  the plan independent of L<Test::More>.
  
  All arguments passed to C<import()> are passed onto 
  C<< Your::Module->builder->plan() >> with the exception of 
  C<< import =>[qw(things to import)] >>.
  
      use Your::Module import => [qw(this that)], tests => 23;
  
  says to import the functions C<this()> and C<that()> as well as set the plan
  to be 23 tests.
  
  C<import()> also sets the C<exported_to()> attribute of your builder to be
  the caller of the C<import()> function.
  
  Additional behaviors can be added to your C<import()> method by overriding
  C<import_extra()>.
  
  =cut
  
  sub import {
      my($class) = shift;
  
      Test2::API::test2_load() unless Test2::API::test2_in_preload();
  
      # Don't run all this when loading ourself.
      return 1 if $class eq 'Test::Builder::Module';
  
      my $test = $class->builder;
  
      my $caller = caller;
  
      $test->exported_to($caller);
  
      $class->import_extra( \@_ );
      my(@imports) = $class->_strip_imports( \@_ );
  
      $test->plan(@_);
  
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      $class->Exporter::import(@imports);
  }
  
  sub _strip_imports {
      my $class = shift;
      my $list  = shift;
  
      my @imports = ();
      my @other   = ();
      my $idx     = 0;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'import' ) {
              push @imports, @{ $list->[ $idx + 1 ] };
              $idx++;
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      return @imports;
  }
  
  =head3 import_extra
  
      Your::Module->import_extra(\@import_args);
  
  C<import_extra()> is called by C<import()>.  It provides an opportunity for you
  to add behaviors to your module based on its import list.
  
  Any extra arguments which shouldn't be passed on to C<plan()> should be
  stripped off by this method.
  
  See L<Test::More> for an example of its use.
  
  B<NOTE> This mechanism is I<VERY ALPHA AND LIKELY TO CHANGE> as it
  feels like a bit of an ugly hack in its current form.
  
  =cut
  
  sub import_extra { }
  
  =head2 Builder
  
  Test::Builder::Module provides some methods of getting at the underlying
  Test::Builder object.
  
  =head3 builder
  
    my $builder = Your::Class->builder;
  
  This method returns the L<Test::Builder> object associated with Your::Class.
  It is not a constructor so you can call it as often as you like.
  
  This is the preferred way to get the L<Test::Builder> object.  You should
  I<not> get it via C<< Test::Builder->new >> as was previously
  recommended.
  
  The object returned by C<builder()> may change at runtime so you should
  call C<builder()> inside each function rather than store it in a global.
  
    sub ok {
        my $builder = Your::Class->builder;
  
        return $builder->ok(@_);
    }
  
  
  =cut
  
  sub builder {
      return Test::Builder->new;
  }
  
  1;
TEST_BUILDER_MODULE

$fatpacked{"Test/Builder/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER';
  package Test::Builder::Tester;
  
  use strict;
  our $VERSION = '1.302136';
  
  use Test::Builder;
  use Symbol;
  use Carp;
  
  =head1 NAME
  
  Test::Builder::Tester - test testsuites that have been built with
  Test::Builder
  
  =head1 SYNOPSIS
  
      use Test::Builder::Tester tests => 1;
      use Test::More;
  
      test_out("not ok 1 - foo");
      test_fail(+1);
      fail("foo");
      test_test("fail works");
  
  =head1 DESCRIPTION
  
  A module that helps you test testing modules that are built with
  L<Test::Builder>.
  
  The testing system is designed to be used by performing a three step
  process for each test you wish to test.  This process starts with using
  C<test_out> and C<test_err> in advance to declare what the testsuite you
  are testing will output with L<Test::Builder> to stdout and stderr.
  
  You then can run the test(s) from your test suite that call
  L<Test::Builder>.  At this point the output of L<Test::Builder> is
  safely captured by L<Test::Builder::Tester> rather than being
  interpreted as real test output.
  
  The final stage is to call C<test_test> that will simply compare what you
  predeclared to what L<Test::Builder> actually outputted, and report the
  results back with a "ok" or "not ok" (with debugging) to the normal
  output.
  
  =cut
  
  ####
  # set up testing
  ####
  
  my $t = Test::Builder->new;
  
  ###
  # make us an exporter
  ###
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(test_out test_err test_fail test_diag test_test line_num);
  
  sub import {
      my $class = shift;
      my(@plan) = @_;
  
      my $caller = caller;
  
      $t->exported_to($caller);
      $t->plan(@plan);
  
      my @imports = ();
      foreach my $idx ( 0 .. $#plan ) {
          if( $plan[$idx] eq 'import' ) {
              @imports = @{ $plan[ $idx + 1 ] };
              last;
          }
      }
  
      __PACKAGE__->export_to_level( 1, __PACKAGE__, @imports );
  }
  
  ###
  # set up file handles
  ###
  
  # create some private file handles
  my $output_handle = gensym;
  my $error_handle  = gensym;
  
  # and tie them to this package
  my $out = tie *$output_handle, "Test::Builder::Tester::Tie", "STDOUT";
  my $err = tie *$error_handle,  "Test::Builder::Tester::Tie", "STDERR";
  
  ####
  # exported functions
  ####
  
  # for remembering that we're testing and where we're testing at
  my $testing = 0;
  my $testing_num;
  my $original_is_passing;
  
  # remembering where the file handles were originally connected
  my $original_output_handle;
  my $original_failure_handle;
  my $original_todo_handle;
  my $original_formatter;
  
  my $original_harness_env;
  
  # function that starts testing and redirects the filehandles for now
  sub _start_testing {
      # Hack for things that conditioned on Test-Stream being loaded
      $INC{'Test/Stream.pm'} ||= 'fake' if $INC{'Test/Moose/More.pm'};
      # even if we're running under Test::Harness pretend we're not
      # for now.  This needed so Test::Builder doesn't add extra spaces
      $original_harness_env = $ENV{HARNESS_ACTIVE} || 0;
      $ENV{HARNESS_ACTIVE} = 0;
  
      my $hub = $t->{Hub} || ($t->{Stack} ? $t->{Stack}->top : Test2::API::test2_stack->top);
      $original_formatter = $hub->format;
      unless ($original_formatter && $original_formatter->isa('Test::Builder::Formatter')) {
          my $fmt = Test::Builder::Formatter->new;
          $hub->format($fmt);
      }
  
      # remember what the handles were set to
      $original_output_handle  = $t->output();
      $original_failure_handle = $t->failure_output();
      $original_todo_handle    = $t->todo_output();
  
      # switch out to our own handles
      $t->output($output_handle);
      $t->failure_output($error_handle);
      $t->todo_output($output_handle);
  
      # clear the expected list
      $out->reset();
      $err->reset();
  
      # remember that we're testing
      $testing     = 1;
      $testing_num = $t->current_test;
      $t->current_test(0);
      $original_is_passing  = $t->is_passing;
      $t->is_passing(1);
  
      # look, we shouldn't do the ending stuff
      $t->no_ending(1);
  }
  
  =head2 Functions
  
  These are the six methods that are exported as default.
  
  =over 4
  
  =item test_out
  
  =item test_err
  
  Procedures for predeclaring the output that your test suite is
  expected to produce until C<test_test> is called.  These procedures
  automatically assume that each line terminates with "\n".  So
  
     test_out("ok 1","ok 2");
  
  is the same as
  
     test_out("ok 1\nok 2");
  
  which is even the same as
  
     test_out("ok 1");
     test_out("ok 2");
  
  Once C<test_out> or C<test_err> (or C<test_fail> or C<test_diag>) have
  been called, all further output from L<Test::Builder> will be
  captured by L<Test::Builder::Tester>.  This means that you will not
  be able perform further tests to the normal output in the normal way
  until you call C<test_test> (well, unless you manually meddle with the
  output filehandles)
  
  =cut
  
  sub test_out {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $out->expect(@_);
  }
  
  sub test_err {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $err->expect(@_);
  }
  
  =item test_fail
  
  Because the standard failure message that L<Test::Builder> produces
  whenever a test fails will be a common occurrence in your test error
  output, and because it has changed between Test::Builder versions, rather
  than forcing you to call C<test_err> with the string all the time like
  so
  
      test_err("# Failed test ($0 at line ".line_num(+1).")");
  
  C<test_fail> exists as a convenience function that can be called
  instead.  It takes one argument, the offset from the current line that
  the line that causes the fail is on.
  
      test_fail(+1);
  
  This means that the example in the synopsis could be rewritten
  more simply as:
  
     test_out("not ok 1 - foo");
     test_fail(+1);
     fail("foo");
     test_test("fail works");
  
  =cut
  
  sub test_fail {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # work out what line we should be on
      my( $package, $filename, $line ) = caller;
      $line = $line + ( shift() || 0 );    # prevent warnings
  
      # expect that on stderr
      $err->expect("#     Failed test ($filename at line $line)");
  }
  
  =item test_diag
  
  As most of the remaining expected output to the error stream will be
  created by L<Test::Builder>'s C<diag> function, L<Test::Builder::Tester>
  provides a convenience function C<test_diag> that you can use instead of
  C<test_err>.
  
  The C<test_diag> function prepends comment hashes and spacing to the
  start and newlines to the end of the expected output passed to it and
  adds it to the list of expected error output.  So, instead of writing
  
     test_err("# Couldn't open file");
  
  you can write
  
     test_diag("Couldn't open file");
  
  Remember that L<Test::Builder>'s diag function will not add newlines to
  the end of output and test_diag will. So to check
  
     Test::Builder->new->diag("foo\n","bar\n");
  
  You would do
  
    test_diag("foo","bar")
  
  without the newlines.
  
  =cut
  
  sub test_diag {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # expect the same thing, but prepended with "#     "
      local $_;
      $err->expect( map { "# $_" } @_ );
  }
  
  =item test_test
  
  Actually performs the output check testing the tests, comparing the
  data (with C<eq>) that we have captured from L<Test::Builder> against
  what was declared with C<test_out> and C<test_err>.
  
  This takes name/value pairs that effect how the test is run.
  
  =over
  
  =item title (synonym 'name', 'label')
  
  The name of the test that will be displayed after the C<ok> or C<not
  ok>.
  
  =item skip_out
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the output stream does not match that
  declared with C<test_out>.
  
  =item skip_err
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the error stream does not match that
  declared with C<test_err>.
  
  =back
  
  As a convenience, if only one argument is passed then this argument
  is assumed to be the name of the test (as in the above examples.)
  
  Once C<test_test> has been run test output will be redirected back to
  the original filehandles that L<Test::Builder> was connected to
  (probably STDOUT and STDERR,) meaning any further tests you run
  will function normally and cause success/errors for L<Test::Harness>.
  
  =cut
  
  sub test_test {
      # END the hack
      delete $INC{'Test/Stream.pm'} if $INC{'Test/Stream.pm'} && $INC{'Test/Stream.pm'} eq 'fake';
      # decode the arguments as described in the pod
      my $mess;
      my %args;
      if( @_ == 1 ) {
          $mess = shift
      }
      else {
          %args = @_;
          $mess = $args{name} if exists( $args{name} );
          $mess = $args{title} if exists( $args{title} );
          $mess = $args{label} if exists( $args{label} );
      }
  
      # er, are we testing?
      croak "Not testing.  You must declare output with a test function first."
        unless $testing;
  
  
      my $hub = $t->{Hub} || Test2::API::test2_stack->top;
      $hub->format($original_formatter);
  
      # okay, reconnect the test suite back to the saved handles
      $t->output($original_output_handle);
      $t->failure_output($original_failure_handle);
      $t->todo_output($original_todo_handle);
  
      # restore the test no, etc, back to the original point
      $t->current_test($testing_num);
      $testing = 0;
      $t->is_passing($original_is_passing);
  
      # re-enable the original setting of the harness
      $ENV{HARNESS_ACTIVE} = $original_harness_env;
  
      # check the output we've stashed
      unless( $t->ok( ( $args{skip_out} || $out->check ) &&
                      ( $args{skip_err} || $err->check ), $mess ) 
      )
      {
          # print out the diagnostic information about why this
          # test failed
  
          local $_;
  
          $t->diag( map { "$_\n" } $out->complaint )
            unless $args{skip_out} || $out->check;
  
          $t->diag( map { "$_\n" } $err->complaint )
            unless $args{skip_err} || $err->check;
      }
  }
  
  =item line_num
  
  A utility function that returns the line number that the function was
  called on.  You can pass it an offset which will be added to the
  result.  This is very useful for working out the correct text of
  diagnostic functions that contain line numbers.
  
  Essentially this is the same as the C<__LINE__> macro, but the
  C<line_num(+3)> idiom is arguably nicer.
  
  =cut
  
  sub line_num {
      my( $package, $filename, $line ) = caller;
      return $line + ( shift() || 0 );    # prevent warnings
  }
  
  =back
  
  In addition to the six exported functions there exists one
  function that can only be accessed with a fully qualified function
  call.
  
  =over 4
  
  =item color
  
  When C<test_test> is called and the output that your tests generate
  does not match that which you declared, C<test_test> will print out
  debug information showing the two conflicting versions.  As this
  output itself is debug information it can be confusing which part of
  the output is from C<test_test> and which was the original output from
  your original tests.  Also, it may be hard to spot things like
  extraneous whitespace at the end of lines that may cause your test to
  fail even though the output looks similar.
  
  To assist you C<test_test> can colour the background of the debug
  information to disambiguate the different types of output. The debug
  output will have its background coloured green and red.  The green
  part represents the text which is the same between the executed and
  actual output, the red shows which part differs.
  
  The C<color> function determines if colouring should occur or not.
  Passing it a true or false value will enable or disable colouring
  respectively, and the function called with no argument will return the
  current setting.
  
  To enable colouring from the command line, you can use the
  L<Text::Builder::Tester::Color> module like so:
  
     perl -Mlib=Text::Builder::Tester::Color test.t
  
  Or by including the L<Test::Builder::Tester::Color> module directly in
  the PERL5LIB.
  
  =cut
  
  my $color;
  
  sub color {
      $color = shift if @_;
      $color;
  }
  
  =back
  
  =head1 BUGS
  
  Test::Builder::Tester does not handle plans well. It has never done anything
  special with plans. This means that plans from outside Test::Builder::Tester
  will effect Test::Builder::Tester, worse plans when using Test::Builder::Tester
  will effect overall testing. At this point there are no plans to fix this bug
  as people have come to depend on it, and Test::Builder::Tester is now
  discouraged in favor of C<Test2::API::intercept()>. See
  L<https://github.com/Test-More/test-more/issues/667>
  
  Calls C<< Test::Builder->no_ending >> turning off the ending tests.
  This is needed as otherwise it will trip out because we've run more
  tests than we strictly should have and it'll register any failures we
  had that we were testing for as real failures.
  
  The color function doesn't work unless L<Term::ANSIColor> is
  compatible with your terminal. Additionally, L<Win32::Console::ANSI>
  must be installed on windows platforms for color output.
  
  Bugs (and requests for new features) can be reported to the author
  though GitHub:
  L<https://github.com/Test-More/test-more/issues>
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002, 2004.
  
  Some code taken from L<Test::More> and L<Test::Catch>, written by
  Michael G Schwern E<lt>schwern@pobox.comE<gt>.  Hence, those parts
  Copyright Micheal G Schwern 2001.  Used and distributed with
  permission.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 NOTES
  
  Thanks to Richard Clamp E<lt>richardc@unixbeard.netE<gt> for letting
  me use his testing system to try this module out on.
  
  =head1 SEE ALSO
  
  L<Test::Builder>, L<Test::Builder::Tester::Color>, L<Test::More>.
  
  =cut
  
  1;
  
  ####################################################################
  # Helper class that is used to remember expected and received data
  
  package Test::Builder::Tester::Tie;
  
  ##
  # add line(s) to be expected
  
  sub expect {
      my $self = shift;
  
      my @checks = @_;
      foreach my $check (@checks) {
          $check = $self->_account_for_subtest($check);
          $check = $self->_translate_Failed_check($check);
          push @{ $self->{wanted} }, ref $check ? $check : "$check\n";
      }
  }
  
  sub _account_for_subtest {
      my( $self, $check ) = @_;
  
      my $hub = $t->{Stack}->top;
      my $nesting = $hub->isa('Test2::Hub::Subtest') ? $hub->nested : 0;
      return ref($check) ? $check : ('    ' x $nesting) . $check;
  }
  
  sub _translate_Failed_check {
      my( $self, $check ) = @_;
  
      if( $check =~ /\A(.*)#     (Failed .*test) \((.*?) at line (\d+)\)\Z(?!\n)/ ) {
          $check = "/\Q$1\E#\\s+\Q$2\E.*?\\n?.*?\Qat $3\E line \Q$4\E.*\\n?/";
      }
  
      return $check;
  }
  
  ##
  # return true iff the expected data matches the got data
  
  sub check {
      my $self = shift;
  
      # turn off warnings as these might be undef
      local $^W = 0;
  
      my @checks = @{ $self->{wanted} };
      my $got    = $self->{got};
      foreach my $check (@checks) {
          $check = "\Q$check\E" unless( $check =~ s,^/(.*)/$,$1, or ref $check );
          return 0 unless $got =~ s/^$check//;
      }
  
      return length $got == 0;
  }
  
  ##
  # a complaint message about the inputs not matching (to be
  # used for debugging messages)
  
  sub complaint {
      my $self   = shift;
      my $type   = $self->type;
      my $got    = $self->got;
      my $wanted = join '', @{ $self->wanted };
  
      # are we running in colour mode?
      if(Test::Builder::Tester::color) {
          # get color
          eval { require Term::ANSIColor };
          unless($@) {
              eval { require Win32::Console::ANSI } if 'MSWin32' eq $^O;  # support color on windows platforms
  
              # colours
  
              my $green = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_green");
              my $red   = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_red");
              my $reset = Term::ANSIColor::color("reset");
  
              # work out where the two strings start to differ
              my $char = 0;
              $char++ while substr( $got, $char, 1 ) eq substr( $wanted, $char, 1 );
  
              # get the start string and the two end strings
              my $start = $green . substr( $wanted, 0, $char );
              my $gotend    = $red . substr( $got,    $char ) . $reset;
              my $wantedend = $red . substr( $wanted, $char ) . $reset;
  
              # make the start turn green on and off
              $start =~ s/\n/$reset\n$green/g;
  
              # make the ends turn red on and off
              $gotend    =~ s/\n/$reset\n$red/g;
              $wantedend =~ s/\n/$reset\n$red/g;
  
              # rebuild the strings
              $got    = $start . $gotend;
              $wanted = $start . $wantedend;
          }
      }
  
      my @got = split "\n", $got;
      my @wanted = split "\n", $wanted;
  
      $got = "";
      $wanted = "";
  
      while (@got || @wanted) {
          my $g = shift @got    || "";
          my $w = shift @wanted || "";
          if ($g ne $w) {
              if($g =~ s/(\s+)$/    |> /g) {
                  $g .= ($_ eq ' ' ? '_' : '\t') for split '', $1;
              }
              if($w =~ s/(\s+)$/    |> /g) {
                  $w .= ($_ eq ' ' ? '_' : '\t') for split '', $1;
              }
              $g = "> $g";
              $w = "> $w";
          }
          else {
              $g = "  $g";
              $w = "  $w";
          }
          $got = $got ? "$got\n$g" : $g;
          $wanted = $wanted ? "$wanted\n$w" : $w;
      }
  
      return "$type is:\n" . "$got\nnot:\n$wanted\nas expected";
  }
  
  ##
  # forget all expected and got data
  
  sub reset {
      my $self = shift;
      %$self = (
          type   => $self->{type},
          got    => '',
          wanted => [],
      );
  }
  
  sub got {
      my $self = shift;
      return $self->{got};
  }
  
  sub wanted {
      my $self = shift;
      return $self->{wanted};
  }
  
  sub type {
      my $self = shift;
      return $self->{type};
  }
  
  ###
  # tie interface
  ###
  
  sub PRINT {
      my $self = shift;
      $self->{got} .= join '', @_;
  }
  
  sub TIEHANDLE {
      my( $class, $type ) = @_;
  
      my $self = bless { type => $type }, $class;
  
      $self->reset;
  
      return $self;
  }
  
  sub READ     { }
  sub READLINE { }
  sub GETC     { }
  sub FILENO   { }
  
  1;
TEST_BUILDER_TESTER

$fatpacked{"Test/Builder/Tester/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER_COLOR';
  package Test::Builder::Tester::Color;
  
  use strict;
  our $VERSION = '1.302136';
  
  require Test::Builder::Tester;
  
  
  =head1 NAME
  
  Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester
  
  =head1 SYNOPSIS
  
     When running a test script
  
       perl -MTest::Builder::Tester::Color test.t
  
  =head1 DESCRIPTION
  
  Importing this module causes the subroutine color in Test::Builder::Tester
  to be called with a true value causing colour highlighting to be turned
  on in debug output.
  
  The sole purpose of this module is to enable colour highlighting
  from the command line.
  
  =cut
  
  sub import {
      Test::Builder::Tester::color(1);
  }
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 BUGS
  
  This module will have no effect unless Term::ANSIColor is installed.
  
  =head1 SEE ALSO
  
  L<Test::Builder::Tester>, L<Term::ANSIColor>
  
  =cut
  
  1;
TEST_BUILDER_TESTER_COLOR

$fatpacked{"Test/Builder/TodoDiag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TODODIAG';
  package Test::Builder::TodoDiag;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Event::Diag; our @ISA = qw(Test2::Event::Diag) }
  
  sub diagnostics { 0 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->SUPER::facet_data();
      $out->{info}->[0]->{debug} = 0;
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Builder::TodoDiag - Test::Builder subclass of Test2::Event::Diag
  
  =head1 DESCRIPTION
  
  This is used to encapsulate diag messages created inside TODO.
  
  =head1 SYNOPSIS
  
  You do not need to use this directly.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST_BUILDER_TODODIAG

$fatpacked{"Test/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MORE';
  package Test::More;
  
  use 5.006;
  use strict;
  use warnings;
  
  #---- perlcritic exemptions. ----#
  
  # We use a lot of subroutine prototypes
  ## no critic (Subroutines::ProhibitSubroutinePrototypes)
  
  # Can't use Carp because it might cause C<use_ok()> to accidentally succeed
  # even though the module being used forgot to use Carp.  Yes, this
  # actually happened.
  sub _carp {
      my( $file, $line ) = ( caller(1) )[ 1, 2 ];
      return warn @_, " at $file line $line\n";
  }
  
  our $VERSION = '1.302136';
  
  use Test::Builder::Module;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok use_ok require_ok
    is isnt like unlike is_deeply
    cmp_ok
    skip todo todo_skip
    pass fail
    eq_array eq_hash eq_set
    $TODO
    plan
    done_testing
    can_ok isa_ok new_ok
    diag note explain
    subtest
    BAIL_OUT
  );
  
  =head1 NAME
  
  Test::More - yet another framework for writing test scripts
  
  =head1 SYNOPSIS
  
    use Test::More tests => 23;
    # or
    use Test::More skip_all => $reason;
    # or
    use Test::More;   # see done_testing()
  
    require_ok( 'Some::Module' );
  
    # Various ways to say "ok"
    ok($got eq $expected, $test_name);
  
    is  ($got, $expected, $test_name);
    isnt($got, $expected, $test_name);
  
    # Rather than print STDERR "# here's what went wrong\n"
    diag("here's what went wrong");
  
    like  ($got, qr/expected/, $test_name);
    unlike($got, qr/expected/, $test_name);
  
    cmp_ok($got, '==', $expected, $test_name);
  
    is_deeply($got_complex_structure, $expected_complex_structure, $test_name);
  
    SKIP: {
        skip $why, $how_many unless $have_some_feature;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    TODO: {
        local $TODO = $why;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    can_ok($module, @methods);
    isa_ok($object, $class);
  
    pass($test_name);
    fail($test_name);
  
    BAIL_OUT($why);
  
    # UNIMPLEMENTED!!!
    my @status = Test::More::status;
  
  
  =head1 DESCRIPTION
  
  B<STOP!> If you're just getting started writing tests, have a look at
  L<Test::Simple> first.  This is a drop in replacement for Test::Simple
  which you can switch to once you get the hang of basic testing.
  
  The purpose of this module is to provide a wide range of testing
  utilities.  Various ways to say "ok" with better diagnostics,
  facilities to skip tests, test future features and compare complicated
  data structures.  While you can do almost anything with a simple
  C<ok()> function, it doesn't provide good diagnostic output.
  
  
  =head2 I love it when a plan comes together
  
  Before anything else, you need a testing plan.  This basically declares
  how many tests your script is going to run to protect against premature
  failure.
  
  The preferred way to do this is to declare a plan when you C<use Test::More>.
  
    use Test::More tests => 23;
  
  There are cases when you will not know beforehand how many tests your
  script is going to run.  In this case, you can declare your tests at
  the end.
  
    use Test::More;
  
    ... run your tests ...
  
    done_testing( $number_of_tests_run );
  
  B<NOTE> C<done_testing()> should never be called in an C<END { ... }> block.
  
  Sometimes you really don't know how many tests were run, or it's too
  difficult to calculate.  In which case you can leave off
  $number_of_tests_run.
  
  In some cases, you'll want to completely skip an entire testing script.
  
    use Test::More skip_all => $skip_reason;
  
  Your script will declare a skip with the reason why you skipped and
  exit immediately with a zero (success).  See L<Test::Harness> for
  details.
  
  If you want to control what functions Test::More will export, you
  have to use the 'import' option.  For example, to import everything
  but 'fail', you'd do:
  
    use Test::More tests => 23, import => ['!fail'];
  
  Alternatively, you can use the C<plan()> function.  Useful for when you
  have to calculate the number of tests.
  
    use Test::More;
    plan tests => keys %Stuff * 3;
  
  or for deciding between running the tests at all:
  
    use Test::More;
    if( $^O eq 'MacOS' ) {
        plan skip_all => 'Test irrelevant on MacOS';
    }
    else {
        plan tests => 42;
    }
  
  =cut
  
  sub plan {
      my $tb = Test::More->builder;
  
      return $tb->plan(@_);
  }
  
  # This implements "use Test::More 'no_diag'" but the behavior is
  # deprecated.
  sub import_extra {
      my $class = shift;
      my $list  = shift;
  
      my @other = ();
      my $idx   = 0;
      my $import;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'no_diag' ) {
              $class->builder->no_diag(1);
          }
          elsif( defined $item and $item eq 'import' ) {
              if ($import) {
                  push @$import, @{$list->[ ++$idx ]};
              }
              else {
                  $import = $list->[ ++$idx ];
                  push @other, $item, $import;
              }
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      if ($class eq __PACKAGE__ && (!$import || grep $_ eq '$TODO', @$import)) {
          my $to = $class->builder->exported_to;
          no strict 'refs';
          *{"$to\::TODO"} = \our $TODO;
          if ($import) {
              @$import = grep $_ ne '$TODO', @$import;
          }
          else {
              push @$list, import => [grep $_ ne '$TODO', @EXPORT];
          }
      }
  
      return;
  }
  
  =over 4
  
  =item B<done_testing>
  
      done_testing();
      done_testing($number_of_tests);
  
  If you don't know how many tests you're going to run, you can issue
  the plan when you're done running tests.
  
  $number_of_tests is the same as C<plan()>, it's the number of tests you
  expected to run.  You can omit this, in which case the number of tests
  you ran doesn't matter, just the fact that your tests ran to
  conclusion.
  
  This is safer than and replaces the "no_plan" plan.
  
  B<Note:> You must never put C<done_testing()> inside an C<END { ... }> block.
  The plan is there to ensure your test does not exit before testing has
  completed. If you use an END block you completely bypass this protection.
  
  =back
  
  =cut
  
  sub done_testing {
      my $tb = Test::More->builder;
      $tb->done_testing(@_);
  }
  
  =head2 Test names
  
  By convention, each test is assigned a number in order.  This is
  largely done automatically for you.  However, it's often very useful to
  assign a name to each test.  Which would you rather see:
  
    ok 4
    not ok 5
    ok 6
  
  or
  
    ok 4 - basic multi-variable
    not ok 5 - simple exponential
    ok 6 - force == mass * acceleration
  
  The later gives you some idea of what failed.  It also makes it easier
  to find the test in your script, simply search for "simple
  exponential".
  
  All test functions take a name argument.  It's optional, but highly
  suggested that you use it.
  
  =head2 I'm ok, you're not ok.
  
  The basic purpose of this module is to print out either "ok #" or "not
  ok #" depending on if a given test succeeded or failed.  Everything
  else is just gravy.
  
  All of the following print "ok" or "not ok" depending on if the test
  succeeded or failed.  They all also return true or false,
  respectively.
  
  =over 4
  
  =item B<ok>
  
    ok($got eq $expected, $test_name);
  
  This simply evaluates any expression (C<$got eq $expected> is just a
  simple example) and uses that to determine if the test succeeded or
  failed.  A true expression passes, a false one fails.  Very simple.
  
  For example:
  
      ok( $exp{9} == 81,                   'simple exponential' );
      ok( Film->can('db_Main'),            'set_db()' );
      ok( $p->tests == 4,                  'saw tests' );
      ok( !grep(!defined $_, @items),      'all items defined' );
  
  (Mnemonic:  "This is ok.")
  
  $test_name is a very short description of the test that will be printed
  out.  It makes it very easy to find a test in your script when it fails
  and gives others an idea of your intentions.  $test_name is optional,
  but we B<very> strongly encourage its use.
  
  Should an C<ok()> fail, it will produce some diagnostics:
  
      not ok 18 - sufficient mucus
      #   Failed test 'sufficient mucus'
      #   in foo.t at line 42.
  
  This is the same as L<Test::Simple>'s C<ok()> routine.
  
  =cut
  
  sub ok ($;$) {
      my( $test, $name ) = @_;
      my $tb = Test::More->builder;
  
      return $tb->ok( $test, $name );
  }
  
  =item B<is>
  
  =item B<isnt>
  
    is  ( $got, $expected, $test_name );
    isnt( $got, $expected, $test_name );
  
  Similar to C<ok()>, C<is()> and C<isnt()> compare their two arguments
  with C<eq> and C<ne> respectively and use the result of that to
  determine if the test succeeded or failed.  So these:
  
      # Is the ultimate answer 42?
      is( ultimate_answer(), 42,          "Meaning of Life" );
  
      # $foo isn't empty
      isnt( $foo, '',     "Got some foo" );
  
  are similar to these:
  
      ok( ultimate_answer() eq 42,        "Meaning of Life" );
      ok( $foo ne '',     "Got some foo" );
  
  C<undef> will only ever match C<undef>.  So you can test a value
  against C<undef> like this:
  
      is($not_defined, undef, "undefined as expected");
  
  (Mnemonic:  "This is that."  "This isn't that.")
  
  So why use these?  They produce better diagnostics on failure.  C<ok()>
  cannot know what you are testing for (beyond the name), but C<is()> and
  C<isnt()> know what the test was and why it failed.  For example this
  test:
  
      my $foo = 'waffle';  my $bar = 'yarblokos';
      is( $foo, $bar,   'Is foo the same as bar?' );
  
  Will produce something like this:
  
      not ok 17 - Is foo the same as bar?
      #   Failed test 'Is foo the same as bar?'
      #   in foo.t at line 139.
      #          got: 'waffle'
      #     expected: 'yarblokos'
  
  So you can figure out what went wrong without rerunning the test.
  
  You are encouraged to use C<is()> and C<isnt()> over C<ok()> where possible,
  however do not be tempted to use them to find out if something is
  true or false!
  
    # XXX BAD!
    is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );
  
  This does not check if C<exists $brooklyn{tree}> is true, it checks if
  it returns 1.  Very different.  Similar caveats exist for false and 0.
  In these cases, use C<ok()>.
  
    ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );
  
  A simple call to C<isnt()> usually does not provide a strong test but there
  are cases when you cannot say much more about a value than that it is
  different from some other value:
  
    new_ok $obj, "Foo";
  
    my $clone = $obj->clone;
    isa_ok $obj, "Foo", "Foo->clone";
  
    isnt $obj, $clone, "clone() produces a different object";
  
  For those grammatical pedants out there, there's an C<isn't()>
  function which is an alias of C<isnt()>.
  
  =cut
  
  sub is ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->is_eq(@_);
  }
  
  sub isnt ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->isnt_eq(@_);
  }
  
  *isn't = \&isnt;
  # ' to unconfuse syntax higlighters
  
  =item B<like>
  
    like( $got, qr/expected/, $test_name );
  
  Similar to C<ok()>, C<like()> matches $got against the regex C<qr/expected/>.
  
  So this:
  
      like($got, qr/expected/, 'this is like that');
  
  is similar to:
  
      ok( $got =~ m/expected/, 'this is like that');
  
  (Mnemonic "This is like that".)
  
  The second argument is a regular expression.  It may be given as a
  regex reference (i.e. C<qr//>) or (for better compatibility with older
  perls) as a string that looks like a regex (alternative delimiters are
  currently not supported):
  
      like( $got, '/expected/', 'this is like that' );
  
  Regex options may be placed on the end (C<'/expected/i'>).
  
  Its advantages over C<ok()> are similar to that of C<is()> and C<isnt()>.  Better
  diagnostics on failure.
  
  =cut
  
  sub like ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->like(@_);
  }
  
  =item B<unlike>
  
    unlike( $got, qr/expected/, $test_name );
  
  Works exactly as C<like()>, only it checks if $got B<does not> match the
  given pattern.
  
  =cut
  
  sub unlike ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->unlike(@_);
  }
  
  =item B<cmp_ok>
  
    cmp_ok( $got, $op, $expected, $test_name );
  
  Halfway between C<ok()> and C<is()> lies C<cmp_ok()>.  This allows you
  to compare two arguments using any binary perl operator.  The test
  passes if the comparison is true and fails otherwise.
  
      # ok( $got eq $expected );
      cmp_ok( $got, 'eq', $expected, 'this eq that' );
  
      # ok( $got == $expected );
      cmp_ok( $got, '==', $expected, 'this == that' );
  
      # ok( $got && $expected );
      cmp_ok( $got, '&&', $expected, 'this && that' );
      ...etc...
  
  Its advantage over C<ok()> is when the test fails you'll know what $got
  and $expected were:
  
      not ok 1
      #   Failed test in foo.t at line 12.
      #     '23'
      #         &&
      #     undef
  
  It's also useful in those cases where you are comparing numbers and
  C<is()>'s use of C<eq> will interfere:
  
      cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );
  
  It's especially useful when comparing greater-than or smaller-than 
  relation between values:
  
      cmp_ok( $some_value, '<=', $upper_limit );
  
  
  =cut
  
  sub cmp_ok($$$;$) {
      my $tb = Test::More->builder;
  
      return $tb->cmp_ok(@_);
  }
  
  =item B<can_ok>
  
    can_ok($module, @methods);
    can_ok($object, @methods);
  
  Checks to make sure the $module or $object can do these @methods
  (works with functions, too).
  
      can_ok('Foo', qw(this that whatever));
  
  is almost exactly like saying:
  
      ok( Foo->can('this') && 
          Foo->can('that') && 
          Foo->can('whatever') 
        );
  
  only without all the typing and with a better interface.  Handy for
  quickly testing an interface.
  
  No matter how many @methods you check, a single C<can_ok()> call counts
  as one test.  If you desire otherwise, use:
  
      foreach my $meth (@methods) {
          can_ok('Foo', $meth);
      }
  
  =cut
  
  sub can_ok ($@) {
      my( $proto, @methods ) = @_;
      my $class = ref $proto || $proto;
      my $tb = Test::More->builder;
  
      unless($class) {
          my $ok = $tb->ok( 0, "->can(...)" );
          $tb->diag('    can_ok() called with empty class or reference');
          return $ok;
      }
  
      unless(@methods) {
          my $ok = $tb->ok( 0, "$class->can(...)" );
          $tb->diag('    can_ok() called with no methods');
          return $ok;
      }
  
      my @nok = ();
      foreach my $method (@methods) {
          $tb->_try( sub { $proto->can($method) } ) or push @nok, $method;
      }
  
      my $name = (@methods == 1) ? "$class->can('$methods[0]')" :
                                   "$class->can(...)"           ;
  
      my $ok = $tb->ok( !@nok, $name );
  
      $tb->diag( map "    $class->can('$_') failed\n", @nok );
  
      return $ok;
  }
  
  =item B<isa_ok>
  
    isa_ok($object,   $class, $object_name);
    isa_ok($subclass, $class, $object_name);
    isa_ok($ref,      $type,  $ref_name);
  
  Checks to see if the given C<< $object->isa($class) >>.  Also checks to make
  sure the object was defined in the first place.  Handy for this sort
  of thing:
  
      my $obj = Some::Module->new;
      isa_ok( $obj, 'Some::Module' );
  
  where you'd otherwise have to write
  
      my $obj = Some::Module->new;
      ok( defined $obj && $obj->isa('Some::Module') );
  
  to safeguard against your test script blowing up.
  
  You can also test a class, to make sure that it has the right ancestor:
  
      isa_ok( 'Vole', 'Rodent' );
  
  It works on references, too:
  
      isa_ok( $array_ref, 'ARRAY' );
  
  The diagnostics of this test normally just refer to 'the object'.  If
  you'd like them to be more specific, you can supply an $object_name
  (for example 'Test customer').
  
  =cut
  
  sub isa_ok ($$;$) {
      my( $thing, $class, $thing_name ) = @_;
      my $tb = Test::More->builder;
  
      my $whatami;
      if( !defined $thing ) {
          $whatami = 'undef';
      }
      elsif( ref $thing ) {
          $whatami = 'reference';
  
          local($@,$!);
          require Scalar::Util;
          if( Scalar::Util::blessed($thing) ) {
              $whatami = 'object';
          }
      }
      else {
          $whatami = 'class';
      }
  
      # We can't use UNIVERSAL::isa because we want to honor isa() overrides
      my( $rslt, $error ) = $tb->_try( sub { $thing->isa($class) } );
  
      if($error) {
          die <<WHOA unless $error =~ /^Can't (locate|call) method "isa"/;
  WHOA! I tried to call ->isa on your $whatami and got some weird error.
  Here's the error.
  $error
  WHOA
      }
  
      # Special case for isa_ok( [], "ARRAY" ) and like
      if( $whatami eq 'reference' ) {
          $rslt = UNIVERSAL::isa($thing, $class);
      }
  
      my($diag, $name);
      if( defined $thing_name ) {
          $name = "'$thing_name' isa '$class'";
          $diag = defined $thing ? "'$thing_name' isn't a '$class'" : "'$thing_name' isn't defined";
      }
      elsif( $whatami eq 'object' ) {
          my $my_class = ref $thing;
          $thing_name = qq[An object of class '$my_class'];
          $name = "$thing_name isa '$class'";
          $diag = "The object of class '$my_class' isn't a '$class'";
      }
      elsif( $whatami eq 'reference' ) {
          my $type = ref $thing;
          $thing_name = qq[A reference of type '$type'];
          $name = "$thing_name isa '$class'";
          $diag = "The reference of type '$type' isn't a '$class'";
      }
      elsif( $whatami eq 'undef' ) {
          $thing_name = 'undef';
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't defined";
      }
      elsif( $whatami eq 'class' ) {
          $thing_name = qq[The class (or class-like) '$thing'];
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't a '$class'";
      }
      else {
          die;
      }
  
      my $ok;
      if($rslt) {
          $ok = $tb->ok( 1, $name );
      }
      else {
          $ok = $tb->ok( 0, $name );
          $tb->diag("    $diag\n");
      }
  
      return $ok;
  }
  
  =item B<new_ok>
  
    my $obj = new_ok( $class );
    my $obj = new_ok( $class => \@args );
    my $obj = new_ok( $class => \@args, $object_name );
  
  A convenience function which combines creating an object and calling
  C<isa_ok()> on that object.
  
  It is basically equivalent to:
  
      my $obj = $class->new(@args);
      isa_ok $obj, $class, $object_name;
  
  If @args is not given, an empty list will be used.
  
  This function only works on C<new()> and it assumes C<new()> will return
  just a single object which isa C<$class>.
  
  =cut
  
  sub new_ok {
      my $tb = Test::More->builder;
      $tb->croak("new_ok() must be given at least a class") unless @_;
  
      my( $class, $args, $object_name ) = @_;
  
      $args ||= [];
  
      my $obj;
      my( $success, $error ) = $tb->_try( sub { $obj = $class->new(@$args); 1 } );
      if($success) {
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          isa_ok $obj, $class, $object_name;
      }
      else {
          $class = 'undef' if !defined $class;
          $tb->ok( 0, "$class->new() died" );
          $tb->diag("    Error was:  $error");
      }
  
      return $obj;
  }
  
  =item B<subtest>
  
      subtest $name => \&code, @args;
  
  C<subtest()> runs the &code as its own little test with its own plan and
  its own result.  The main test counts this as a single test using the
  result of the whole subtest to determine if its ok or not ok.
  
  For example...
  
    use Test::More tests => 3;
   
    pass("First test");
  
    subtest 'An example subtest' => sub {
        plan tests => 2;
  
        pass("This is a subtest");
        pass("So is this");
    };
  
    pass("Third test");
  
  This would produce.
  
    1..3
    ok 1 - First test
        # Subtest: An example subtest
        1..2
        ok 1 - This is a subtest
        ok 2 - So is this
    ok 2 - An example subtest
    ok 3 - Third test
  
  A subtest may call C<skip_all>.  No tests will be run, but the subtest is
  considered a skip.
  
    subtest 'skippy' => sub {
        plan skip_all => 'cuz I said so';
        pass('this test will never be run');
    };
  
  Returns true if the subtest passed, false otherwise.
  
  Due to how subtests work, you may omit a plan if you desire.  This adds an
  implicit C<done_testing()> to the end of your subtest.  The following two
  subtests are equivalent:
  
    subtest 'subtest with implicit done_testing()', sub {
        ok 1, 'subtests with an implicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
    };
  
    subtest 'subtest with explicit done_testing()', sub {
        ok 1, 'subtests with an explicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
        done_testing();
    };
  
  Extra arguments given to C<subtest> are passed to the callback. For example:
  
      sub my_subtest {
          my $range = shift;
          ...
      }
  
      for my $range (1, 10, 100, 1000) {
          subtest "testing range $range", \&my_subtest, $range;
      }
  
  =cut
  
  sub subtest {
      my $tb = Test::More->builder;
      return $tb->subtest(@_);
  }
  
  =item B<pass>
  
  =item B<fail>
  
    pass($test_name);
    fail($test_name);
  
  Sometimes you just want to say that the tests have passed.  Usually
  the case is you've got some complicated condition that is difficult to
  wedge into an C<ok()>.  In this case, you can simply use C<pass()> (to
  declare the test ok) or fail (for not ok).  They are synonyms for
  C<ok(1)> and C<ok(0)>.
  
  Use these very, very, very sparingly.
  
  =cut
  
  sub pass (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 1, @_ );
  }
  
  sub fail (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 0, @_ );
  }
  
  =back
  
  
  =head2 Module tests
  
  Sometimes you want to test if a module, or a list of modules, can
  successfully load.  For example, you'll often want a first test which
  simply loads all the modules in the distribution to make sure they
  work before going on to do more complicated testing.
  
  For such purposes we have C<use_ok> and C<require_ok>.
  
  =over 4
  
  =item B<require_ok>
  
     require_ok($module);
     require_ok($file);
  
  Tries to C<require> the given $module or $file.  If it loads
  successfully, the test will pass.  Otherwise it fails and displays the
  load error.
  
  C<require_ok> will guess whether the input is a module name or a
  filename.
  
  No exception will be thrown if the load fails.
  
      # require Some::Module
      require_ok "Some::Module";
  
      # require "Some/File.pl";
      require_ok "Some/File.pl";
  
      # stop testing if any of your modules will not load
      for my $module (@module) {
          require_ok $module or BAIL_OUT "Can't load $module";
      }
  
  =cut
  
  sub require_ok ($) {
      my($module) = shift;
      my $tb = Test::More->builder;
  
      my $pack = caller;
  
      # Try to determine if we've been given a module name or file.
      # Module names must be barewords, files not.
      $module = qq['$module'] unless _is_module_name($module);
  
      my $code = <<REQUIRE;
  package $pack;
  require $module;
  1;
  REQUIRE
  
      my( $eval_result, $eval_error ) = _eval($code);
      my $ok = $tb->ok( $eval_result, "require $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $tb->diag(<<DIAGNOSTIC);
      Tried to require '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _is_module_name {
      my $module = shift;
  
      # Module names start with a letter.
      # End with an alphanumeric.
      # The rest is an alphanumeric or ::
      $module =~ s/\b::\b//g;
  
      return $module =~ /^[a-zA-Z]\w*$/ ? 1 : 0;
  }
  
  
  =item B<use_ok>
  
     BEGIN { use_ok($module); }
     BEGIN { use_ok($module, @imports); }
  
  Like C<require_ok>, but it will C<use> the $module in question and
  only loads modules, not files.
  
  If you just want to test a module can be loaded, use C<require_ok>.
  
  If you just want to load a module in a test, we recommend simply using
  C<use> directly.  It will cause the test to stop.
  
  It's recommended that you run C<use_ok()> inside a BEGIN block so its
  functions are exported at compile-time and prototypes are properly
  honored.
  
  If @imports are given, they are passed through to the use.  So this:
  
     BEGIN { use_ok('Some::Module', qw(foo bar)) }
  
  is like doing this:
  
     use Some::Module qw(foo bar);
  
  Version numbers can be checked like so:
  
     # Just like "use Some::Module 1.02"
     BEGIN { use_ok('Some::Module', 1.02) }
  
  Don't try to do this:
  
     BEGIN {
         use_ok('Some::Module');
  
         ...some code that depends on the use...
         ...happening at compile time...
     }
  
  because the notion of "compile-time" is relative.  Instead, you want:
  
    BEGIN { use_ok('Some::Module') }
    BEGIN { ...some code that depends on the use... }
  
  If you want the equivalent of C<use Foo ()>, use a module but not
  import anything, use C<require_ok>.
  
    BEGIN { require_ok "Foo" }
  
  =cut
  
  sub use_ok ($;@) {
      my( $module, @imports ) = @_;
      @imports = () unless @imports;
      my $tb = Test::More->builder;
  
      my %caller;
      @caller{qw/pack file line sub args want eval req strict warn/} = caller(0);
  
      my ($pack, $filename, $line, $warn) = @caller{qw/pack file line warn/};
      $filename =~ y/\n\r/_/; # so it doesn't run off the "#line $line $f" line
  
      my $code;
      if( @imports == 1 and $imports[0] =~ /^\d+(?:\.\d+)?$/ ) {
          # probably a version check.  Perl needs to see the bare number
          # for it to work with non-Exporter based modules.
          $code = <<USE;
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module $imports[0];
  1;
  USE
      }
      else {
          $code = <<USE;
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module \@{\$args[0]};
  1;
  USE
      }
  
      my ($eval_result, $eval_error) = _eval($code, \@imports, $warn);
      my $ok = $tb->ok( $eval_result, "use $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $@ =~ s{^BEGIN failed--compilation aborted at .*$}
                  {BEGIN failed--compilation aborted at $filename line $line.}m;
          $tb->diag(<<DIAGNOSTIC);
      Tried to use '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _eval {
      my( $code, @args ) = @_;
  
      # Work around oddities surrounding resetting of $@ by immediately
      # storing it.
      my( $sigdie, $eval_result, $eval_error );
      {
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
          $eval_result = eval $code;              ## no critic (BuiltinFunctions::ProhibitStringyEval)
          $eval_error  = $@;
          $sigdie      = $SIG{__DIE__} || undef;
      }
      # make sure that $code got a chance to set $SIG{__DIE__}
      $SIG{__DIE__} = $sigdie if defined $sigdie;
  
      return( $eval_result, $eval_error );
  }
  
  
  =back
  
  
  =head2 Complex data structures
  
  Not everything is a simple eq check or regex.  There are times you
  need to see if two data structures are equivalent.  For these
  instances Test::More provides a handful of useful functions.
  
  B<NOTE> I'm not quite sure what will happen with filehandles.
  
  =over 4
  
  =item B<is_deeply>
  
    is_deeply( $got, $expected, $test_name );
  
  Similar to C<is()>, except that if $got and $expected are references, it
  does a deep comparison walking each data structure to see if they are
  equivalent.  If the two structures are different, it will display the
  place where they start differing.
  
  C<is_deeply()> compares the dereferenced values of references, the
  references themselves (except for their type) are ignored.  This means
  aspects such as blessing and ties are not considered "different".
  
  C<is_deeply()> currently has very limited handling of function reference
  and globs.  It merely checks if they have the same referent.  This may
  improve in the future.
  
  L<Test::Differences> and L<Test::Deep> provide more in-depth functionality
  along these lines.
  
  B<NOTE> is_deeply() has limitations when it comes to comparing strings and
  refs:
  
      my $path = path('.');
      my $hash = {};
      is_deeply( $path, "$path" ); # ok
      is_deeply( $hash, "$hash" ); # fail
  
  This happens because is_deeply will unoverload all arguments unconditionally.
  It is probably best not to use is_deeply with overloading. For legacy reasons
  this is not likely to ever be fixed. If you would like a much better tool for
  this you should see L<Test2::Suite> Specifically L<Test2::Tools::Compare> has
  an C<is()> function that works like C<is_deeply> with many improvements.
  
  =cut
  
  our( @Data_Stack, %Refs_Seen );
  my $DNE = bless [], 'Does::Not::Exist';
  
  sub _dne {
      return ref $_[0] eq ref $DNE;
  }
  
  ## no critic (Subroutines::RequireArgUnpacking)
  sub is_deeply {
      my $tb = Test::More->builder;
  
      unless( @_ == 2 or @_ == 3 ) {
          my $msg = <<'WARNING';
  is_deeply() takes two or three args, you gave %d.
  This usually means you passed an array or hash instead 
  of a reference to it
  WARNING
          chop $msg;    # clip off newline so carp() will put in line/file
  
          _carp sprintf $msg, scalar @_;
  
          return $tb->ok(0);
      }
  
      my( $got, $expected, $name ) = @_;
  
      $tb->_unoverload_str( \$expected, \$got );
  
      my $ok;
      if( !ref $got and !ref $expected ) {    # neither is a reference
          $ok = $tb->is_eq( $got, $expected, $name );
      }
      elsif( !ref $got xor !ref $expected ) {    # one's a reference, one isn't
          $ok = $tb->ok( 0, $name );
          $tb->diag( _format_stack({ vals => [ $got, $expected ] }) );
      }
      else {                                     # both references
          local @Data_Stack = ();
          if( _deep_check( $got, $expected ) ) {
              $ok = $tb->ok( 1, $name );
          }
          else {
              $ok = $tb->ok( 0, $name );
              $tb->diag( _format_stack(@Data_Stack) );
          }
      }
  
      return $ok;
  }
  
  sub _format_stack {
      my(@Stack) = @_;
  
      my $var       = '$FOO';
      my $did_arrow = 0;
      foreach my $entry (@Stack) {
          my $type = $entry->{type} || '';
          my $idx = $entry->{'idx'};
          if( $type eq 'HASH' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "{$idx}";
          }
          elsif( $type eq 'ARRAY' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "[$idx]";
          }
          elsif( $type eq 'REF' ) {
              $var = "\${$var}";
          }
      }
  
      my @vals = @{ $Stack[-1]{vals} }[ 0, 1 ];
      my @vars = ();
      ( $vars[0] = $var ) =~ s/\$FOO/     \$got/;
      ( $vars[1] = $var ) =~ s/\$FOO/\$expected/;
  
      my $out = "Structures begin differing at:\n";
      foreach my $idx ( 0 .. $#vals ) {
          my $val = $vals[$idx];
          $vals[$idx]
            = !defined $val ? 'undef'
            : _dne($val)    ? "Does not exist"
            : ref $val      ? "$val"
            :                 "'$val'";
      }
  
      $out .= "$vars[0] = $vals[0]\n";
      $out .= "$vars[1] = $vals[1]\n";
  
      $out =~ s/^/    /msg;
      return $out;
  }
  
  sub _type {
      my $thing = shift;
  
      return '' if !ref $thing;
  
      for my $type (qw(Regexp ARRAY HASH REF SCALAR GLOB CODE VSTRING)) {
          return $type if UNIVERSAL::isa( $thing, $type );
      }
  
      return '';
  }
  
  =back
  
  
  =head2 Diagnostics
  
  If you pick the right test function, you'll usually get a good idea of
  what went wrong when it failed.  But sometimes it doesn't work out
  that way.  So here we have ways for you to write your own diagnostic
  messages which are safer than just C<print STDERR>.
  
  =over 4
  
  =item B<diag>
  
    diag(@diagnostic_message);
  
  Prints a diagnostic message which is guaranteed not to interfere with
  test output.  Like C<print> @diagnostic_message is simply concatenated
  together.
  
  Returns false, so as to preserve failure.
  
  Handy for this sort of thing:
  
      ok( grep(/foo/, @users), "There's a foo user" ) or
          diag("Since there's no foo, check that /etc/bar is set up right");
  
  which would produce:
  
      not ok 42 - There's a foo user
      #   Failed test 'There's a foo user'
      #   in foo.t at line 52.
      # Since there's no foo, check that /etc/bar is set up right.
  
  You might remember C<ok() or diag()> with the mnemonic C<open() or
  die()>.
  
  B<NOTE> The exact formatting of the diagnostic output is still
  changing, but it is guaranteed that whatever you throw at it won't
  interfere with the test.
  
  =item B<note>
  
    note(@diagnostic_message);
  
  Like C<diag()>, except the message will not be seen when the test is run
  in a harness.  It will only be visible in the verbose TAP stream.
  
  Handy for putting in notes which might be useful for debugging, but
  don't indicate a problem.
  
      note("Tempfile is $tempfile");
  
  =cut
  
  sub diag {
      return Test::More->builder->diag(@_);
  }
  
  sub note {
      return Test::More->builder->note(@_);
  }
  
  =item B<explain>
  
    my @dump = explain @diagnostic_message;
  
  Will dump the contents of any references in a human readable format.
  Usually you want to pass this into C<note> or C<diag>.
  
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      note explain \%args;
      Some::Class->method(%args);
  
  =cut
  
  sub explain {
      return Test::More->builder->explain(@_);
  }
  
  =back
  
  
  =head2 Conditional tests
  
  Sometimes running a test under certain conditions will cause the
  test script to die.  A certain function or method isn't implemented
  (such as C<fork()> on MacOS), some resource isn't available (like a 
  net connection) or a module isn't available.  In these cases it's
  necessary to skip tests, or declare that they are supposed to fail
  but will work in the future (a todo test).
  
  For more details on the mechanics of skip and todo tests see
  L<Test::Harness>.
  
  The way Test::More handles this is with a named block.  Basically, a
  block of tests which can be skipped over or made todo.  It's best if I
  just show you...
  
  =over 4
  
  =item B<SKIP: BLOCK>
  
    SKIP: {
        skip $why, $how_many if $condition;
  
        ...normal testing code goes here...
    }
  
  This declares a block of tests that might be skipped, $how_many tests
  there are, $why and under what $condition to skip them.  An example is
  the easiest way to illustrate:
  
      SKIP: {
          eval { require HTML::Lint };
  
          skip "HTML::Lint not installed", 2 if $@;
  
          my $lint = new HTML::Lint;
          isa_ok( $lint, "HTML::Lint" );
  
          $lint->parse( $html );
          is( $lint->errors, 0, "No errors found in HTML" );
      }
  
  If the user does not have HTML::Lint installed, the whole block of
  code I<won't be run at all>.  Test::More will output special ok's
  which Test::Harness interprets as skipped, but passing, tests.
  
  It's important that $how_many accurately reflects the number of tests
  in the SKIP block so the # of tests run will match up with your plan.
  If your plan is C<no_plan> $how_many is optional and will default to 1.
  
  It's perfectly safe to nest SKIP blocks.  Each SKIP block must have
  the label C<SKIP>, or Test::More can't work its magic.
  
  You don't skip tests which are failing because there's a bug in your
  program, or for which you don't yet have code written.  For that you
  use TODO.  Read on.
  
  =cut
  
  ## no critic (Subroutines::RequireFinalReturn)
  sub skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      # If the plan is set, and is static, then skip needs a count. If the plan
      # is 'no_plan' we are fine. As well if plan is undefined then we are
      # waiting for done_testing.
      unless (defined $how_many) {
          my $plan = $tb->has_plan;
          _carp "skip() needs to know \$how_many tests are in the block"
              if $plan && $plan =~ m/^\d+$/;
          $how_many = 1;
      }
  
      if( defined $how_many and $how_many =~ /\D/ ) {
          _carp
            "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->skip($why);
      }
  
      no warnings 'exiting';
      last SKIP;
  }
  
  =item B<TODO: BLOCK>
  
      TODO: {
          local $TODO = $why if $condition;
  
          ...normal testing code goes here...
      }
  
  Declares a block of tests you expect to fail and $why.  Perhaps it's
  because you haven't fixed a bug or haven't finished a new feature:
  
      TODO: {
          local $TODO = "URI::Geller not finished";
  
          my $card = "Eight of clubs";
          is( URI::Geller->your_card, $card, 'Is THIS your card?' );
  
          my $spoon;
          URI::Geller->bend_spoon;
          is( $spoon, 'bent',    "Spoon bending, that's original" );
      }
  
  With a todo block, the tests inside are expected to fail.  Test::More
  will run the tests normally, but print out special flags indicating
  they are "todo".  L<Test::Harness> will interpret failures as being ok.
  Should anything succeed, it will report it as an unexpected success.
  You then know the thing you had todo is done and can remove the
  TODO flag.
  
  The nice part about todo tests, as opposed to simply commenting out a
  block of tests, is it's like having a programmatic todo list.  You know
  how much work is left to be done, you're aware of what bugs there are,
  and you'll know immediately when they're fixed.
  
  Once a todo test starts succeeding, simply move it outside the block.
  When the block is empty, delete it.
  
  
  =item B<todo_skip>
  
      TODO: {
          todo_skip $why, $how_many if $condition;
  
          ...normal testing code...
      }
  
  With todo tests, it's best to have the tests actually run.  That way
  you'll know when they start passing.  Sometimes this isn't possible.
  Often a failing test will cause the whole program to die or hang, even
  inside an C<eval BLOCK> with and using C<alarm>.  In these extreme
  cases you have no choice but to skip over the broken tests entirely.
  
  The syntax and behavior is similar to a C<SKIP: BLOCK> except the
  tests will be marked as failing but todo.  L<Test::Harness> will
  interpret them as passing.
  
  =cut
  
  sub todo_skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      unless( defined $how_many ) {
          # $how_many can only be avoided when no_plan is in use.
          _carp "todo_skip() needs to know \$how_many tests are in the block"
            unless $tb->has_plan eq 'no_plan';
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->todo_skip($why);
      }
  
      no warnings 'exiting';
      last TODO;
  }
  
  =item When do I use SKIP vs. TODO?
  
  B<If it's something the user might not be able to do>, use SKIP.
  This includes optional modules that aren't installed, running under
  an OS that doesn't have some feature (like C<fork()> or symlinks), or maybe
  you need an Internet connection and one isn't available.
  
  B<If it's something the programmer hasn't done yet>, use TODO.  This
  is for any code you haven't written yet, or bugs you have yet to fix,
  but want to put tests in your testing script (always a good idea).
  
  
  =back
  
  
  =head2 Test control
  
  =over 4
  
  =item B<BAIL_OUT>
  
      BAIL_OUT($reason);
  
  Indicates to the harness that things are going so badly all testing
  should terminate.  This includes the running of any additional test scripts.
  
  This is typically used when testing cannot continue such as a critical
  module failing to compile or a necessary external utility not being
  available such as a database connection failing.
  
  The test will exit with 255.
  
  For even better control look at L<Test::Most>.
  
  =cut
  
  sub BAIL_OUT {
      my $reason = shift;
      my $tb     = Test::More->builder;
  
      $tb->BAIL_OUT($reason);
  }
  
  =back
  
  
  =head2 Discouraged comparison functions
  
  The use of the following functions is discouraged as they are not
  actually testing functions and produce no diagnostics to help figure
  out what went wrong.  They were written before C<is_deeply()> existed
  because I couldn't figure out how to display a useful diff of two
  arbitrary data structures.
  
  These functions are usually used inside an C<ok()>.
  
      ok( eq_array(\@got, \@expected) );
  
  C<is_deeply()> can do that better and with diagnostics.  
  
      is_deeply( \@got, \@expected );
  
  They may be deprecated in future versions.
  
  =over 4
  
  =item B<eq_array>
  
    my $is_eq = eq_array(\@got, \@expected);
  
  Checks if two arrays are equivalent.  This is a deep check, so
  multi-level structures are handled correctly.
  
  =cut
  
  #'#
  sub eq_array {
      local @Data_Stack = ();
      _deep_check(@_);
  }
  
  sub _eq_array {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'ARRAY', $a1, $a2 ) {
          warn "eq_array passed a non-array ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
      for( 0 .. $max ) {
          my $e1 = $_ > $#$a1 ? $DNE : $a1->[$_];
          my $e2 = $_ > $#$a2 ? $DNE : $a2->[$_];
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'ARRAY', idx => $_, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  sub _equal_nonrefs {
      my( $e1, $e2 ) = @_;
  
      return if ref $e1 or ref $e2;
  
      if ( defined $e1 ) {
          return 1 if defined $e2 and $e1 eq $e2;
      }
      else {
          return 1 if !defined $e2;
      }
  
      return;
  }
  
  sub _deep_check {
      my( $e1, $e2 ) = @_;
      my $tb = Test::More->builder;
  
      my $ok = 0;
  
      # Effectively turn %Refs_Seen into a stack.  This avoids picking up
      # the same referenced used twice (such as [\$a, \$a]) to be considered
      # circular.
      local %Refs_Seen = %Refs_Seen;
  
      {
          $tb->_unoverload_str( \$e1, \$e2 );
  
          # Either they're both references or both not.
          my $same_ref = !( !ref $e1 xor !ref $e2 );
          my $not_ref = ( !ref $e1 and !ref $e2 );
  
          if( defined $e1 xor defined $e2 ) {
              $ok = 0;
          }
          elsif( !defined $e1 and !defined $e2 ) {
              # Shortcut if they're both undefined.
              $ok = 1;
          }
          elsif( _dne($e1) xor _dne($e2) ) {
              $ok = 0;
          }
          elsif( $same_ref and( $e1 eq $e2 ) ) {
              $ok = 1;
          }
          elsif($not_ref) {
              push @Data_Stack, { type => '', vals => [ $e1, $e2 ] };
              $ok = 0;
          }
          else {
              if( $Refs_Seen{$e1} ) {
                  return $Refs_Seen{$e1} eq $e2;
              }
              else {
                  $Refs_Seen{$e1} = "$e2";
              }
  
              my $type = _type($e1);
              $type = 'DIFFERENT' unless _type($e2) eq $type;
  
              if( $type eq 'DIFFERENT' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              elsif( $type eq 'ARRAY' ) {
                  $ok = _eq_array( $e1, $e2 );
              }
              elsif( $type eq 'HASH' ) {
                  $ok = _eq_hash( $e1, $e2 );
              }
              elsif( $type eq 'REF' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif( $type eq 'SCALAR' ) {
                  push @Data_Stack, { type => 'REF', vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif($type) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              else {
                  _whoa( 1, "No type in _deep_check" );
              }
          }
      }
  
      return $ok;
  }
  
  sub _whoa {
      my( $check, $desc ) = @_;
      if($check) {
          die <<"WHOA";
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
      }
  }
  
  =item B<eq_hash>
  
    my $is_eq = eq_hash(\%got, \%expected);
  
  Determines if the two hashes contain the same keys and values.  This
  is a deep check.
  
  =cut
  
  sub eq_hash {
      local @Data_Stack = ();
      return _deep_check(@_);
  }
  
  sub _eq_hash {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'HASH', $a1, $a2 ) {
          warn "eq_hash passed a non-hash ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $bigger = keys %$a1 > keys %$a2 ? $a1 : $a2;
      foreach my $k ( keys %$bigger ) {
          my $e1 = exists $a1->{$k} ? $a1->{$k} : $DNE;
          my $e2 = exists $a2->{$k} ? $a2->{$k} : $DNE;
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'HASH', idx => $k, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  =item B<eq_set>
  
    my $is_eq = eq_set(\@got, \@expected);
  
  Similar to C<eq_array()>, except the order of the elements is B<not>
  important.  This is a deep check, but the irrelevancy of order only
  applies to the top level.
  
      ok( eq_set(\@got, \@expected) );
  
  Is better written:
  
      is_deeply( [sort @got], [sort @expected] );
  
  B<NOTE> By historical accident, this is not a true set comparison.
  While the order of elements does not matter, duplicate elements do.
  
  B<NOTE> C<eq_set()> does not know how to deal with references at the top
  level.  The following is an example of a comparison which might not work:
  
      eq_set([\1, \2], [\2, \1]);
  
  L<Test::Deep> contains much better set comparison functions.
  
  =cut
  
  sub eq_set {
      my( $a1, $a2 ) = @_;
      return 0 unless @$a1 == @$a2;
  
      no warnings 'uninitialized';
  
      # It really doesn't matter how we sort them, as long as both arrays are
      # sorted with the same algorithm.
      #
      # Ensure that references are not accidentally treated the same as a
      # string containing the reference.
      #
      # Have to inline the sort routine due to a threading/sort bug.
      # See [rt.cpan.org 6782]
      #
      # I don't know how references would be sorted so we just don't sort
      # them.  This means eq_set doesn't really work with refs.
      return eq_array(
          [ grep( ref, @$a1 ), sort( grep( !ref, @$a1 ) ) ],
          [ grep( ref, @$a2 ), sort( grep( !ref, @$a2 ) ) ],
      );
  }
  
  =back
  
  
  =head2 Extending and Embedding Test::More
  
  Sometimes the Test::More interface isn't quite enough.  Fortunately,
  Test::More is built on top of L<Test::Builder> which provides a single,
  unified backend for any test library to use.  This means two test
  libraries which both use <Test::Builder> B<can> be used together in the
  same program>.
  
  If you simply want to do a little tweaking of how the tests behave,
  you can access the underlying L<Test::Builder> object like so:
  
  =over 4
  
  =item B<builder>
  
      my $test_builder = Test::More->builder;
  
  Returns the L<Test::Builder> object underlying Test::More for you to play
  with.
  
  
  =back
  
  
  =head1 EXIT CODES
  
  If all your tests passed, L<Test::Builder> will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run L<Test::Builder>
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  B<NOTE>  This behavior may go away in future versions.
  
  
  =head1 COMPATIBILITY
  
  Test::More works with Perls as old as 5.8.1.
  
  Thread support is not very reliable before 5.10.1, but that's
  because threads are not very reliable before 5.10.1.
  
  Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use C<done_testing()> but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More > 0.88.
  
  Key feature milestones include:
  
  =over 4
  
  =item subtests
  
  Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call C<done_testing()> until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.
  
  =item C<done_testing()>
  
  This was released in Test::More 0.88 and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =item C<cmp_ok()>
  
  Although C<cmp_ok()> was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.
  
  =item C<new_ok()> C<note()> and C<explain()>
  
  These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =back
  
  There is a full version history in the Changes file, and the Test::More versions included as core can be found using L<Module::CoreList>:
  
      $ corelist -a Test::More
  
  
  =head1 CAVEATS and NOTES
  
  =over 4
  
  =item utf8 / "Wide character in print"
  
  If you use utf8 or other non-ASCII characters with Test::More you
  might get a "Wide character in print" warning.  Using
  C<< binmode STDOUT, ":utf8" >> will not fix it.
  L<Test::Builder> (which powers
  Test::More) duplicates STDOUT and STDERR.  So any changes to them,
  including changing their output disciplines, will not be seem by
  Test::More.
  
  One work around is to apply encodings to STDOUT and STDERR as early
  as possible and before Test::More (or any other Test module) loads.
  
      use open ':std', ':encoding(utf8)';
      use Test::More;
  
  A more direct work around is to change the filehandles used by
  L<Test::Builder>.
  
      my $builder = Test::More->builder;
      binmode $builder->output,         ":encoding(utf8)";
      binmode $builder->failure_output, ":encoding(utf8)";
      binmode $builder->todo_output,    ":encoding(utf8)";
  
  
  =item Overloaded objects
  
  String overloaded objects are compared B<as strings> (or in C<cmp_ok()>'s
  case, strings or numbers as appropriate to the comparison op).  This
  prevents Test::More from piercing an object's interface allowing
  better blackbox testing.  So if a function starts returning overloaded
  objects instead of bare strings your tests won't notice the
  difference.  This is good.
  
  However, it does mean that functions like C<is_deeply()> cannot be used to
  test the internals of string overloaded objects.  In this case I would
  suggest L<Test::Deep> which contains more flexible testing functions for
  complex data structures.
  
  
  =item Threads
  
  Test::More will only be aware of threads if C<use threads> has been done
  I<before> Test::More is loaded.  This is ok:
  
      use threads;
      use Test::More;
  
  This may cause problems:
  
      use Test::More
      use threads;
  
  5.8.1 and above are supported.  Anything below that has too many bugs.
  
  =back
  
  
  =head1 HISTORY
  
  This is a case of convergent evolution with Joshua Pritikin's L<Test>
  module.  I was largely unaware of its existence when I'd first
  written my own C<ok()> routines.  This module exists because I can't
  figure out how to easily wedge test names into Test's interface (along
  with a few other problems).
  
  The goal here is to have a testing utility that's simple to learn,
  quick to use and difficult to trip yourself up with while still
  providing more flexibility than the existing Test.pm.  As such, the
  names of the most common routines are kept tiny, special cases and
  magic side-effects are kept to a minimum.  WYSIWYG.
  
  
  =head1 SEE ALSO
  
  =head2
  
  =head2 ALTERNATIVES
  
  L<Test::Simple> if all this confuses you and you just want to write
  some tests.  You can upgrade to Test::More later (it's forward
  compatible).
  
  L<Test::Legacy> tests written with Test.pm, the original testing
  module, do not play well with other testing libraries.  Test::Legacy
  emulates the Test.pm interface and does play well with others.
  
  =head2 TESTING FRAMEWORKS
  
  L<Fennec> The Fennec framework is a testers toolbox. It uses L<Test::Builder>
  under the hood. It brings enhancements for forking, defining state, and
  mocking. Fennec enhances several modules to work better together than they
  would if you loaded them individually on your own.
  
  L<Fennec::Declare> Provides enhanced (L<Devel::Declare>) syntax for Fennec.
  
  =head2 ADDITIONAL LIBRARIES
  
  L<Test::Differences> for more ways to test complex data structures.
  And it plays well with Test::More.
  
  L<Test::Class> is like xUnit but more perlish.
  
  L<Test::Deep> gives you more powerful complex data structure testing.
  
  L<Test::Inline> shows the idea of embedded testing.
  
  L<Mock::Quick> The ultimate mocking library. Easily spawn objects defined on
  the fly. Can also override, block, or reimplement packages as needed.
  
  L<Test::FixtureBuilder> Quickly define fixture data for unit tests.
  
  =head2 OTHER COMPONENTS
  
  L<Test::Harness> is the test runner and output interpreter for Perl.
  It's the thing that powers C<make test> and where the C<prove> utility
  comes from.
  
  =head2 BUNDLES
  
  L<Test::Most> Most commonly needed test functions and features.
  
  =head1 AUTHORS
  
  Michael G Schwern E<lt>schwern@pobox.comE<gt> with much inspiration
  from Joshua Pritikin's Test module and lots of help from Barrie
  Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and
  the perl-qa gang.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  
  =head1 BUGS
  
  See F<https://github.com/Test-More/test-more/issues> to report and view bugs.
  
  
  =head1 SOURCE
  
  The source code repository for Test::More can be found at
  F<http://github.com/Test-More/test-more/>.
  
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
TEST_MORE

$fatpacked{"Test/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SIMPLE';
  package Test::Simple;
  
  use 5.006;
  
  use strict;
  
  our $VERSION = '1.302136';
  
  use Test::Builder::Module;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok);
  
  my $CLASS = __PACKAGE__;
  
  =head1 NAME
  
  Test::Simple - Basic utilities for writing tests.
  
  =head1 SYNOPSIS
  
    use Test::Simple tests => 1;
  
    ok( $foo eq $bar, 'foo is bar' );
  
  
  =head1 DESCRIPTION
  
  ** If you are unfamiliar with testing B<read L<Test::Tutorial> first!> **
  
  This is an extremely simple, extremely basic module for writing tests
  suitable for CPAN modules and other pursuits.  If you wish to do more
  complicated testing, use the Test::More module (a drop-in replacement
  for this one).
  
  The basic unit of Perl testing is the ok.  For each thing you want to
  test your program will print out an "ok" or "not ok" to indicate pass
  or fail.  You do this with the C<ok()> function (see below).
  
  The only other constraint is you must pre-declare how many tests you
  plan to run.  This is in case something goes horribly wrong during the
  test and your test program aborts, or skips a test or whatever.  You
  do this like so:
  
      use Test::Simple tests => 23;
  
  You must have a plan.
  
  
  =over 4
  
  =item B<ok>
  
    ok( $foo eq $bar, $name );
    ok( $foo eq $bar );
  
  C<ok()> is given an expression (in this case C<$foo eq $bar>).  If it's
  true, the test passed.  If it's false, it didn't.  That's about it.
  
  C<ok()> prints out either "ok" or "not ok" along with a test number (it
  keeps track of that for you).
  
    # This produces "ok 1 - Hell not yet frozen over" (or not ok)
    ok( get_temperature($hell) > 0, 'Hell not yet frozen over' );
  
  If you provide a $name, that will be printed along with the "ok/not
  ok" to make it easier to find your test when if fails (just search for
  the name).  It also makes it easier for the next guy to understand
  what your test is for.  It's highly recommended you use test names.
  
  All tests are run in scalar context.  So this:
  
      ok( @stuff, 'I have some stuff' );
  
  will do what you mean (fail if stuff is empty)
  
  =cut
  
  sub ok ($;$) {    ## no critic (Subroutines::ProhibitSubroutinePrototypes)
      return $CLASS->builder->ok(@_);
  }
  
  =back
  
  Test::Simple will start by printing number of tests run in the form
  "1..M" (so "1..5" means you're going to run 5 tests).  This strange
  format lets L<Test::Harness> know how many tests you plan on running in
  case something goes horribly wrong.
  
  If all your tests passed, Test::Simple will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Simple
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  This module is by no means trying to be a complete testing system.
  It's just to get you started.  Once you're off the ground its
  recommended you look at L<Test::More>.
  
  
  =head1 EXAMPLE
  
  Here's an example of a simple .t file for the fictional Film module.
  
      use Test::Simple tests => 5;
  
      use Film;  # What you're testing.
  
      my $btaste = Film->new({ Title    => 'Bad Taste',
                               Director => 'Peter Jackson',
                               Rating   => 'R',
                               NumExplodingSheep => 1
                             });
      ok( defined($btaste) && ref $btaste eq 'Film',     'new() works' );
  
      ok( $btaste->Title      eq 'Bad Taste',     'Title() get'    );
      ok( $btaste->Director   eq 'Peter Jackson', 'Director() get' );
      ok( $btaste->Rating     eq 'R',             'Rating() get'   );
      ok( $btaste->NumExplodingSheep == 1,        'NumExplodingSheep() get' );
  
  It will produce output like this:
  
      1..5
      ok 1 - new() works
      ok 2 - Title() get
      ok 3 - Director() get
      not ok 4 - Rating() get
      #   Failed test 'Rating() get'
      #   in t/film.t at line 14.
      ok 5 - NumExplodingSheep() get
      # Looks like you failed 1 tests of 5
  
  Indicating the Film::Rating() method is broken.
  
  
  =head1 CAVEATS
  
  Test::Simple will only report a maximum of 254 failures in its exit
  code.  If this is a problem, you probably have a huge test script.
  Split it into multiple files.  (Otherwise blame the Unix folks for
  using an unsigned short integer as the exit status).
  
  Because VMS's exit codes are much, much different than the rest of the
  universe, and perl does horrible mangling to them that gets in my way,
  it works like this on VMS.
  
      0     SS$_NORMAL        all tests successful
      4     SS$_ABORT         something went wrong
  
  Unfortunately, I can't differentiate any further.
  
  
  =head1 NOTES
  
  Test::Simple is B<explicitly> tested all the way back to perl 5.6.0.
  
  Test::Simple is thread-safe in perl 5.8.1 and up.
  
  =head1 HISTORY
  
  This module was conceived while talking with Tony Bowden in his
  kitchen one night about the problems I was having writing some really
  complicated feature into the new Testing module.  He observed that the
  main problem is not dealing with these edge cases but that people hate
  to write tests B<at all>.  What was needed was a dead simple module
  that took all the hard work out of testing and was really, really easy
  to learn.  Paul Johnson simultaneously had this idea (unfortunately,
  he wasn't in Tony's kitchen).  This is it.
  
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  More testing functions!  Once you outgrow Test::Simple, look at
  L<Test::More>.  Test::Simple is 100% forward compatible with L<Test::More>
  (i.e. you can just use L<Test::More> instead of Test::Simple in your
  programs and things will still work).
  
  =back
  
  Look in L<Test::More>'s SEE ALSO for more testing modules.
  
  
  =head1 AUTHORS
  
  Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>, wardrobe by Calvin Klein.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
TEST_SIMPLE

$fatpacked{"Test/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER';
  use strict;
  
  package Test::Tester;
  
  BEGIN
  {
  	if (*Test::Builder::new{CODE})
  	{
  		warn "You should load Test::Tester before Test::Builder (or anything that loads Test::Builder)"
  	}
  }
  
  use Test::Builder;
  use Test::Tester::CaptureRunner;
  use Test::Tester::Delegate;
  
  require Exporter;
  
  use vars qw( @ISA @EXPORT );
  
  our $VERSION = '1.302136';
  
  @EXPORT = qw( run_tests check_tests check_test cmp_results show_space );
  @ISA = qw( Exporter );
  
  my $Test = Test::Builder->new;
  my $Capture = Test::Tester::Capture->new;
  my $Delegator = Test::Tester::Delegate->new;
  $Delegator->{Object} = $Test;
  
  my $runner = Test::Tester::CaptureRunner->new;
  
  my $want_space = $ENV{TESTTESTERSPACE};
  
  sub show_space
  {
  	$want_space = 1;
  }
  
  my $colour = '';
  my $reset = '';
  
  if (my $want_colour = $ENV{TESTTESTERCOLOUR} || $ENV{TESTTESTERCOLOR})
  {
  	if (eval { require Term::ANSIColor; 1 })
  	{
  		eval { require Win32::Console::ANSI } if 'MSWin32' eq $^O;  # support color on windows platforms
  		my ($f, $b) = split(",", $want_colour);
  		$colour = Term::ANSIColor::color($f).Term::ANSIColor::color("on_$b");
  		$reset = Term::ANSIColor::color("reset");
  	}
  
  }
  
  sub new_new
  {
  	return $Delegator;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  sub fh
  {
  	# experiment with capturing output, I don't like it
  	$runner = Test::Tester::FHRunner->new;
  
  	return $Test;
  }
  
  sub find_run_tests
  {
  	my $d = 1;
  	my $found = 0;
  	while ((not $found) and (my ($sub) = (caller($d))[3]) )
  	{
  #		print "$d: $sub\n";
  		$found = ($sub eq "Test::Tester::run_tests");
  		$d++;
  	}
  
  #	die "Didn't find 'run_tests' in caller stack" unless $found;
  	return $d;
  }
  
  sub run_tests
  {
  	local($Delegator->{Object}) = $Capture;
  
  	$runner->run_tests(@_);
  
  	return ($runner->get_premature, $runner->get_results);
  }
  
  sub check_test
  {
  	my $test = shift;
  	my $expect = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	@_ = ($test, [$expect], $name);
  	goto &check_tests;
  }
  
  sub check_tests
  {
  	my $test = shift;
  	my $expects = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	my ($prem, @results) = eval { run_tests($test, $name) };
  
  	$Test->ok(! $@, "Test '$name' completed") || $Test->diag($@);
  	$Test->ok(! length($prem), "Test '$name' no premature diagnostication") ||
  		$Test->diag("Before any testing anything, your tests said\n$prem");
  
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	cmp_results(\@results, $expects, $name);
  	return ($prem, @results);
  }
  
  sub cmp_field
  {
  	my ($result, $expect, $field, $desc) = @_;
  
  	if (defined $expect->{$field})
  	{
  		$Test->is_eq($result->{$field}, $expect->{$field},
  			"$desc compare $field");
  	}
  }
  
  sub cmp_result
  {
  	my ($result, $expect, $name) = @_;
  
  	my $sub_name = $result->{name};
  	$sub_name = "" unless defined($name);
  
  	my $desc = "subtest '$sub_name' of '$name'";
  
  	{
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  
  		cmp_field($result, $expect, "ok", $desc);
  
  		cmp_field($result, $expect, "actual_ok", $desc);
  
  		cmp_field($result, $expect, "type", $desc);
  
  		cmp_field($result, $expect, "reason", $desc);
  
  		cmp_field($result, $expect, "name", $desc);
  	}
  
  	# if we got no depth then default to 1
  	my $depth = 1;
  	if (exists $expect->{depth})
  	{
  		$depth = $expect->{depth};
  	}
  
  	# if depth was explicitly undef then don't test it
  	if (defined $depth)
  	{
  		$Test->is_eq($result->{depth}, $depth, "checking depth") ||
  			$Test->diag('You need to change $Test::Builder::Level');
  	}
  
  	if (defined(my $exp = $expect->{diag}))
  	{
  
          my $got = '';
          if (ref $exp eq 'Regexp') {
  
              if (not $Test->like($result->{diag}, $exp,
                  "subtest '$sub_name' of '$name' compare diag"))
              {
                  $got = $result->{diag};
              }
  
          } else {
  
              # if there actually is some diag then put a \n on the end if it's not
              # there already
              $exp .= "\n" if (length($exp) and $exp !~ /\n$/);
  
              if (not $Test->ok($result->{diag} eq $exp,
      			"subtest '$sub_name' of '$name' compare diag"))
              {
                  $got = $result->{diag};
              }
          }
  
          if ($got) {
      		my $glen = length($got);
      		my $elen = length($exp);
      		for ($got, $exp)
      		{
      			my @lines = split("\n", $_);
       			$_ = join("\n", map {
      				if ($want_space)
      				{
      					$_ = $colour.escape($_).$reset;
      				}
      				else
      				{
      					"'$colour$_$reset'"
      				}
      			} @lines);
      		}
  
          	$Test->diag(<<EOM);
  Got diag ($glen bytes):
  $got
  Expected diag ($elen bytes):
  $exp
  EOM
          }
  	}
  }
  
  sub escape
  {
  	my $str = shift;
  	my $res = '';
  	for my $char (split("", $str))
  	{
  		my $c = ord($char);
  		if(($c>32 and $c<125) or $c == 10)
  		{
  			$res .= $char;
  		}
  		else
  		{
  			$res .= sprintf('\x{%x}', $c)
  		}
  	}
  	return $res;
  }
  
  sub cmp_results
  {
  	my ($results, $expects, $name) = @_;
  
  	$Test->is_num(scalar @$results, scalar @$expects, "Test '$name' result count");
  
  	for (my $i = 0; $i < @$expects; $i++)
  	{
  		my $expect = $expects->[$i];
  		my $result = $results->[$i];
  
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  		cmp_result($result, $expect, $name);
  	}
  }
  
  ######## nicked from Test::More
  sub plan {
  	my(@plan) = @_;
  
  	my $caller = caller;
  
  	$Test->exported_to($caller);
  
  	my @imports = ();
  	foreach my $idx (0..$#plan) {
  		if( $plan[$idx] eq 'import' ) {
  			my($tag, $imports) = splice @plan, $idx, 2;
  			@imports = @$imports;
  			last;
  		}
  	}
  
  	$Test->plan(@plan);
  
  	__PACKAGE__->_export_to_level(1, __PACKAGE__, @imports);
  }
  
  sub import {
  	my($class) = shift;
  		{
  			no warnings 'redefine';
  			*Test::Builder::new = \&new_new;
  		}
  	goto &plan;
  }
  
  sub _export_to_level
  {
          my $pkg = shift;
  	my $level = shift;
  	(undef) = shift;	# redundant arg
  	my $callpkg = caller($level);
  	$pkg->export($callpkg, @_);
  }
  
  
  ############
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester - Ease testing test modules built with Test::Builder
  
  =head1 SYNOPSIS
  
    use Test::Tester tests => 6;
  
    use Test::MyStyle;
  
    check_test(
      sub {
        is_mystyle_eq("this", "that", "not eq");
      },
      {
        ok => 0, # expect this to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  or
  
    use Test::Tester tests => 6;
  
    use Test::MyStyle;
  
    check_test(
      sub {
        is_mystyle_qr("this", "that", "not matching");
      },
      {
        ok => 0, # expect this to fail
        name => "not matching",
        diag => qr/Expected: 'this'\s+Got: 'that'/,
      }
    );
  
  or
  
    use Test::Tester;
  
    use Test::More tests => 3;
    use Test::MyStyle;
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    # now use Test::More::like to check the diagnostic output
  
    like($results[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  =head1 DESCRIPTION
  
  If you have written a test module based on Test::Builder then Test::Tester
  allows you to test it with the minimum of effort.
  
  =head1 HOW TO USE (THE EASY WAY)
  
  From version 0.08 Test::Tester no longer requires you to included anything
  special in your test modules. All you need to do is
  
    use Test::Tester;
  
  in your test script B<before> any other Test::Builder based modules and away
  you go.
  
  Other modules based on Test::Builder can be used to help with the
  testing.  In fact you can even use functions from your module to test
  other functions from the same module (while this is possible it is
  probably not a good idea, if your module has bugs, then
  using it to test itself may give the wrong answers).
  
  The easiest way to test is to do something like
  
    check_test(
      sub { is_mystyle_eq("this", "that", "not eq") },
      {
        ok => 0, # we expect the test to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  this will execute the is_mystyle_eq test, capturing it's results and
  checking that they are what was expected.
  
  You may need to examine the test results in a more flexible way, for
  example, the diagnostic output may be quite long or complex or it may involve
  something that you cannot predict in advance like a timestamp. In this case
  you can get direct access to the test results:
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    like($result[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  or
  
    check_test(
      sub { is_mystyle_qr("this", "that", "not matching") },
      {
        ok => 0, # we expect the test to fail
        name => "not matching",
        diag => qr/Expected: 'this'\s+Got: 'that'/,
      }
    );
  
  We cannot predict how long the database ping will take so we use
  Test::More's like() test to check that the diagnostic string is of the right
  form.
  
  =head1 HOW TO USE (THE HARD WAY)
  
  I<This is here for backwards compatibility only>
  
  Make your module use the Test::Tester::Capture object instead of the
  Test::Builder one. How to do this depends on your module but assuming that
  your module holds the Test::Builder object in $Test and that all your test
  routines access it through $Test then providing a function something like this
  
    sub set_builder
    {
      $Test = shift;
    }
  
  should allow your test scripts to do
  
    Test::YourModule::set_builder(Test::Tester->capture);
  
  and after that any tests inside your module will captured.
  
  =head1 TEST RESULTS
  
  The result of each test is captured in a hash. These hashes are the same as
  the hashes returned by Test::Builder->details but with a couple of extra
  fields.
  
  These fields are documented in L<Test::Builder> in the details() function
  
  =over 2
  
  =item ok
  
  Did the test pass?
  
  =item actual_ok
  
  Did the test really pass? That is, did the pass come from
  Test::Builder->ok() or did it pass because it was a TODO test?
  
  =item name
  
  The name supplied for the test.
  
  =item type
  
  What kind of test? Possibilities include, skip, todo etc. See
  L<Test::Builder> for more details.
  
  =item reason
  
  The reason for the skip, todo etc. See L<Test::Builder> for more details.
  
  =back
  
  These fields are exclusive to Test::Tester.
  
  =over 2
  
  =item diag
  
  Any diagnostics that were output for the test. This only includes
  diagnostics output B<after> the test result is declared.
  
  Note that Test::Builder ensures that any diagnostics end in a \n and
  it in earlier versions of Test::Tester it was essential that you have
  the final \n in your expected diagnostics. From version 0.10 onward,
  Test::Tester will add the \n if you forgot it. It will not add a \n if
  you are expecting no diagnostics. See below for help tracking down
  hard to find space and tab related problems.
  
  =item depth
  
  This allows you to check that your test module is setting the correct value
  for $Test::Builder::Level and thus giving the correct file and line number
  when a test fails. It is calculated by looking at caller() and
  $Test::Builder::Level. It should count how many subroutines there are before
  jumping into the function you are testing. So for example in
  
    run_tests( sub { my_test_function("a", "b") } );
  
  the depth should be 1 and in
  
    sub deeper { my_test_function("a", "b") }
  
    run_tests(sub { deeper() });
  
  depth should be 2, that is 1 for the sub {} and one for deeper(). This
  might seem a little complex but if your tests look like the simple
  examples in this doc then you don't need to worry as the depth will
  always be 1 and that's what Test::Tester expects by default.
  
  B<Note>: if you do not specify a value for depth in check_test() then it
  automatically compares it against 1, if you really want to skip the depth
  test then pass in undef.
  
  B<Note>: depth will not be correctly calculated for tests that run from a
  signal handler or an END block or anywhere else that hides the call stack.
  
  =back
  
  Some of Test::Tester's functions return arrays of these hashes, just
  like Test::Builder->details. That is, the hash for the first test will
  be array element 1 (not 0). Element 0 will not be a hash it will be a
  string which contains any diagnostic output that came before the first
  test. This should usually be empty, if it's not, it means something
  output diagnostics before any test results showed up.
  
  =head1 SPACES AND TABS
  
  Appearances can be deceptive, especially when it comes to emptiness. If you
  are scratching your head trying to work out why Test::Tester is saying that
  your diagnostics are wrong when they look perfectly right then the answer is
  probably whitespace. From version 0.10 on, Test::Tester surrounds the
  expected and got diag values with single quotes to make it easier to spot
  trailing whitespace. So in this example
  
    # Got diag (5 bytes):
    # 'abcd '
    # Expected diag (4 bytes):
    # 'abcd'
  
  it is quite clear that there is a space at the end of the first string.
  Another way to solve this problem is to use colour and inverse video on an
  ANSI terminal, see below COLOUR below if you want this.
  
  Unfortunately this is sometimes not enough, neither colour nor quotes will
  help you with problems involving tabs, other non-printing characters and
  certain kinds of problems inherent in Unicode. To deal with this, you can
  switch Test::Tester into a mode whereby all "tricky" characters are shown as
  \{xx}. Tricky characters are those with ASCII code less than 33 or higher
  than 126. This makes the output more difficult to read but much easier to
  find subtle differences between strings. To turn on this mode either call
  C<show_space()> in your test script or set the C<TESTTESTERSPACE> environment
  variable to be a true value. The example above would then look like
  
    # Got diag (5 bytes):
    # abcd\x{20}
    # Expected diag (4 bytes):
    # abcd
  
  =head1 COLOUR
  
  If you prefer to use colour as a means of finding tricky whitespace
  characters then you can set the C<TESTTESTCOLOUR> environment variable to a
  comma separated pair of colours, the first for the foreground, the second
  for the background. For example "white,red" will print white text on a red
  background. This requires the Term::ANSIColor module. You can specify any
  colour that would be acceptable to the Term::ANSIColor::color function.
  
  If you spell colour differently, that's no problem. The C<TESTTESTERCOLOR>
  variable also works (if both are set then the British spelling wins out).
  
  =head1 EXPORTED FUNCTIONS
  
  =head3 ($premature, @results) = run_tests(\&test_sub)
  
  \&test_sub is a reference to a subroutine.
  
  run_tests runs the subroutine in $test_sub and captures the results of any
  tests inside it. You can run more than 1 test inside this subroutine if you
  like.
  
  $premature is a string containing any diagnostic output from before
  the first test.
  
  @results is an array of test result hashes.
  
  =head3 cmp_result(\%result, \%expect, $name)
  
  \%result is a ref to a test result hash.
  
  \%expect is a ref to a hash of expected values for the test result.
  
  cmp_result compares the result with the expected values. If any differences
  are found it outputs diagnostics. You may leave out any field from the
  expected result and cmp_result will not do the comparison of that field.
  
  =head3 cmp_results(\@results, \@expects, $name)
  
  \@results is a ref to an array of test results.
  
  \@expects is a ref to an array of hash refs.
  
  cmp_results checks that the results match the expected results and if any
  differences are found it outputs diagnostics. It first checks that the
  number of elements in \@results and \@expects is the same. Then it goes
  through each result checking it against the expected result as in
  cmp_result() above.
  
  =head3 ($premature, @results) = check_tests(\&test_sub, \@expects, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \@expect is a ref to an array of hash refs which are expected test results.
  
  check_tests combines run_tests and cmp_tests into a single call. It also
  checks if the tests died at any stage.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 ($premature, @results) = check_test(\&test_sub, \%expect, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \%expect is a ref to an hash of expected values for the test result.
  
  check_test is a wrapper around check_tests. It combines run_tests and
  cmp_tests into a single call, checking if the test died. It assumes
  that only a single test is run inside \&test_sub and include a test to
  make sure this is true.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 show_space()
  
  Turn on the escaping of characters as described in the SPACES AND TABS
  section.
  
  =head1 HOW IT WORKS
  
  Normally, a test module (let's call it Test:MyStyle) calls
  Test::Builder->new to get the Test::Builder object. Test::MyStyle calls
  methods on this object to record information about test results. When
  Test::Tester is loaded, it replaces Test::Builder's new() method with one
  which returns a Test::Tester::Delegate object. Most of the time this object
  behaves as the real Test::Builder object. Any methods that are called are
  delegated to the real Test::Builder object so everything works perfectly.
  However once we go into test mode, the method calls are no longer passed to
  the real Test::Builder object, instead they go to the Test::Tester::Capture
  object. This object seems exactly like the real Test::Builder object,
  except, instead of outputting test results and diagnostics, it just records
  all the information for later analysis.
  
  =head1 CAVEATS
  
  Support for calling Test::Builder->note is minimal. It's implemented
  as an empty stub, so modules that use it will not crash but the calls
  are not recorded for testing purposes like the others. Patches
  welcome.
  
  =head1 SEE ALSO
  
  L<Test::Builder> the source of testing goodness. L<Test::Builder::Tester>
  for an alternative approach to the problem tackled by Test::Tester -
  captures the strings output by Test::Builder. This means you cannot get
  separate access to the individual pieces of information and you must predict
  B<exactly> what your test will output.
  
  =head1 AUTHOR
  
  This module is copyright 2005 Fergal Daly <fergal@esatclear.ie>, some parts
  are based on other people's work.
  
  Plan handling lifted from Test::More. written by Michael G Schwern
  <schwern@pobox.com>.
  
  Test::Tester::Capture is a cut down and hacked up version of Test::Builder.
  Test::Builder was written by chromatic <chromatic@wgz.org> and Michael G
  Schwern <schwern@pobox.com>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER

$fatpacked{"Test/Tester/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURE';
  use strict;
  
  package Test::Tester::Capture;
  
  our $VERSION = '1.302136';
  
  
  use Test::Builder;
  
  use vars qw( @ISA );
  @ISA = qw( Test::Builder );
  
  # Make Test::Tester::Capture thread-safe for ithreads.
  BEGIN {
  	use Config;
  	if( $] >= 5.008 && $Config{useithreads} ) {
  		require threads::shared;
  		threads::shared->import;
  	}
  	else {
  		*share = sub { 0 };
  		*lock  = sub { 0 };
  	}
  }
  
  my $Curr_Test = 0;      share($Curr_Test);
  my @Test_Results = ();  share(@Test_Results);
  my $Prem_Diag = {diag => ""};	 share($Curr_Test);
  
  sub new
  {
    # Test::Tester::Capgture::new used to just return __PACKAGE__
    # because Test::Builder::new enforced it's singleton nature by
    # return __PACKAGE__. That has since changed, Test::Builder::new now
    # returns a blessed has and around version 0.78, Test::Builder::todo
    # started wanting to modify $self. To cope with this, we now return
    # a blessed hash. This is a short-term hack, the correct thing to do
    # is to detect which style of Test::Builder we're dealing with and
    # act appropriately.
  
    my $class = shift;
    return bless {}, $class;
  }
  
  sub ok {
  	my($self, $test, $name) = @_;
  
  	my $ctx = $self->ctx;
  
  	# $test might contain an object which we don't want to accidentally
  	# store, so we turn it into a boolean.
  	$test = $test ? 1 : 0;
  
  	lock $Curr_Test;
  	$Curr_Test++;
  
  	my($pack, $file, $line) = $self->caller;
  
  	my $todo = $self->todo();
  
  	my $result = {};
  	share($result);
  
  	unless( $test ) {
  		@$result{ 'ok', 'actual_ok' } = ( ( $todo ? 1 : 0 ), 0 );
  	}
  	else {
  		@$result{ 'ok', 'actual_ok' } = ( 1, $test );
  	}
  
  	if( defined $name ) {
  		$name =~ s|#|\\#|g;	 # # in a name can confuse Test::Harness.
  		$result->{name} = $name;
  	}
  	else {
  		$result->{name} = '';
  	}
  
  	if( $todo ) {
  		my $what_todo = $todo;
  		$result->{reason} = $what_todo;
  		$result->{type}   = 'todo';
  	}
  	else {
  		$result->{reason} = '';
  		$result->{type}   = '';
  	}
  
  	$Test_Results[$Curr_Test-1] = $result;
  
  	unless( $test ) {
  		my $msg = $todo ? "Failed (TODO)" : "Failed";
  		$result->{fail_diag} = ("	$msg test ($file at line $line)\n");
  	} 
  
  	$result->{diag} = "";
  	$result->{_level} = $Test::Builder::Level;
  	$result->{_depth} = Test::Tester::find_run_tests();
  
  	$ctx->release;
  
  	return $test ? 1 : 0;
  }
  
  sub skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	my $ctx = $self->ctx;
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 1,
  		name	  => '',
  		type	  => 'skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	$ctx->release;
  	return 1;
  }
  
  sub todo_skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	my $ctx = $self->ctx;
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 0,
  		name	  => '',
  		type	  => 'todo_skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	$ctx->release;
  	return 1;
  }
  
  sub diag {
  	my($self, @msgs) = @_;
  	return unless @msgs;
  
  	# Prevent printing headers when compiling (i.e. -c)
  	return if $^C;
  
  	my $ctx = $self->ctx;
  
  	# Escape each line with a #.
  	foreach (@msgs) {
  		$_ = 'undef' unless defined;
  	}
  
  	push @msgs, "\n" unless $msgs[-1] =~ /\n\Z/;
  
  	my $result = $Curr_Test ? $Test_Results[$Curr_Test - 1] : $Prem_Diag;
  
  	$result->{diag} .= join("", @msgs);
  
  	$ctx->release;
  	return 0;
  }
  
  sub details {
  	return @Test_Results;
  }
  
  
  # Stub. Feel free to send me a patch to implement this.
  sub note {
  }
  
  sub explain {
  	return Test::Builder::explain(@_);
  }
  
  sub premature
  {
  	return $Prem_Diag->{diag};
  }
  
  sub current_test
  {
  	if (@_ > 1)
  	{
  		die "Don't try to change the test number!";
  	}
  	else
  	{
  		return $Curr_Test;
  	}
  }
  
  sub reset
  {
  	$Curr_Test = 0;
  	@Test_Results = ();
  	$Prem_Diag = {diag => ""};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester::Capture - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This is a subclass of Test::Builder that overrides many of the methods so
  that they don't output anything. It also keeps track of it's own set of test
  results so that you can use Test::Builder based modules to perform tests on
  other Test::Builder based modules.
  
  =head1 AUTHOR
  
  Most of the code here was lifted straight from Test::Builder and then had
  chunks removed by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER_CAPTURE

$fatpacked{"Test/Tester/CaptureRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURERUNNER';
  # $Header: /home/fergal/my/cvs/Test-Tester/lib/Test/Tester/CaptureRunner.pm,v 1.3 2003/03/05 01:07:55 fergal Exp $
  use strict;
  
  package Test::Tester::CaptureRunner;
  
  our $VERSION = '1.302136';
  
  
  use Test::Tester::Capture;
  require Exporter;
  
  sub new
  {
  	my $pkg = shift;
  	my $self = bless {}, $pkg;
  	return $self;
  }
  
  sub run_tests
  {
  	my $self = shift;
  
  	my $test = shift;
  
  	capture()->reset;
  
  	$self->{StartLevel} = $Test::Builder::Level;
  	&$test();
  }
  
  sub get_results
  {
  	my $self = shift;
  	my @results = capture()->details;
  
  	my $start = $self->{StartLevel};
  	foreach my $res (@results)
  	{
  		next if defined $res->{depth};
  		my $depth = $res->{_depth} - $res->{_level} - $start - 3;
  #		print "my $depth = $res->{_depth} - $res->{_level} - $start - 1\n";
  		$res->{depth} = $depth;
  	}
  
  	return @results;
  }
  
  sub get_premature
  {
  	return capture()->premature;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  __END__
  
  =head1 NAME
  
  Test::Tester::CaptureRunner - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This stuff if needed to allow me to play with other ways of monitoring the
  test results.
  
  =head1 AUTHOR
  
  Copyright 2003 by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER_CAPTURERUNNER

$fatpacked{"Test/Tester/Delegate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_DELEGATE';
  use strict;
  use warnings;
  
  package Test::Tester::Delegate;
  
  our $VERSION = '1.302136';
  
  use Scalar::Util();
  
  use vars '$AUTOLOAD';
  
  sub new
  {
  	my $pkg = shift;
  
  	my $obj = shift;
  	my $self = bless {}, $pkg;
  
  	return $self;
  }
  
  sub AUTOLOAD
  {
  	my ($sub) = $AUTOLOAD =~ /.*::(.*?)$/;
  
  	return if $sub eq "DESTROY";
  
  	my $obj = $_[0]->{Object};
  
  	my $ref = $obj->can($sub);
  	shift(@_);
  	unshift(@_, $obj);
  	goto &$ref;
  }
  
  sub can {
  	my $this = shift;
  	my ($sub) = @_;
  
  	return $this->{Object}->can($sub) if Scalar::Util::blessed($this);
  
  	return $this->SUPER::can(@_);
  }
  
  1;
TEST_TESTER_DELEGATE

$fatpacked{"Test/use/ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_USE_OK';
  package Test::use::ok;
  use 5.005;
  
  our $VERSION = '1.302136';
  
  
  __END__
  
  =head1 NAME
  
  Test::use::ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  According to the B<Test::More> documentation, it is recommended to run
  C<use_ok()> inside a C<BEGIN> block, so functions are exported at
  compile-time and prototypes are properly honored.
  
  That is, instead of writing this:
  
      use_ok( 'Some::Module' );
      use_ok( 'Other::Module' );
  
  One should write this:
  
      BEGIN { use_ok( 'Some::Module' ); }
      BEGIN { use_ok( 'Other::Module' ); }
  
  However, people often either forget to add C<BEGIN>, or mistakenly group
  C<use_ok> with other tests in a single C<BEGIN> block, which can create subtle
  differences in execution order.
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.  The explicit space after C<use>
  makes it clear that this is a single compile-time action.
  
  =head1 SEE ALSO
  
  L<Test::More>
  
  =head1 MAINTAINER
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =encoding utf8
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
TEST_USE_OK

$fatpacked{"Test2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2';
  package Test2;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2 - Framework for writing test tools that all work together.
  
  =head1 DESCRIPTION
  
  Test2 is a new testing framework produced by forking L<Test::Builder>,
  completely refactoring it, adding many new features and capabilities.
  
  =head2 WHAT IS NEW?
  
  =over 4
  
  =item Easier to test new testing tools.
  
  From the beginning Test2 was built with introspection capabilities. With
  Test::Builder it was difficult at best to capture test tool output for
  verification. Test2 Makes it easy with C<Test2::API::intercept()>.
  
  =item Better diagnostics capabilities.
  
  Test2 uses an L<Test2::API::Context> object to track filename, line number, and
  tool details. This object greatly simplifies tracking for where errors should
  be reported.
  
  =item Event driven.
  
  Test2 based tools produce events which get passed through a processing system
  before being output by a formatter. This event system allows for rich plugin
  and extension support.
  
  =item More complete API.
  
  Test::Builder only provided a handful of methods for generating lines of TAP.
  Test2 took inventory of everything people were doing with Test::Builder that
  required hacking it up. Test2 made public API functions for nearly all the
  desired functionality people didn't previously have.
  
  =item Support for output other than TAP.
  
  Test::Builder assumed everything would end up as TAP. Test2 makes no such
  assumption. Test2 provides ways for you to specify alternative and custom
  formatters.
  
  =item Subtest implementation is more sane.
  
  The Test::Builder implementation of subtests was certifiably insane. Test2 uses
  a stacked event hub system that greatly improves how subtests are implemented.
  
  =item Support for threading/forking.
  
  Test2 support for forking and threading can be turned on using L<Test2::IPC>.
  Once turned on threading and forking operate sanely and work as one would
  expect.
  
  =back
  
  =head1 GETTING STARTED
  
  If you are interested in writing tests using new tools then you should look at
  L<Test2::Suite>. L<Test2::Suite> is a separate cpan distribution that contains
  many tools implemented on Test2.
  
  If you are interested in writing new tools you should take a look at
  L<Test2::API> first.
  
  =head1 NAMESPACE LAYOUT
  
  This describes the namespace layout for the Test2 ecosystem. Not all the
  namespaces listed here are part of the Test2 distribution, some are implemented
  in L<Test2::Suite>.
  
  =head2 Test2::Tools::
  
  This namespace is for sets of tools. Modules in this namespace should export
  tools like C<ok()> and C<is()>. Most things written for Test2 should go here.
  Modules in this namespace B<MUST NOT> export subs from other tools. See the
  L</Test2::Bundle::> namespace if you want to do that.
  
  =head2 Test2::Plugin::
  
  This namespace is for plugins. Plugins are modules that change or enhance the
  behavior of Test2. An example of a plugin is a module that sets the encoding to
  utf8 globally. Another example is a module that causes a bail-out event after
  the first test failure.
  
  =head2 Test2::Bundle::
  
  This namespace is for bundles of tools and plugins. Loading one of these may
  load multiple tools and plugins. Modules in this namespace should not implement
  tools directly. In general modules in this namespace should load tools and
  plugins, then re-export things into the consumers namespace.
  
  =head2 Test2::Require::
  
  This namespace is for modules that cause a test to be skipped when conditions
  do not allow it to run. Examples would be modules that skip the test on older
  perls, or when non-essential modules have not been installed.
  
  =head2 Test2::Formatter::
  
  Formatters live under this namespace. L<Test2::Formatter::TAP> is the only
  formatter currently. It is acceptable for third party distributions to create
  new formatters under this namespace.
  
  =head2 Test2::Event::
  
  Events live under this namespace. It is considered acceptable for third party
  distributions to add new event types in this namespace.
  
  =head2 Test2::Hub::
  
  Hub subclasses (and some hub utility objects) live under this namespace. It is
  perfectly reasonable for third party distributions to add new hub subclasses in
  this namespace.
  
  =head2 Test2::IPC::
  
  The IPC subsystem lives in this namespace. There are not many good reasons to
  add anything to this namespace, with exception of IPC drivers.
  
  =head3 Test2::IPC::Driver::
  
  IPC drivers live in this namespace. It is fine to create new IPC drivers and to
  put them in this namespace.
  
  =head2 Test2::Util::
  
  This namespace is for general utilities used by testing tools. Please be
  considerate when adding new modules to this namespace.
  
  =head2 Test2::API::
  
  This is for Test2 API and related packages.
  
  =head2 Test2::
  
  The Test2:: namespace is intended for extensions and frameworks. Tools,
  Plugins, etc should not go directly into this namespace. However extensions
  that are used to build tools and plugins may go here.
  
  In short: If the module exports anything that should be run directly by a test
  script it should probably NOT go directly into C<Test2::XXX>.
  
  =head1 SEE ALSO
  
  L<Test2::API> - Primary API functions.
  
  L<Test2::API::Context> - Detailed documentation of the context object.
  
  L<Test2::IPC> - The IPC system used for threading/fork support.
  
  L<Test2::Formatter> - Formatters such as TAP live here.
  
  L<Test2::Event> - Events live in this namespace.
  
  L<Test2::Hub> - All events eventually funnel through a hub. Custom hubs are how
  C<intercept()> and C<run_subtest()> are implemented.
  
  =head1 CONTACTING US
  
  Many Test2 developers and users lurk on L<irc://irc.perl.org/#perl-qa> and
  L<irc://irc.perl.org/#toolchain>. We also have a slack team that can be joined
  by anyone with an C<@cpan.org> email address L<https://perl-test2.slack.com/>
  If you do not have an C<@cpan.org> email you can ask for a slack invite by
  emailing Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2

$fatpacked{"Test2/API.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API';
  package Test2::API;
  use strict;
  use warnings;
  
  use Test2::Util qw/USE_THREADS/;
  
  BEGIN {
      $ENV{TEST_ACTIVE} ||= 1;
      $ENV{TEST2_ACTIVE} = 1;
  }
  
  our $VERSION = '1.302136';
  
  
  my $INST;
  my $ENDING = 0;
  sub test2_set_is_end { ($ENDING) = @_ ? @_ : (1) }
  sub test2_get_is_end { $ENDING }
  
  use Test2::API::Instance(\$INST);
  
  # Set the exit status
  END {
      test2_set_is_end(); # See gh #16
      $INST->set_exit();
  }
  
  sub CLONE {
      my $init = test2_init_done();
      my $load = test2_load_done();
  
      return if $init && $load;
  
      require Carp;
      Carp::croak "Test2 must be fully loaded before you start a new thread!\n";
  }
  
  # See gh #16
  {
      no warnings;
      INIT { eval 'END { test2_set_is_end() }; 1' or die $@ }
  }
  
  BEGIN {
      no warnings 'once';
      if($] ge '5.014' || $ENV{T2_CHECK_DEPTH} || $Test2::API::DO_DEPTH_CHECK) {
          *DO_DEPTH_CHECK = sub() { 1 };
      }
      else {
          *DO_DEPTH_CHECK = sub() { 0 };
      }
  }
  
  use Test2::EventFacet::Trace();
  use Test2::Util::Trace(); # Legacy
  
  use Test2::Hub::Subtest();
  use Test2::Hub::Interceptor();
  use Test2::Hub::Interceptor::Terminator();
  
  use Test2::Event::Ok();
  use Test2::Event::Diag();
  use Test2::Event::Note();
  use Test2::Event::Plan();
  use Test2::Event::Bail();
  use Test2::Event::Exception();
  use Test2::Event::Waiting();
  use Test2::Event::Skip();
  use Test2::Event::Subtest();
  
  use Carp qw/carp croak confess/;
  use Scalar::Util qw/blessed weaken/;
  use Test2::Util qw/get_tid clone_io pkg_to_file gen_uid/;
  
  our @EXPORT_OK = qw{
      context release
      context_do
      no_context
      intercept intercept_deep
      run_subtest
  
      test2_init_done
      test2_load_done
      test2_load
      test2_start_preload
      test2_stop_preload
      test2_in_preload
  
      test2_set_is_end
      test2_get_is_end
  
      test2_pid
      test2_tid
      test2_stack
      test2_no_wait
      test2_ipc_wait_enable
      test2_ipc_wait_disable
      test2_ipc_wait_enabled
  
      test2_add_uuid_via
  
      test2_add_callback_testing_done
  
      test2_add_callback_context_aquire
      test2_add_callback_context_acquire
      test2_add_callback_context_init
      test2_add_callback_context_release
      test2_add_callback_exit
      test2_add_callback_post_load
      test2_add_callback_pre_subtest
      test2_list_context_aquire_callbacks
      test2_list_context_acquire_callbacks
      test2_list_context_init_callbacks
      test2_list_context_release_callbacks
      test2_list_exit_callbacks
      test2_list_post_load_callbacks
      test2_list_pre_subtest_callbacks
  
      test2_ipc
      test2_has_ipc
      test2_ipc_disable
      test2_ipc_disabled
      test2_ipc_drivers
      test2_ipc_add_driver
      test2_ipc_polling
      test2_ipc_disable_polling
      test2_ipc_enable_polling
      test2_ipc_get_pending
      test2_ipc_set_pending
      test2_ipc_get_timeout
      test2_ipc_set_timeout
      test2_ipc_enable_shm
  
      test2_formatter
      test2_formatters
      test2_formatter_add
      test2_formatter_set
  
      test2_stdout
      test2_stderr
      test2_reset_io
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  my $STACK       = $INST->stack;
  my $CONTEXTS    = $INST->contexts;
  my $INIT_CBS    = $INST->context_init_callbacks;
  my $ACQUIRE_CBS = $INST->context_acquire_callbacks;
  
  my $STDOUT = clone_io(\*STDOUT);
  my $STDERR = clone_io(\*STDERR);
  sub test2_stdout { $STDOUT ||= clone_io(\*STDOUT) }
  sub test2_stderr { $STDERR ||= clone_io(\*STDERR) }
  
  sub test2_post_preload_reset {
      test2_reset_io();
      $INST->post_preload_reset;
  }
  
  sub test2_reset_io {
      $STDOUT = clone_io(\*STDOUT);
      $STDERR = clone_io(\*STDERR);
  }
  
  sub test2_init_done { $INST->finalized }
  sub test2_load_done { $INST->loaded }
  
  sub test2_load          { $INST->load }
  sub test2_start_preload { $ENV{T2_IN_PRELOAD} = 1; $INST->start_preload }
  sub test2_stop_preload  { $ENV{T2_IN_PRELOAD} = 0; $INST->stop_preload }
  sub test2_in_preload    { $INST->preload }
  
  sub test2_pid              { $INST->pid }
  sub test2_tid              { $INST->tid }
  sub test2_stack            { $INST->stack }
  sub test2_ipc_wait_enable  { $INST->set_no_wait(0) }
  sub test2_ipc_wait_disable { $INST->set_no_wait(1) }
  sub test2_ipc_wait_enabled { !$INST->no_wait }
  
  sub test2_no_wait {
      $INST->set_no_wait(@_) if @_;
      $INST->no_wait;
  }
  
  sub test2_add_callback_testing_done {
      my $cb = shift;
  
      test2_add_callback_post_load(sub {
          my $stack = test2_stack();
          $stack->top; # Insure we have a hub
          my ($hub) = Test2::API::test2_stack->all;
  
          $hub->set_active(1);
  
          $hub->follow_up($cb);
      });
  
      return;
  }
  
  sub test2_add_callback_context_acquire   { $INST->add_context_acquire_callback(@_) }
  sub test2_add_callback_context_aquire    { $INST->add_context_acquire_callback(@_) }
  sub test2_add_callback_context_init      { $INST->add_context_init_callback(@_) }
  sub test2_add_callback_context_release   { $INST->add_context_release_callback(@_) }
  sub test2_add_callback_exit              { $INST->add_exit_callback(@_) }
  sub test2_add_callback_post_load         { $INST->add_post_load_callback(@_) }
  sub test2_add_callback_pre_subtest       { $INST->add_pre_subtest_callback(@_) }
  sub test2_list_context_aquire_callbacks  { @{$INST->context_acquire_callbacks} }
  sub test2_list_context_acquire_callbacks { @{$INST->context_acquire_callbacks} }
  sub test2_list_context_init_callbacks    { @{$INST->context_init_callbacks} }
  sub test2_list_context_release_callbacks { @{$INST->context_release_callbacks} }
  sub test2_list_exit_callbacks            { @{$INST->exit_callbacks} }
  sub test2_list_post_load_callbacks       { @{$INST->post_load_callbacks} }
  sub test2_list_pre_subtest_callbacks     { @{$INST->pre_subtest_callbacks} }
  
  sub test2_add_uuid_via {
      $INST->set_add_uuid_via(@_) if @_;
      $INST->add_uuid_via();
  }
  
  sub test2_ipc                 { $INST->ipc }
  sub test2_has_ipc             { $INST->has_ipc }
  sub test2_ipc_disable         { $INST->ipc_disable }
  sub test2_ipc_disabled        { $INST->ipc_disabled }
  sub test2_ipc_add_driver      { $INST->add_ipc_driver(@_) }
  sub test2_ipc_drivers         { @{$INST->ipc_drivers} }
  sub test2_ipc_polling         { $INST->ipc_polling }
  sub test2_ipc_enable_polling  { $INST->enable_ipc_polling }
  sub test2_ipc_disable_polling { $INST->disable_ipc_polling }
  sub test2_ipc_get_pending     { $INST->get_ipc_pending }
  sub test2_ipc_set_pending     { $INST->set_ipc_pending(@_) }
  sub test2_ipc_set_timeout     { $INST->set_ipc_timeout(@_) }
  sub test2_ipc_get_timeout     { $INST->ipc_timeout() }
  sub test2_ipc_enable_shm      { $INST->ipc_enable_shm }
  
  sub test2_formatter     {
      if ($ENV{T2_FORMATTER} && $ENV{T2_FORMATTER} =~ m/^(\+)?(.*)$/) {
          my $formatter = $1 ? $2 : "Test2::Formatter::$2";
          my $file = pkg_to_file($formatter);
          require $file;
          return $formatter;
      }
  
      return $INST->formatter;
  }
  
  sub test2_formatters    { @{$INST->formatters} }
  sub test2_formatter_add { $INST->add_formatter(@_) }
  sub test2_formatter_set {
      my ($formatter) = @_;
      croak "No formatter specified" unless $formatter;
      croak "Global Formatter already set" if $INST->formatter_set;
      $INST->set_formatter($formatter);
  }
  
  # Private, for use in Test2::API::Context
  sub _contexts_ref                  { $INST->contexts }
  sub _context_acquire_callbacks_ref { $INST->context_acquire_callbacks }
  sub _context_init_callbacks_ref    { $INST->context_init_callbacks }
  sub _context_release_callbacks_ref { $INST->context_release_callbacks }
  sub _add_uuid_via_ref              { \($INST->{Test2::API::Instance::ADD_UUID_VIA()}) }
  
  # Private, for use in Test2::IPC
  sub _set_ipc { $INST->set_ipc(@_) }
  
  sub context_do(&;@) {
      my $code = shift;
      my @args = @_;
  
      my $ctx = context(level => 1);
  
      my $want = wantarray;
  
      my @out;
      my $ok = eval {
          $want          ? @out    = $code->($ctx, @args) :
          defined($want) ? $out[0] = $code->($ctx, @args) :
                                     $code->($ctx, @args) ;
          1;
      };
      my $err = $@;
  
      $ctx->release;
  
      die $err unless $ok;
  
      return @out    if $want;
      return $out[0] if defined $want;
      return;
  }
  
  sub no_context(&;$) {
      my ($code, $hid) = @_;
      $hid ||= $STACK->top->hid;
  
      my $ctx = $CONTEXTS->{$hid};
      delete $CONTEXTS->{$hid};
      my $ok = eval { $code->(); 1 };
      my $err = $@;
  
      $CONTEXTS->{$hid} = $ctx;
      weaken($CONTEXTS->{$hid});
  
      die $err unless $ok;
  
      return;
  };
  
  my $UUID_VIA = _add_uuid_via_ref();
  sub context {
      # We need to grab these before anything else to ensure they are not
      # changed.
      my ($errno, $eval_error, $child_error, $extended_error) = (0 + $!, $@, $?, $^E);
  
      my %params = (level => 0, wrapped => 0, @_);
  
      # If something is getting a context then the sync system needs to be
      # considered loaded...
      $INST->load unless $INST->{loaded};
  
      croak "context() called, but return value is ignored"
          unless defined wantarray;
  
      my $stack   = $params{stack} || $STACK;
      my $hub     = $params{hub}   || (@$stack ? $stack->[-1] : $stack->top);
      my $hid     = $hub->{hid};
      my $current = $CONTEXTS->{$hid};
  
      $_->(\%params) for @$ACQUIRE_CBS;
      map $_->(\%params), @{$hub->{_context_acquire}} if $hub->{_context_acquire};
  
      # This is for https://github.com/Test-More/test-more/issues/16
      # and https://rt.perl.org/Public/Bug/Display.html?id=127774
      my $phase = ${^GLOBAL_PHASE} || 'NA';
      my $end_phase = $ENDING || $phase eq 'END' || $phase eq 'DESTRUCT';
  
      my $level = 1 + $params{level};
      my ($pkg, $file, $line, $sub) = $end_phase ? caller(0) : caller($level);
      unless ($pkg || $end_phase) {
          confess "Could not find context at depth $level" unless $params{fudge};
          ($pkg, $file, $line, $sub) = caller(--$level) while ($level >= 0 && !$pkg);
      }
  
      my $depth = $level;
      $depth++ while DO_DEPTH_CHECK && !$end_phase && (!$current || $depth <= $current->{_depth} + $params{wrapped}) && caller($depth + 1);
      $depth -= $params{wrapped};
      my $depth_ok = !DO_DEPTH_CHECK || $end_phase || !$current || $current->{_depth} < $depth;
  
      if ($current && $params{on_release} && $depth_ok) {
          $current->{_on_release} ||= [];
          push @{$current->{_on_release}} => $params{on_release};
      }
  
      # I know this is ugly....
      ($!, $@, $?, $^E) = ($errno, $eval_error, $child_error, $extended_error) and return bless(
          {
              %$current,
              _is_canon   => undef,
              errno       => $errno,
              eval_error  => $eval_error,
              child_error => $child_error,
              _is_spawn   => [$pkg, $file, $line, $sub],
          },
          'Test2::API::Context'
      ) if $current && $depth_ok;
  
      # Handle error condition of bad level
      if ($current) {
          unless (${$current->{_aborted}}) {
              _canon_error($current, [$pkg, $file, $line, $sub, $depth])
                  unless $current->{_is_canon};
  
              _depth_error($current, [$pkg, $file, $line, $sub, $depth])
                  unless $depth_ok;
          }
  
          $current->release if $current->{_is_canon};
  
          delete $CONTEXTS->{$hid};
      }
  
      # Directly bless the object here, calling new is a noticeable performance
      # hit with how often this needs to be called.
      my $trace = bless(
          {
              frame  => [$pkg, $file, $line, $sub],
              pid    => $$,
              tid    => get_tid(),
              cid    => gen_uid(),
              hid    => $hid,
              nested => $hub->{nested},
              buffered => $hub->{buffered},
  
              $$UUID_VIA ? (
                  huuid => $hub->{uuid},
                  uuid  => ${$UUID_VIA}->('context'),
              ) : (),
          },
          'Test2::EventFacet::Trace'
      );
  
      # Directly bless the object here, calling new is a noticeable performance
      # hit with how often this needs to be called.
      my $aborted = 0;
      $current = bless(
          {
              _aborted     => \$aborted,
              stack        => $stack,
              hub          => $hub,
              trace        => $trace,
              _is_canon    => 1,
              _depth       => $depth,
              errno        => $errno,
              eval_error   => $eval_error,
              child_error  => $child_error,
              $params{on_release} ? (_on_release => [$params{on_release}]) : (),
          },
          'Test2::API::Context'
      );
  
      $CONTEXTS->{$hid} = $current;
      weaken($CONTEXTS->{$hid});
  
      $_->($current) for @$INIT_CBS;
      map $_->($current), @{$hub->{_context_init}} if $hub->{_context_init};
  
      $params{on_init}->($current) if $params{on_init};
  
      ($!, $@, $?, $^E) = ($errno, $eval_error, $child_error, $extended_error);
  
      return $current;
  }
  
  sub _depth_error {
      _existing_error(@_, <<"    EOT");
  context() was called to retrieve an existing context, however the existing
  context was created in a stack frame at the same, or deeper level. This usually
  means that a tool failed to release the context when it was finished.
      EOT
  }
  
  sub _canon_error {
      _existing_error(@_, <<"    EOT");
  context() was called to retrieve an existing context, however the existing
  context has an invalid internal state (!_canon_count). This should not normally
  happen unless something is mucking about with internals...
      EOT
  }
  
  sub _existing_error {
      my ($ctx, $details, $msg) = @_;
      my ($pkg, $file, $line, $sub, $depth) = @$details;
  
      my $oldframe = $ctx->{trace}->frame;
      my $olddepth = $ctx->{_depth};
  
      # Older versions of Carp do not export longmess() function, so it needs to be called with package name
      my $mess = Carp::longmess();
  
      warn <<"    EOT";
  $msg
  Old context details:
     File: $oldframe->[1]
     Line: $oldframe->[2]
     Tool: $oldframe->[3]
    Depth: $olddepth
  
  New context details:
     File: $file
     Line: $line
     Tool: $sub
    Depth: $depth
  
  Trace: $mess
  
  Removing the old context and creating a new one...
      EOT
  }
  
  sub release($;$) {
      $_[0]->release;
      return $_[1];
  }
  
  sub intercept(&) {
      my $code = shift;
      my $ctx = context();
  
      my $events = _intercept($code, deep => 0);
  
      $ctx->release;
  
      return $events;
  }
  
  sub intercept_deep(&) {
      my $code = shift;
      my $ctx = context();
  
      my $events = _intercept($code, deep => 1);
  
      $ctx->release;
  
      return $events;
  }
  
  sub _intercept {
      my $code = shift;
      my %params = @_;
      my $ctx = context();
  
      my $ipc;
      if (my $global_ipc = test2_ipc()) {
          my $driver = blessed($global_ipc);
          $ipc = $driver->new;
      }
  
      my $hub = Test2::Hub::Interceptor->new(
          ipc => $ipc,
          no_ending => 1,
      );
  
      my @events;
      $hub->listen(sub { push @events => $_[1] }, inherit => $params{deep});
  
      $ctx->stack->top; # Make sure there is a top hub before we begin.
      $ctx->stack->push($hub);
  
      my ($ok, $err) = (1, undef);
      T2_SUBTEST_WRAPPER: {
          # Do not use 'try' cause it localizes __DIE__
          $ok = eval { $code->(hub => $hub, context => $ctx->snapshot); 1 };
          $err = $@;
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && $err->isa('Test2::Hub::Interceptor::Terminator'))) {
              $ok  = 1;
              $err = undef;
          }
      }
  
      $hub->cull;
      $ctx->stack->pop($hub);
  
      my $trace = $ctx->trace;
      $ctx->release;
  
      die $err unless $ok;
  
      $hub->finalize($trace, 1)
          if $ok
          && !$hub->no_ending
          && !$hub->ended;
  
      return \@events;
  }
  
  sub run_subtest {
      my ($name, $code, $params, @args) = @_;
  
      $_->($name,$code,@args)
          for Test2::API::test2_list_pre_subtest_callbacks();
  
      $params = {buffered => $params} unless ref $params;
      my $inherit_trace = delete $params->{inherit_trace};
  
      my $ctx = context();
  
      my $parent = $ctx->hub;
  
      # If a parent is buffered then the child must be as well.
      my $buffered = $params->{buffered} || $parent->{buffered};
  
      $ctx->note($name) unless $buffered;
  
      my $stack = $ctx->stack || $STACK;
      my $hub = $stack->new_hub(
          class => 'Test2::Hub::Subtest',
          %$params,
          buffered => $buffered,
      );
  
      my @events;
      $hub->listen(sub { push @events => $_[1] });
  
      if ($buffered) {
          if (my $format = $hub->format) {
              my $hide = $format->can('hide_buffered') ? $format->hide_buffered : 1;
              $hub->format(undef) if $hide;
          }
      }
  
      if ($inherit_trace) {
          my $orig = $code;
          $code = sub {
              my $base_trace = $ctx->trace;
              my $trace = $base_trace->snapshot(nested => 1 + $base_trace->nested);
              my $st_ctx = Test2::API::Context->new(
                  trace  => $trace,
                  hub    => $hub,
              );
              $st_ctx->do_in_context($orig, @args);
          };
      }
  
      my ($ok, $err, $finished);
      T2_SUBTEST_WRAPPER: {
          # Do not use 'try' cause it localizes __DIE__
          $ok = eval { $code->(@args); 1 };
          $err = $@;
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && blessed($err) eq 'Test::Builder::Exception')) {
              $ok  = undef;
              $err = undef;
          }
          else {
              $finished = 1;
          }
      }
  
      if ($params->{no_fork}) {
          if ($$ != $ctx->trace->pid) {
              warn $ok ? "Forked inside subtest, but subtest never finished!\n" : $err;
              exit 255;
          }
  
          if (get_tid() != $ctx->trace->tid) {
              warn $ok ? "Started new thread inside subtest, but thread never finished!\n" : $err;
              exit 255;
          }
      }
      elsif (!$parent->is_local && !$parent->ipc) {
          warn $ok ? "A new process or thread was started inside subtest, but IPC is not enabled!\n" : $err;
          exit 255;
      }
  
      $stack->pop($hub);
  
      my $trace = $ctx->trace;
  
      my $bailed = $hub->bailed_out;
  
      if (!$finished) {
          if ($bailed && !$buffered) {
              $ctx->bail($bailed->reason);
          }
          elsif ($bailed && $buffered) {
              $ok = 1;
          }
          else {
              my $code = $hub->exit_code;
              $ok = !$code;
              $err = "Subtest ended with exit code $code" if $code;
          }
      }
  
      $hub->finalize($trace->snapshot(huuid => $hub->uuid, hid => $hub->hid, nested => $hub->nested, buffered => $buffered), 1)
          if $ok
          && !$hub->no_ending
          && !$hub->ended;
  
      my $pass = $ok && $hub->is_passing;
      my $e = $ctx->build_event(
          'Subtest',
          pass         => $pass,
          name         => $name,
          subtest_id   => $hub->id,
          subtest_uuid => $hub->uuid,
          buffered     => $buffered,
          subevents    => \@events,
      );
  
      my $plan_ok = $hub->check_plan;
  
      $ctx->hub->send($e);
  
      $ctx->failure_diag($e) unless $e->pass;
  
      $ctx->diag("Caught exception in subtest: $err") unless $ok;
  
      $ctx->diag("Bad subtest plan, expected " . $hub->plan . " but ran " . $hub->count)
          if defined($plan_ok) && !$plan_ok;
  
      $ctx->bail($bailed->reason) if $bailed && $buffered;
  
      $ctx->release;
      return $pass;
  }
  
  # There is a use-cycle between API and API/Context. Context needs to use some
  # API functions as the package is compiling. Test2::API::context() needs
  # Test2::API::Context to be loaded, but we cannot 'require' the module there as
  # it causes a very noticeable performance impact with how often context() is
  # called.
  require Test2::API::Context;
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API - Primary interface for writing Test2 based testing tools.
  
  =head1 ***INTERNALS NOTE***
  
  B<The internals of this package are subject to change at any time!> The public
  methods provided will not change in backwards-incompatible ways (once there is
  a stable release), but the underlying implementation details might.
  B<Do not break encapsulation here!>
  
  Currently the implementation is to create a single instance of the
  L<Test2::API::Instance> Object. All class methods defer to the single
  instance. There is no public access to the singleton, and that is intentional.
  The class methods provided by this package provide the only functionality
  publicly exposed.
  
  This is done primarily to avoid the problems Test::Builder had by exposing its
  singleton. We do not want anyone to replace this singleton, rebless it, or
  directly muck with its internals. If you need to do something and cannot
  because of the restrictions placed here, then please report it as an issue. If
  possible, we will create a way for you to implement your functionality without
  exposing things that should not be exposed.
  
  =head1 DESCRIPTION
  
  This package exports all the functions necessary to write and/or verify testing
  tools. Using these building blocks you can begin writing test tools very
  quickly. You are also provided with tools that help you to test the tools you
  write.
  
  =head1 SYNOPSIS
  
  =head2 WRITING A TOOL
  
  The C<context()> method is your primary interface into the Test2 framework.
  
      package My::Ok;
      use Test2::API qw/context/;
  
      our @EXPORT = qw/my_ok/;
      use base 'Exporter';
  
      # Just like ok() from Test::More
      sub my_ok($;$) {
          my ($bool, $name) = @_;
          my $ctx = context(); # Get a context
          $ctx->ok($bool, $name);
          $ctx->release; # Release the context
          return $bool;
      }
  
  See L<Test2::API::Context> for a list of methods available on the context object.
  
  =head2 TESTING YOUR TOOLS
  
  The C<intercept { ... }> tool lets you temporarily intercept all events
  generated by the test system:
  
      use Test2::API qw/intercept/;
  
      use My::Ok qw/my_ok/;
  
      my $events = intercept {
          # These events are not displayed
          my_ok(1, "pass");
          my_ok(0, "fail");
      };
  
      my_ok(@$events == 2, "got 2 events, the pass and the fail");
      my_ok($events->[0]->pass, "first event passed");
      my_ok(!$events->[1]->pass, "second event failed");
  
  =head3 DEEP EVENT INTERCEPTION
  
  Normally C<intercept { ... }> only intercepts events sent to the main hub (as
  added by intercept itself). Nested hubs, such as those created by subtests,
  will not be intercepted. This is normally what you will still see the nested
  events by inspecting the subtest event. However there are times where you want
  to verify each event as it is sent, in that case use C<intercept_deep { ... }>.
  
      my $events = intercept_Deep {
          buffered_subtest foo => sub {
              ok(1, "pass");
          };
      };
  
  C<$events> in this case will contain 3 items:
  
  =over 4
  
  =item The event from C<ok(1, "pass")>
  
  =item The plan event for the subtest
  
  =item The subtest event itself, with the first 2 events nested inside it as children.
  
  =back
  
  This lets you see the order in which the events were sent, unlike
  C<intercept { ... }> which only lets you see events as the main hub sees them.
  
  =head2 OTHER API FUNCTIONS
  
      use Test2::API qw{
          test2_init_done
          test2_stack
          test2_set_is_end
          test2_get_is_end
          test2_ipc
          test2_formatter_set
          test2_formatter
      };
  
      my $init  = test2_init_done();
      my $stack = test2_stack();
      my $ipc   = test2_ipc();
  
      test2_formatter_set($FORMATTER)
      my $formatter = test2_formatter();
  
      ... And others ...
  
  =head1 MAIN API EXPORTS
  
  All exports are optional. You must specify subs to import.
  
      use Test2::API qw/context intercept run_subtest/;
  
  This is the list of exports that are most commonly needed. If you are simply
  writing a tool, then this is probably all you need. If you need something and
  you cannot find it here, then you can also look at L</OTHER API EXPORTS>.
  
  These exports lack the 'test2_' prefix because of how important/common they
  are. Exports in the L</OTHER API EXPORTS> section have the 'test2_' prefix to
  ensure they stand out.
  
  =head2 context(...)
  
  Usage:
  
  =over 4
  
  =item $ctx = context()
  
  =item $ctx = context(%params)
  
  =back
  
  The C<context()> function will always return the current context. If
  there is already a context active, it will be returned. If there is not an
  active context, one will be generated. When a context is generated it will
  default to using the file and line number where the currently running sub was
  called from.
  
  Please see L<Test2::API::Context/"CRITICAL DETAILS"> for important rules about
  what you can and cannot do with a context once it is obtained.
  
  B<Note> This function will throw an exception if you ignore the context object
  it returns.
  
  B<Note> On perls 5.14+ a depth check is used to insure there are no context
  leaks. This cannot be safely done on older perls due to
  L<https://rt.perl.org/Public/Bug/Display.html?id=127774>
  You can forcefully enable it either by setting C<$ENV{T2_CHECK_DEPTH} = 1> or
  C<$Test2::API::DO_DEPTH_CHECK = 1> B<BEFORE> loading L<Test2::API>.
  
  =head3 OPTIONAL PARAMETERS
  
  All parameters to C<context> are optional.
  
  =over 4
  
  =item level => $int
  
  If you must obtain a context in a sub deeper than your entry point you can use
  this to tell it how many EXTRA stack frames to look back. If this option is not
  provided the default of C<0> is used.
  
      sub third_party_tool {
          my $sub = shift;
          ... # Does not obtain a context
          $sub->();
          ...
      }
  
      third_party_tool(sub {
          my $ctx = context(level => 1);
          ...
          $ctx->release;
      });
  
  =item wrapped => $int
  
  Use this if you need to write your own tool that wraps a call to C<context()>
  with the intent that it should return a context object.
  
      sub my_context {
          my %params = ( wrapped => 0, @_ );
          $params{wrapped}++;
          my $ctx = context(%params);
          ...
          return $ctx;
      }
  
      sub my_tool {
          my $ctx = my_context();
          ...
          $ctx->release;
      }
  
  If you do not do this, then tools you call that also check for a context will
  notice that the context they grabbed was created at the same stack depth, which
  will trigger protective measures that warn you and destroy the existing
  context.
  
  =item stack => $stack
  
  Normally C<context()> looks at the global hub stack. If you are maintaining
  your own L<Test2::API::Stack> instance you may pass it in to be used
  instead of the global one.
  
  =item hub => $hub
  
  Use this parameter if you want to obtain the context for a specific hub instead
  of whatever one happens to be at the top of the stack.
  
  =item on_init => sub { ... }
  
  This lets you provide a callback sub that will be called B<ONLY> if your call
  to C<context()> generated a new context. The callback B<WILL NOT> be called if
  C<context()> is returning an existing context. The only argument passed into
  the callback will be the context object itself.
  
      sub foo {
          my $ctx = context(on_init => sub { 'will run' });
  
          my $inner = sub {
              # This callback is not run since we are getting the existing
              # context from our parent sub.
              my $ctx = context(on_init => sub { 'will NOT run' });
              $ctx->release;
          }
          $inner->();
  
          $ctx->release;
      }
  
  =item on_release => sub { ... }
  
  This lets you provide a callback sub that will be called when the context
  instance is released. This callback will be added to the returned context even
  if an existing context is returned. If multiple calls to context add callbacks,
  then all will be called in reverse order when the context is finally released.
  
      sub foo {
          my $ctx = context(on_release => sub { 'will run second' });
  
          my $inner = sub {
              my $ctx = context(on_release => sub { 'will run first' });
  
              # Neither callback runs on this release
              $ctx->release;
          }
          $inner->();
  
          # Both callbacks run here.
          $ctx->release;
      }
  
  =back
  
  =head2 release($;$)
  
  Usage:
  
  =over 4
  
  =item release $ctx;
  
  =item release $ctx, ...;
  
  =back
  
  This is intended as a shortcut that lets you release your context and return a
  value in one statement. This function will get your context, and an optional
  return value. It will release your context, then return your value. Scalar
  context is always assumed.
  
      sub tool {
          my $ctx = context();
          ...
  
          return release $ctx, 1;
      }
  
  This tool is most useful when you want to return the value you get from calling
  a function that needs to see the current context:
  
      my $ctx = context();
      my $out = some_tool(...);
      $ctx->release;
      return $out;
  
  We can combine the last 3 lines of the above like so:
  
      my $ctx = context();
      release $ctx, some_tool(...);
  
  =head2 context_do(&;@)
  
  Usage:
  
      sub my_tool {
          context_do {
              my $ctx = shift;
  
              my (@args) = @_;
  
              $ctx->ok(1, "pass");
  
              ...
  
              # No need to call $ctx->release, done for you on scope exit.
          } @_;
      }
  
  Using this inside your test tool takes care of a lot of boilerplate for you. It
  will ensure a context is acquired. It will capture and rethrow any exception. It
  will insure the context is released when you are done. It preserves the
  subroutine call context (array, scalar, void).
  
  This is the safest way to write a test tool. The only two downsides to this are a
  slight performance decrease, and some extra indentation in your source. If the
  indentation is a problem for you then you can take a peek at the next section.
  
  =head2 no_context(&;$)
  
  Usage:
  
  =over 4
  
  =item no_context { ... };
  
  =item no_context { ... } $hid;
  
      sub my_tool(&) {
          my $code = shift;
          my $ctx = context();
          ...
  
          no_context {
              # Things in here will not see our current context, they get a new
              # one.
  
              $code->();
          };
  
          ...
          $ctx->release;
      };
  
  =back
  
  This tool will hide a context for the provided block of code. This means any
  tools run inside the block will get a completely new context if they acquire
  one. The new context will be inherited by tools nested below the one that
  acquired it.
  
  This will normally hide the current context for the top hub. If you need to
  hide the context for a different hub you can pass in the optional C<$hid>
  parameter.
  
  =head2 intercept(&)
  
  Usage:
  
      my $events = intercept {
          ok(1, "pass");
          ok(0, "fail");
          ...
      };
  
  This function takes a codeblock as its only argument, and it has a prototype.
  It will execute the codeblock, intercepting any generated events in the
  process. It will return an array reference with all the generated event
  objects. All events should be subclasses of L<Test2::Event>.
  
  This is a very low-level subtest tool. This is useful for writing tools which
  produce subtests. This is not intended for people simply writing tests.
  
  =head2 run_subtest(...)
  
  Usage:
  
      run_subtest($NAME, \&CODE, $BUFFERED, @ARGS)
  
      # or
  
      run_subtest($NAME, \&CODE, \%PARAMS, @ARGS)
  
  This will run the provided codeblock with the args in C<@args>. This codeblock
  will be run as a subtest. A subtest is an isolated test state that is condensed
  into a single L<Test2::Event::Subtest> event, which contains all events
  generated inside the subtest.
  
  =head3 ARGUMENTS:
  
  =over 4
  
  =item $NAME
  
  The name of the subtest.
  
  =item \&CODE
  
  The code to run inside the subtest.
  
  =item $BUFFERED or \%PARAMS
  
  If this is a simple scalar then it will be treated as a boolean for the
  'buffered' setting. If this is a hash reference then it will be used as a
  parameters hash. The param hash will be used for hub construction (with the
  specified keys removed).
  
  Keys that are removed and used by run_subtest:
  
  =over 4
  
  =item 'buffered' => $bool
  
  Toggle buffered status.
  
  =item 'inherit_trace' => $bool
  
  Normally the subtest hub is pushed and the sub is allowed to generate its own
  root context for the hub. When this setting is turned on a root context will be
  created for the hub that shares the same trace as the current context.
  
  Set this to true if your tool is producing subtests without user-specified
  subs.
  
  =item 'no_fork' => $bool
  
  Defaults to off. Normally forking inside a subtest will actually fork the
  subtest, resulting in 2 final subtest events. This parameter will turn off that
  behavior, only the original process/thread will return a final subtest event.
  
  =back
  
  =item @ARGS
  
  Any extra arguments you want passed into the subtest code.
  
  =back
  
  =head3 BUFFERED VS UNBUFFERED (OR STREAMED)
  
  Normally all events inside and outside a subtest are sent to the formatter
  immediately by the hub. Sometimes it is desirable to hold off sending events
  within a subtest until the subtest is complete. This usually depends on the
  formatter being used.
  
  =over 4
  
  =item Things not effected by this flag
  
  In both cases events are generated and stored in an array. This array is
  eventually used to populate the C<subevents> attribute on the
  L<Test2::Event::Subtest> event that is generated at the end of the subtest.
  This flag has no effect on this part, it always happens.
  
  At the end of the subtest, the final L<Test2::Event::Subtest> event is sent to
  the formatter.
  
  =item Things that are effected by this flag
  
  The C<buffered> attribute of the L<Test2::Event::Subtest> event will be set to
  the value of this flag. This means any formatter, listener, etc which looks at
  the event will know if it was buffered.
  
  =item Things that are formatter dependant
  
  Events within a buffered subtest may or may not be sent to the formatter as
  they happen. If a formatter fails to specify then the default is to B<NOT SEND>
  the events as they are generated, instead the formatter can pull them from the
  C<subevents> attribute.
  
  A formatter can specify by implementing the C<hide_buffered()> method. If this
  method returns true then events generated inside a buffered subtest will not be
  sent independently of the final subtest event.
  
  =back
  
  An example of how this is used is the L<Test2::Formatter::TAP> formatter. For
  unbuffered subtests the events are rendered as they are generated. At the end
  of the subtest, the final subtest event is rendered, but the C<subevents>
  attribute is ignored. For buffered subtests the opposite occurs, the events are
  NOT rendered as they are generated, instead the C<subevents> attribute is used
  to render them all at once. This is useful when running subtests tests in
  parallel, since without it the output from subtests would be interleaved
  together.
  
  =head1 OTHER API EXPORTS
  
  Exports in this section are not commonly needed. These all have the 'test2_'
  prefix to help ensure they stand out. You should look at the L</MAIN API
  EXPORTS> section before looking here. This section is one where "Great power
  comes with great responsibility". It is possible to break things badly if you
  are not careful with these.
  
  All exports are optional. You need to list which ones you want at import time:
  
      use Test2::API qw/test2_init_done .../;
  
  =head2 STATUS AND INITIALIZATION STATE
  
  These provide access to internal state and object instances.
  
  =over 4
  
  =item $bool = test2_init_done()
  
  This will return true if the stack and IPC instances have already been
  initialized. It will return false if they have not. Init happens as late as
  possible. It happens as soon as a tool requests the IPC instance, the
  formatter, or the stack.
  
  =item $bool = test2_load_done()
  
  This will simply return the boolean value of the loaded flag. If Test2 has
  finished loading this will be true, otherwise false. Loading is considered
  complete the first time a tool requests a context.
  
  =item test2_set_is_end()
  
  =item test2_set_is_end($bool)
  
  This is used to toggle Test2's belief that the END phase has already started.
  With no arguments this will set it to true. With arguments it will set it to
  the first argument's value.
  
  This is used to prevent the use of C<caller()> in END blocks which can cause
  segfaults. This is only necessary in some persistent environments that may have
  multiple END phases.
  
  =item $bool = test2_get_is_end()
  
  Check if Test2 believes it is the END phase.
  
  =item $stack = test2_stack()
  
  This will return the global L<Test2::API::Stack> instance. If this has not
  yet been initialized it will be initialized now.
  
  =item test2_ipc_disable
  
  Disable IPC.
  
  =item $bool = test2_ipc_diabled
  
  Check if IPC is disabled.
  
  =item test2_ipc_wait_enable()
  
  =item test2_ipc_wait_disable()
  
  =item $bool = test2_ipc_wait_enabled()
  
  These can be used to turn IPC waiting on and off, or check the current value of
  the flag.
  
  Waiting is turned on by default. Waiting will cause the parent process/thread
  to wait until all child processes and threads are finished before exiting. You
  will almost never want to turn this off.
  
  =item $bool = test2_no_wait()
  
  =item test2_no_wait($bool)
  
  B<DISCOURAGED>: This is a confusing interface, it is better to use
  C<test2_ipc_wait_enable()>, C<test2_ipc_wait_disable()> and
  C<test2_ipc_wait_enabled()>.
  
  This can be used to get/set the no_wait status. Waiting is turned on by
  default. Waiting will cause the parent process/thread to wait until all child
  processes and threads are finished before exiting. You will almost never want
  to turn this off.
  
  =item $fh = test2_stdout()
  
  =item $fh = test2_stderr()
  
  These functions return the filehandles that test output should be written to.
  They are primarily useful when writing a custom formatter and code that turns
  events into actual output (TAP, etc.)  They will return a dupe of the original
  filehandles that formatted output can be sent to regardless of whatever state
  the currently running test may have left STDOUT and STDERR in.
  
  =item test2_reset_io()
  
  Re-dupe the internal filehandles returned by C<test2_stdout()> and
  C<test2_stderr()> from the current STDOUT and STDERR.  You shouldn't need to do
  this except in very peculiar situations (for example, you're testing a new
  formatter and you need control over where the formatter is sending its output.)
  
  =back
  
  =head2 BEHAVIOR HOOKS
  
  These are hooks that allow you to add custom behavior to actions taken by Test2
  and tools built on top of it.
  
  =over 4
  
  =item test2_add_callback_exit(sub { ... })
  
  This can be used to add a callback that is called after all testing is done. This
  is too late to add additional results, the main use of this callback is to set the
  exit code.
  
      test2_add_callback_exit(
          sub {
              my ($context, $exit, \$new_exit) = @_;
              ...
          }
      );
  
  The C<$context> passed in will be an instance of L<Test2::API::Context>. The
  C<$exit> argument will be the original exit code before anything modified it.
  C<$$new_exit> is a reference to the new exit code. You may modify this to
  change the exit code. Please note that C<$$new_exit> may already be different
  from C<$exit>
  
  =item test2_add_callback_post_load(sub { ... })
  
  Add a callback that will be called when Test2 is finished loading. This
  means the callback will be run once, the first time a context is obtained.
  If Test2 has already finished loading then the callback will be run immediately.
  
  =item test2_add_callback_testing_done(sub { ... })
  
  This adds your coderef as a follow-up to the root hub after Test2 is finished loading.
  
  This is essentially a helper to do the following:
  
      test2_add_callback_post_load(sub {
          my $stack = test2_stack();
          $stack->top; # Insure we have a hub
          my ($hub) = Test2::API::test2_stack->all;
  
          $hub->set_active(1);
  
          $hub->follow_up(sub { ... }); # <-- Your coderef here
      });
  
  =item test2_add_callback_context_acquire(sub { ... })
  
  Add a callback that will be called every time someone tries to acquire a
  context. This will be called on EVERY call to C<context()>. It gets a single
  argument, a reference to the hash of parameters being used the construct the
  context. This is your chance to change the parameters by directly altering the
  hash.
  
      test2_add_callback_context_acquire(sub {
          my $params = shift;
          $params->{level}++;
      });
  
  This is a very scary API function. Please do not use this unless you need to.
  This is here for L<Test::Builder> and backwards compatibility. This has you
  directly manipulate the hash instead of returning a new one for performance
  reasons.
  
  =item test2_add_callback_context_init(sub { ... })
  
  Add a callback that will be called every time a new context is created. The
  callback will receive the newly created context as its only argument.
  
  =item test2_add_callback_context_release(sub { ... })
  
  Add a callback that will be called every time a context is released. The
  callback will receive the released context as its only argument.
  
  =item test2_add_callback_pre_subtest(sub { ... })
  
  Add a callback that will be called every time a subtest is going to be
  run. The callback will receive the subtest name, coderef, and any
  arguments.
  
  =item @list = test2_list_context_acquire_callbacks()
  
  Return all the context acquire callback references.
  
  =item @list = test2_list_context_init_callbacks()
  
  Returns all the context init callback references.
  
  =item @list = test2_list_context_release_callbacks()
  
  Returns all the context release callback references.
  
  =item @list = test2_list_exit_callbacks()
  
  Returns all the exit callback references.
  
  =item @list = test2_list_post_load_callbacks()
  
  Returns all the post load callback references.
  
  =item @list = test2_list_pre_subtest_callbacks()
  
  Returns all the pre-subtest callback references.
  
  =item test2_add_uuid_via(sub { ... })
  
  =item $sub = test2_add_uuid_via()
  
  This allows you to provide a UUID generator. If provided UUIDs will be attached
  to all events, hubs, and contexts. This is useful for storing, tracking, and
  linking these objects.
  
  The sub you provide should always return a unique identifier. Most things will
  expect a proper UUID string, however nothing in Test2::API enforces this.
  
  The sub will receive exactly 1 argument, the type of thing being tagged
  'context', 'hub', or 'event'. In the future additional things may be tagged, in
  which case new strings will be passed in. These are purely informative, you can
  (and usually should) ignore them.
  
  =back
  
  =head2 IPC AND CONCURRENCY
  
  These let you access, or specify, the IPC system internals.
  
  =over 4
  
  =item $bool = test2_has_ipc()
  
  Check if IPC is enabled.
  
  =item $ipc = test2_ipc()
  
  This will return the global L<Test2::IPC::Driver> instance. If this has not yet
  been initialized it will be initialized now.
  
  =item test2_ipc_add_driver($DRIVER)
  
  Add an IPC driver to the list. This will add the driver to the start of the
  list.
  
  =item @drivers = test2_ipc_drivers()
  
  Get the list of IPC drivers.
  
  =item $bool = test2_ipc_polling()
  
  Check if polling is enabled.
  
  =item test2_ipc_enable_polling()
  
  Turn on polling. This will cull events from other processes and threads every
  time a context is created.
  
  =item test2_ipc_disable_polling()
  
  Turn off IPC polling.
  
  =item test2_ipc_enable_shm()
  
  Turn on IPC SHM. Only some IPC drivers use this, and most will turn it on
  themselves.
  
  =item test2_ipc_set_pending($uniq_val)
  
  Tell other processes and events that an event is pending. C<$uniq_val> should
  be a unique value no other thread/process will generate.
  
  B<Note:> After calling this C<test2_ipc_get_pending()> will return 1. This is
  intentional, and not avoidable.
  
  =item $pending = test2_ipc_get_pending()
  
  This returns -1 if there is no way to check (assume yes)
  
  This returns 0 if there are (most likely) no pending events.
  
  This returns 1 if there are (likely) pending events. Upon return it will reset,
  nothing else will be able to see that there were pending events.
  
  =item $timeout = test2_ipc_get_timeout()
  
  =item test2_ipc_set_timeout($timeout)
  
  Get/Set the timeout value for the IPC system. This timeout is how long the IPC
  system will wait for child processes and threads to finish before aborting.
  
  The default value is C<30> seconds.
  
  =back
  
  =head2 MANAGING FORMATTERS
  
  These let you access, or specify, the formatters that can/should be used.
  
  =over 4
  
  =item $formatter = test2_formatter
  
  This will return the global formatter class. This is not an instance. By
  default the formatter is set to L<Test2::Formatter::TAP>.
  
  You can override this default using the C<T2_FORMATTER> environment variable.
  
  Normally 'Test2::Formatter::' is prefixed to the value in the
  environment variable:
  
      $ T2_FORMATTER='TAP' perl test.t     # Use the Test2::Formatter::TAP formatter
      $ T2_FORMATTER='Foo' perl test.t     # Use the Test2::Formatter::Foo formatter
  
  If you want to specify a full module name you use the '+' prefix:
  
      $ T2_FORMATTER='+Foo::Bar' perl test.t     # Use the Foo::Bar formatter
  
  =item test2_formatter_set($class_or_instance)
  
  Set the global formatter class. This can only be set once. B<Note:> This will
  override anything specified in the 'T2_FORMATTER' environment variable.
  
  =item @formatters = test2_formatters()
  
  Get a list of all loaded formatters.
  
  =item test2_formatter_add($class_or_instance)
  
  Add a formatter to the list. Last formatter added is used at initialization. If
  this is called after initialization a warning will be issued.
  
  =back
  
  =head1 OTHER EXAMPLES
  
  See the C</Examples/> directory included in this distribution.
  
  =head1 SEE ALSO
  
  L<Test2::API::Context> - Detailed documentation of the context object.
  
  L<Test2::IPC> - The IPC system used for threading/fork support.
  
  L<Test2::Formatter> - Formatters such as TAP live here.
  
  L<Test2::Event> - Events live in this namespace.
  
  L<Test2::Hub> - All events eventually funnel through a hub. Custom hubs are how
  C<intercept()> and C<run_subtest()> are implemented.
  
  =head1 MAGIC
  
  This package has an END block. This END block is responsible for setting the
  exit code based on the test results. This end block also calls the callbacks that
  can be added to this package.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API

$fatpacked{"Test2/API/Breakage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_BREAKAGE';
  package Test2::API::Breakage;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::Util qw/pkg_to_file/;
  
  our @EXPORT_OK = qw{
      upgrade_suggested
      upgrade_required
      known_broken
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub upgrade_suggested {
      return (
          'Test::Exception'    => '0.42',
          'Test::FITesque'     => '0.04',
          'Test::Module::Used' => '0.2.5',
          'Test::Moose::More'  => '0.025',
      );
  }
  
  sub upgrade_required {
      return (
          'Test::Builder::Clutch'   => '0.07',
          'Test::Dist::VersionSync' => '1.1.4',
          'Test::Modern'            => '0.012',
          'Test::SharedFork'        => '0.34',
          'Test::Alien'             => '0.04',
          'Test::UseAllModules'     => '0.14',
          'Test::More::Prefix'      => '0.005',
  
          'Test2::Tools::EventDumper' => 0.000007,
          'Test2::Harness'            => 0.000013,
  
          'Test::DBIx::Class::Schema'    => '1.0.9',
          'Test::Clustericious::Cluster' => '0.30',
      );
  }
  
  sub known_broken {
      return (
          'Net::BitTorrent'       => '0.052',
          'Test::Able'            => '0.11',
          'Test::Aggregate'       => '0.373',
          'Test::Flatten'         => '0.11',
          'Test::Group'           => '0.20',
          'Test::ParallelSubtest' => '0.05',
          'Test::Pretty'          => '0.32',
          'Test::Wrapper'         => '0.3.0',
  
          'Log::Dispatch::Config::TestLog' => '0.02',
      );
  }
  
  # Not reportable:
  # Device::Chip => 0.07   - Tests will not pass, but not broken if already installed, also no fixed version we can upgrade to.
  
  sub report {
      my $class = shift;
      my ($require) = @_;
  
      my %suggest  = __PACKAGE__->upgrade_suggested();
      my %required = __PACKAGE__->upgrade_required();
      my %broken   = __PACKAGE__->known_broken();
  
      my @warn;
      for my $mod (keys %suggest) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $want = $suggest{$mod};
          next if eval { $mod->VERSION($want); 1 };
          push @warn => " * Module '$mod' is outdated, we recommed updating above $want.";
      }
  
      for my $mod (keys %required) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $want = $required{$mod};
          next if eval { $mod->VERSION($want); 1 };
          push @warn => " * Module '$mod' is outdated and known to be broken, please update to $want or higher.";
      }
  
      for my $mod (keys %broken) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $tested = $broken{$mod};
          push @warn => " * Module '$mod' is known to be broken in version $tested and below, newer versions have not been tested. You have: " . $mod->VERSION;
      }
  
      return @warn;
  }
  
  1;
  
  __END__
  
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Breakage - What breaks at what version
  
  =head1 DESCRIPTION
  
  This module provides lists of modules that are broken, or have been broken in
  the past, when upgrading L<Test::Builder> to use L<Test2>.
  
  =head1 FUNCTIONS
  
  These can be imported, or called as methods on the class.
  
  =over 4
  
  =item %mod_ver = upgrade_suggested()
  
  =item %mod_ver = Test2::API::Breakage->upgrade_suggested()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then an upgrade would be a good idea, but not strictly necessary.
  
  =item %mod_ver = upgrade_required()
  
  =item %mod_ver = Test2::API::Breakage->upgrade_required()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then an upgrade is required for the module to work properly.
  
  =item %mod_ver = known_broken()
  
  =item %mod_ver = Test2::API::Breakage->known_broken()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then the module will not work. A newer version may work, but is
  not tested or verified.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_BREAKAGE

$fatpacked{"Test2/API/Context.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_CONTEXT';
  package Test2::API::Context;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/confess croak/;
  use Scalar::Util qw/weaken blessed/;
  use Test2::Util qw/get_tid try pkg_to_file get_tid/;
  
  use Test2::EventFacet::Trace();
  use Test2::API();
  
  # Preload some key event types
  my %LOADED = (
      map {
          my $pkg  = "Test2::Event::$_";
          my $file = "Test2/Event/$_.pm";
          require $file unless $INC{$file};
          ( $pkg => $pkg, $_ => $pkg )
      } qw/Ok Diag Note Plan Bail Exception Waiting Skip Subtest Pass Fail V2/
  );
  
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util::HashBase qw{
      stack hub trace _on_release _depth _is_canon _is_spawn _aborted
      errno eval_error child_error thrown
  };
  
  # Private, not package vars
  # It is safe to cache these.
  my $ON_RELEASE = Test2::API::_context_release_callbacks_ref();
  my $CONTEXTS   = Test2::API::_contexts_ref();
  
  sub init {
      my $self = shift;
  
      confess "The 'trace' attribute is required"
          unless $self->{+TRACE};
  
      confess "The 'hub' attribute is required"
          unless $self->{+HUB};
  
      $self->{+_DEPTH} = 0 unless defined $self->{+_DEPTH};
  
      $self->{+ERRNO}       = $! unless exists $self->{+ERRNO};
      $self->{+EVAL_ERROR}  = $@ unless exists $self->{+EVAL_ERROR};
      $self->{+CHILD_ERROR} = $? unless exists $self->{+CHILD_ERROR};
  }
  
  sub snapshot { bless {%{$_[0]}, _is_canon => undef, _is_spawn => undef, _aborted => undef}, __PACKAGE__ }
  
  sub restore_error_vars {
      my $self = shift;
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR};
  }
  
  sub DESTROY {
      return unless $_[0]->{+_IS_CANON} || $_[0]->{+_IS_SPAWN};
      return if $_[0]->{+_ABORTED} && ${$_[0]->{+_ABORTED}};
      my ($self) = @_;
  
      my $hub = $self->{+HUB};
      my $hid = $hub->{hid};
  
      # Do not show the warning if it looks like an exception has been thrown, or
      # if the context is not local to this process or thread.
      {
          # Sometimes $@ is uninitialized, not a problem in this case so do not
          # show the warning about using eq.
          no warnings 'uninitialized';
          if($self->{+EVAL_ERROR} eq $@ && $hub->is_local) {
              my $frame = $self->{+_IS_SPAWN} || $self->{+TRACE}->frame;
              warn <<"            EOT";
  A context appears to have been destroyed without first calling release().
  Based on \$@ it does not look like an exception was thrown (this is not always
  a reliable test)
  
  This is a problem because the global error variables (\$!, \$@, and \$?) will
  not be restored. In addition some release callbacks will not work properly from
  inside a DESTROY method.
  
  Here are the context creation details, just in case a tool forgot to call
  release():
    File: $frame->[1]
    Line: $frame->[2]
    Tool: $frame->[3]
  
  Cleaning up the CONTEXT stack...
              EOT
          }
      }
  
      return if $self->{+_IS_SPAWN};
  
      # Remove the key itself to avoid a slow memory leak
      delete $CONTEXTS->{$hid};
      $self->{+_IS_CANON} = undef;
  
      if (my $cbk = $self->{+_ON_RELEASE}) {
          $_->($self) for reverse @$cbk;
      }
      if (my $hcbk = $hub->{_context_release}) {
          $_->($self) for reverse @$hcbk;
      }
      $_->($self) for reverse @$ON_RELEASE;
  }
  
  # release exists to implement behaviors like die-on-fail. In die-on-fail you
  # want to die after a failure, but only after diagnostics have been reported.
  # The ideal time for the die to happen is when the context is released.
  # Unfortunately die does not work in a DESTROY block.
  sub release {
      my ($self) = @_;
  
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} and return if $self->{+THROWN};
  
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} and return $self->{+_IS_SPAWN} = undef
          if $self->{+_IS_SPAWN};
  
      croak "release() should not be called on context that is neither canon nor a child"
          unless $self->{+_IS_CANON};
  
      my $hub = $self->{+HUB};
      my $hid = $hub->{hid};
  
      croak "context thinks it is canon, but it is not"
          unless $CONTEXTS->{$hid} && $CONTEXTS->{$hid} == $self;
  
      # Remove the key itself to avoid a slow memory leak
      $self->{+_IS_CANON} = undef;
      delete $CONTEXTS->{$hid};
  
      if (my $cbk = $self->{+_ON_RELEASE}) {
          $_->($self) for reverse @$cbk;
      }
      if (my $hcbk = $hub->{_context_release}) {
          $_->($self) for reverse @$hcbk;
      }
      $_->($self) for reverse @$ON_RELEASE;
  
      # Do this last so that nothing else changes them.
      # If one of the hooks dies then these do not get restored, this is
      # intentional
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR};
  
      return;
  }
  
  sub do_in_context {
      my $self = shift;
      my ($sub, @args) = @_;
  
      # We need to update the pid/tid and error vars.
      my $clone = $self->snapshot;
      @$clone{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} = ($!, $@, $?);
      $clone->{+TRACE} = $clone->{+TRACE}->snapshot(pid => $$, tid => get_tid());
  
      my $hub = $clone->{+HUB};
      my $hid = $hub->hid;
  
      my $old = $CONTEXTS->{$hid};
  
      $clone->{+_IS_CANON} = 1;
      $CONTEXTS->{$hid} = $clone;
      weaken($CONTEXTS->{$hid});
      my ($ok, $err) = &try($sub, @args);
      my ($rok, $rerr) = try { $clone->release };
      delete $clone->{+_IS_CANON};
  
      if ($old) {
          $CONTEXTS->{$hid} = $old;
          weaken($CONTEXTS->{$hid});
      }
      else {
          delete $CONTEXTS->{$hid};
      }
  
      die $err  unless $ok;
      die $rerr unless $rok;
  }
  
  sub done_testing {
      my $self = shift;
      $self->hub->finalize($self->trace, 1);
      return;
  }
  
  sub throw {
      my ($self, $msg) = @_;
      $self->{+THROWN} = 1;
      ${$self->{+_ABORTED}}++ if $self->{+_ABORTED};
      $self->release if $self->{+_IS_CANON} || $self->{+_IS_SPAWN};
      $self->trace->throw($msg);
  }
  
  sub alert {
      my ($self, $msg) = @_;
      $self->trace->alert($msg);
  }
  
  sub send_ev2_and_release {
      my $self = shift;
      my $out  = $self->send_ev2(@_);
      $self->release;
      return $out;
  }
  
  sub send_ev2 {
      my $self = shift;
  
      my $e;
      {
          local $Carp::CarpLevel = $Carp::CarpLevel + 1;
          $e = Test2::Event::V2->new(
              trace => $self->{+TRACE}->snapshot,
              @_,
          );
      }
  
      if ($self->{+_ABORTED}) {
          my $f = $e->facet_data;
          ${$self->{+_ABORTED}}++ if $f->{control}->{halt} || defined($f->{control}->{terminate}) || defined($e->terminate);
      }
      $self->{+HUB}->send($e);
  }
  
  sub build_ev2 {
      my $self = shift;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      Test2::Event::V2->new(
          trace => $self->{+TRACE}->snapshot,
          @_,
      );
  }
  
  sub send_event_and_release {
      my $self = shift;
      my $out = $self->send_event(@_);
      $self->release;
      return $out;
  }
  
  sub send_event {
      my $self  = shift;
      my $event = shift;
      my %args  = @_;
  
      my $pkg = $LOADED{$event} || $self->_parse_event($event);
  
      my $e;
      {
          local $Carp::CarpLevel = $Carp::CarpLevel + 1;
          $e = $pkg->new(
              trace => $self->{+TRACE}->snapshot,
              %args,
          );
      }
  
      if ($self->{+_ABORTED}) {
          my $f = $e->facet_data;
          ${$self->{+_ABORTED}}++ if $f->{control}->{halt} || defined($f->{control}->{terminate}) || defined($e->terminate);
      }
      $self->{+HUB}->send($e);
  }
  
  sub build_event {
      my $self  = shift;
      my $event = shift;
      my %args  = @_;
  
      my $pkg = $LOADED{$event} || $self->_parse_event($event);
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      $pkg->new(
          trace => $self->{+TRACE}->snapshot,
          %args,
      );
  }
  
  sub pass {
      my $self = shift;
      my ($name) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Pass"
      );
  
      $self->{+HUB}->send($e);
      return $e;
  }
  
  sub pass_and_release {
      my $self = shift;
      my ($name) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Pass"
      );
  
      $self->{+HUB}->send($e);
      $self->release;
      return 1;
  }
  
  sub fail {
      my $self = shift;
      my ($name, @diag) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Fail"
      );
  
      $e->add_info({tag => 'DIAG', debug => 1, details => $_}) for @diag;
      $self->{+HUB}->send($e);
      return $e;
  }
  
  sub fail_and_release {
      my $self = shift;
      my ($name, @diag) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Fail"
      );
  
      $e->add_info({tag => 'DIAG', debug => 1, details => $_}) for @diag;
      $self->{+HUB}->send($e);
      $self->release;
      return 0;
  }
  
  sub ok {
      my $self = shift;
      my ($pass, $name, $on_fail) = @_;
  
      my $hub = $self->{+HUB};
  
      my $e = bless {
          trace => bless( {%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
          pass  => $pass,
          name  => $name,
      }, 'Test2::Event::Ok';
      $e->init;
  
      $hub->send($e);
      return $e if $pass;
  
      $self->failure_diag($e);
  
      if ($on_fail && @$on_fail) {
          $self->diag($_) for @$on_fail;
      }
  
      return $e;
  }
  
  sub failure_diag {
      my $self = shift;
      my ($e) = @_;
  
      # Figure out the debug info, this is typically the file name and line
      # number, but can also be a custom message. If no trace object is provided
      # then we have nothing useful to display.
      my $name  = $e->name;
      my $trace = $e->trace;
      my $debug = $trace ? $trace->debug : "[No trace info available]";
  
      # Create the initial diagnostics. If the test has a name we put the debug
      # info on a second line, this behavior is inherited from Test::Builder.
      my $msg = defined($name)
          ? qq[Failed test '$name'\n$debug.\n]
          : qq[Failed test $debug.\n];
  
      $self->diag($msg);
  }
  
  sub skip {
      my $self = shift;
      my ($name, $reason, @extra) = @_;
      $self->send_event(
          'Skip',
          name => $name,
          reason => $reason,
          pass => 1,
          @extra,
      );
  }
  
  sub note {
      my $self = shift;
      my ($message) = @_;
      $self->send_event('Note', message => $message);
  }
  
  sub diag {
      my $self = shift;
      my ($message) = @_;
      my $hub = $self->{+HUB};
      $self->send_event(
          'Diag',
          message => $message,
      );
  }
  
  sub plan {
      my ($self, $max, $directive, $reason) = @_;
      $self->send_event('Plan', max => $max, directive => $directive, reason => $reason);
  }
  
  sub bail {
      my ($self, $reason) = @_;
      $self->send_event('Bail', reason => $reason);
  }
  
  sub _parse_event {
      my $self = shift;
      my $event = shift;
  
      my $pkg;
      if ($event =~ m/^\+(.*)/) {
          $pkg = $1;
      }
      else {
          $pkg = "Test2::Event::$event";
      }
  
      unless ($LOADED{$pkg}) {
          my $file = pkg_to_file($pkg);
          my ($ok, $err) = try { require $file };
          $self->throw("Could not load event module '$pkg': $err")
              unless $ok;
  
          $LOADED{$pkg} = $pkg;
      }
  
      confess "'$pkg' is not a subclass of 'Test2::Event'"
          unless $pkg->isa('Test2::Event');
  
      $LOADED{$event} = $pkg;
  
      return $pkg;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Context - Object to represent a testing context.
  
  =head1 DESCRIPTION
  
  The context object is the primary interface for authors of testing tools
  written with L<Test2>. The context object represents the context in
  which a test takes place (File and Line Number), and provides a quick way to
  generate events from that context. The context object also takes care of
  sending events to the correct L<Test2::Hub> instance.
  
  =head1 SYNOPSIS
  
  In general you will not be creating contexts directly. To obtain a context you
  should always use C<context()> which is exported by the L<Test2::API> module.
  
      use Test2::API qw/context/;
  
      sub my_ok {
          my ($bool, $name) = @_;
          my $ctx = context();
          $ctx->ok($bool, $name);
          $ctx->release; # You MUST do this!
          return $bool;
      }
  
  Context objects make it easy to wrap other tools that also use context. Once
  you grab a context, any tool you call before releasing your context will
  inherit it:
  
      sub wrapper {
          my ($bool, $name) = @_;
          my $ctx = context();
          $ctx->diag("wrapping my_ok");
  
          my $out = my_ok($bool, $name);
          $ctx->release; # You MUST do this!
          return $out;
      }
  
  =head1 CRITICAL DETAILS
  
  =over 4
  
  =item you MUST always use the context() sub from Test2::API
  
  Creating your own context via C<< Test2::API::Context->new() >> will almost never
  produce a desirable result. Use C<context()> which is exported by L<Test2::API>.
  
  There are a handful of cases where a tool author may want to create a new
  context by hand, which is why the C<new> method exists. Unless you really know
  what you are doing you should avoid this.
  
  =item You MUST always release the context when done with it
  
  Releasing the context tells the system you are done with it. This gives it a
  chance to run any necessary callbacks or cleanup tasks. If you forget to
  release the context it will try to detect the problem and warn you about it.
  
  =item You MUST NOT pass context objects around
  
  When you obtain a context object it is made specifically for your tool and any
  tools nested within. If you pass a context around you run the risk of polluting
  other tools with incorrect context information.
  
  If you are certain that you want a different tool to use the same context you
  may pass it a snapshot. C<< $ctx->snapshot >> will give you a shallow clone of
  the context that is safe to pass around or store.
  
  =item You MUST NOT store or cache a context for later
  
  As long as a context exists for a given hub, all tools that try to get a
  context will get the existing instance. If you try to store the context you
  will pollute other tools with incorrect context information.
  
  If you are certain that you want to save the context for later, you can use a
  snapshot. C<< $ctx->snapshot >> will give you a shallow clone of the context
  that is safe to pass around or store.
  
  C<context()> has some mechanisms to protect you if you do cause a context to
  persist beyond the scope in which it was obtained. In practice you should not
  rely on these protections, and they are fairly noisy with warnings.
  
  =item You SHOULD obtain your context as soon as possible in a given tool
  
  You never know what tools you call from within your own tool will need a
  context. Obtaining the context early ensures that nested tools can find the
  context you want them to find.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item $ctx->done_testing;
  
  Note that testing is finished. If no plan has been set this will generate a
  Plan event.
  
  =item $clone = $ctx->snapshot()
  
  This will return a shallow clone of the context. The shallow clone is safe to
  store for later.
  
  =item $ctx->release()
  
  This will release the context. This runs cleanup tasks, and several important
  hooks. It will also restore C<$!>, C<$?>, and C<$@> to what they were when the
  context was created.
  
  B<Note:> If a context is acquired more than once an internal refcount is kept.
  C<release()> decrements the ref count, none of the other actions of
  C<release()> will occur unless the refcount hits 0. This means only the last
  call to C<release()> will reset C<$?>, C<$!>, C<$@>,and run the cleanup tasks.
  
  =item $ctx->throw($message)
  
  This will throw an exception reporting to the file and line number of the
  context. This will also release the context for you.
  
  =item $ctx->alert($message)
  
  This will issue a warning from the file and line number of the context.
  
  =item $stack = $ctx->stack()
  
  This will return the L<Test2::API::Stack> instance the context used to find
  the current hub.
  
  =item $hub = $ctx->hub()
  
  This will return the L<Test2::Hub> instance the context recognizes as the
  current one to which all events should be sent.
  
  =item $dbg = $ctx->trace()
  
  This will return the L<Test2::EventFacet::Trace> instance used by the context.
  
  =item $ctx->do_in_context(\&code, @args);
  
  Sometimes you have a context that is not current, and you want things to use it
  as the current one. In these cases you can call
  C<< $ctx->do_in_context(sub { ... }) >>. The codeblock will be run, and
  anything inside of it that looks for a context will find the one on which the
  method was called.
  
  This B<DOES NOT> affect context on other hubs, only the hub used by the context
  will be affected.
  
      my $ctx = ...;
      $ctx->do_in_context(sub {
          my $ctx = context(); # returns the $ctx the sub is called on
      });
  
  B<Note:> The context will actually be cloned, the clone will be used instead of
  the original. This allows the thread id, process id, and error variables to be correct without
  modifying the original context.
  
  =item $ctx->restore_error_vars()
  
  This will set C<$!>, C<$?>, and C<$@> to what they were when the context was
  created. There is no localization or anything done here, calling this method
  will actually set these vars.
  
  =item $! = $ctx->errno()
  
  The (numeric) value of C<$!> when the context was created.
  
  =item $? = $ctx->child_error()
  
  The value of C<$?> when the context was created.
  
  =item $@ = $ctx->eval_error()
  
  The value of C<$@> when the context was created.
  
  =back
  
  =head2 EVENT PRODUCTION METHODS
  
  B<Which one do I use?>
  
  The C<pass*> and C<fail*> are optimal if they meet your situation, using one of
  them will always be the most optimal. That said they are optimal by eliminating
  many features.
  
  Method such as C<ok>, and C<note> are shortcuts for generating common 1-task
  events based on the old API, however they are forward compatible, and easy to
  use. If these meet your needs then go ahead and use them, but please check back
  often for alternatives that may be added.
  
  If you want to generate new style events, events that do many things at once,
  then you want the C<*ev2*> methods. These let you directly specify which facets
  you wish to use.
  
  =over 4
  
  =item $event = $ctx->pass()
  
  =item $event = $ctx->pass($name)
  
  This will send and return an L<Test2::Event::Pass> event. You may optionally
  provide a C<$name> for the assertion.
  
  The L<Test2::Event::Pass> is a specially crafted and optimized event, using
  this will help the performance of passing tests.
  
  =item $true = $ctx->pass_and_release()
  
  =item $true = $ctx->pass_and_release($name)
  
  This is a combination of C<pass()> and C<release()>. You can use this if you do
  not plan to do anything with the context after sending the event. This helps
  write more clear and compact code.
  
      sub shorthand {
          my ($bool, $name) = @_;
          my $ctx = context();
          return $ctx->pass_and_release($name) if $bool;
  
          ... Handle a failure ...
      }
  
      sub longform {
          my ($bool, $name) = @_;
          my $ctx = context();
  
          if ($bool) {
              $ctx->pass($name);
              $ctx->release;
              return 1;
          }
  
          ... Handle a failure ...
      }
  
  =item my $event = $ctx->fail()
  
  =item my $event = $ctx->fail($name)
  
  =item my $event = $ctx->fail($name, @diagnostics)
  
  This lets you send an L<Test2::Event::Fail> event. You may optionally provide a
  C<$name> and C<@diagnostics> messages.
  
  =item my $false = $ctx->fail_and_release()
  
  =item my $false = $ctx->fail_and_release($name)
  
  =item my $false = $ctx->fail_and_release($name, @diagnostics)
  
  This is a combination of C<fail()> and C<release()>. This can be used to write
  clearer and shorter code.
  
      sub shorthand {
          my ($bool, $name) = @_;
          my $ctx = context();
          return $ctx->fail_and_release($name) unless $bool;
  
          ... Handle a success ...
      }
  
      sub longform {
          my ($bool, $name) = @_;
          my $ctx = context();
  
          unless ($bool) {
              $ctx->pass($name);
              $ctx->release;
              return 1;
          }
  
          ... Handle a success ...
      }
  
  
  =item $event = $ctx->ok($bool, $name)
  
  =item $event = $ctx->ok($bool, $name, \@on_fail)
  
  B<NOTE:> Use of this method is discouraged in favor of C<pass()> and C<fail()>
  which produce L<Test2::Event::Pass> and L<Test2::Event::Fail> events. These
  newer event types are faster and less crufty.
  
  This will create an L<Test2::Event::Ok> object for you. If C<$bool> is false
  then an L<Test2::Event::Diag> event will be sent as well with details about the
  failure. If you do not want automatic diagnostics you should use the
  C<send_event()> method directly.
  
  The third argument C<\@on_fail>) is an optional set of diagnostics to be sent in
  the event of a test failure.
  
  =item $event = $ctx->note($message)
  
  Send an L<Test2::Event::Note>. This event prints a message to STDOUT.
  
  =item $event = $ctx->diag($message)
  
  Send an L<Test2::Event::Diag>. This event prints a message to STDERR.
  
  =item $event = $ctx->plan($max)
  
  =item $event = $ctx->plan(0, 'SKIP', $reason)
  
  This can be used to send an L<Test2::Event::Plan> event. This event
  usually takes either a number of tests you expect to run. Optionally you can
  set the expected count to 0 and give the 'SKIP' directive with a reason to
  cause all tests to be skipped.
  
  =item $event = $ctx->skip($name, $reason);
  
  Send an L<Test2::Event::Skip> event.
  
  =item $event = $ctx->bail($reason)
  
  This sends an L<Test2::Event::Bail> event. This event will completely
  terminate all testing.
  
  =item $event = $ctx->send_ev2(%facets)
  
  This lets you build and send a V2 event directly from facets. The event is
  returned after it is sent.
  
  This example sends a single assertion, a note (comment for stdout in
  Test::Builder talk) and sets the plan to 1.
  
      my $event = $ctx->send_event(
          plan   => {count => 1},
          assert => {pass  => 1, details => "A passing assert"},
          info => [{tag => 'NOTE', details => "This is a note"}],
      );
  
  =item $event = $ctx->build_e2(%facets)
  
  This is the same as C<send_ev2()>, except it builds and returns the event
  without sending it.
  
  =item $event = $ctx->send_ev2_and_release($Type, %parameters)
  
  This is a combination of C<send_ev2()> and C<release()>.
  
      sub shorthand {
          my $ctx = context();
          return $ctx->send_ev2_and_release(assert => {pass => 1, details => 'foo'});
      }
  
      sub longform {
          my $ctx = context();
          my $event = $ctx->send_ev2(assert => {pass => 1, details => 'foo'});
          $ctx->release;
          return $event;
      }
  
  =item $event = $ctx->send_event($Type, %parameters)
  
  B<It is better to use send_ev2() in new code.>
  
  This lets you build and send an event of any type. The C<$Type> argument should
  be the event package name with C<Test2::Event::> left off, or a fully
  qualified package name prefixed with a '+'. The event is returned after it is
  sent.
  
      my $event = $ctx->send_event('Ok', ...);
  
  or
  
      my $event = $ctx->send_event('+Test2::Event::Ok', ...);
  
  =item $event = $ctx->build_event($Type, %parameters)
  
  B<It is better to use build_ev2() in new code.>
  
  This is the same as C<send_event()>, except it builds and returns the event
  without sending it.
  
  =item $event = $ctx->send_event_and_release($Type, %parameters)
  
  B<It is better to use send_ev2_and_release() in new code.>
  
  This is a combination of C<send_event()> and C<release()>.
  
      sub shorthand {
          my $ctx = context();
          return $ctx->send_event_and_release(Pass => { name => 'foo' });
      }
  
      sub longform {
          my $ctx = context();
          my $event = $ctx->send_event(Pass => { name => 'foo' });
          $ctx->release;
          return $event;
      }
  
  =back
  
  =head1 HOOKS
  
  There are 2 types of hooks, init hooks, and release hooks. As the names
  suggest, these hooks are triggered when contexts are created or released.
  
  =head2 INIT HOOKS
  
  These are called whenever a context is initialized. That means when a new
  instance is created. These hooks are B<NOT> called every time something
  requests a context, just when a new one is created.
  
  =head3 GLOBAL
  
  This is how you add a global init callback. Global callbacks happen for every
  context for any hub or stack.
  
      Test2::API::test2_add_callback_context_init(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER HUB
  
  This is how you add an init callback for all contexts created for a given hub.
  These callbacks will not run for other hubs.
  
      $hub->add_context_init(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER CONTEXT
  
  This is how you specify an init hook that will only run if your call to
  C<context()> generates a new context. The callback will be ignored if
  C<context()> is returning an existing context.
  
      my $ctx = context(on_init => sub {
          my $ctx = shift;
          ...
      });
  
  =head2 RELEASE HOOKS
  
  These are called whenever a context is released. That means when the last
  reference to the instance is about to be destroyed. These hooks are B<NOT>
  called every time C<< $ctx->release >> is called.
  
  =head3 GLOBAL
  
  This is how you add a global release callback. Global callbacks happen for every
  context for any hub or stack.
  
      Test2::API::test2_add_callback_context_release(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER HUB
  
  This is how you add a release callback for all contexts created for a given
  hub. These callbacks will not run for other hubs.
  
      $hub->add_context_release(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER CONTEXT
  
  This is how you add release callbacks directly to a context. The callback will
  B<ALWAYS> be added to the context that gets returned, it does not matter if a
  new one is generated, or if an existing one is returned.
  
      my $ctx = context(on_release => sub {
          my $ctx = shift;
          ...
      });
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_CONTEXT

$fatpacked{"Test2/API/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INSTANCE';
  package Test2::API::Instance;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  our @CARP_NOT = qw/Test2::API Test2::API::Instance Test2::IPC::Driver Test2::Formatter/;
  use Carp qw/confess carp/;
  use Scalar::Util qw/reftype/;
  
  use Test2::Util qw/get_tid USE_THREADS CAN_FORK pkg_to_file try CAN_SIGSYS/;
  
  use Test2::EventFacet::Trace();
  use Test2::API::Stack();
  
  use Test2::Util::HashBase qw{
      _pid _tid
      no_wait
      finalized loaded
      ipc stack formatter
      contexts
  
      add_uuid_via
  
      -preload
  
      ipc_disabled
      ipc_shm_size
      ipc_shm_last
      ipc_shm_id
      ipc_polling
      ipc_drivers
      ipc_timeout
      formatters
  
      exit_callbacks
      post_load_callbacks
      context_acquire_callbacks
      context_init_callbacks
      context_release_callbacks
      pre_subtest_callbacks
  };
  
  sub DEFAULT_IPC_TIMEOUT() { 30 }
  
  sub pid { $_[0]->{+_PID} }
  sub tid { $_[0]->{+_TID} }
  
  # Wrap around the getters that should call _finalize.
  BEGIN {
      for my $finalizer (IPC, FORMATTER) {
          my $orig = __PACKAGE__->can($finalizer);
          my $new  = sub {
              my $self = shift;
              $self->_finalize unless $self->{+FINALIZED};
              $self->$orig;
          };
  
          no strict 'refs';
          no warnings 'redefine';
          *{$finalizer} = $new;
      }
  }
  
  sub has_ipc { !!$_[0]->{+IPC} }
  
  sub import {
      my $class = shift;
      return unless @_;
      my ($ref) = @_;
      $$ref = $class->new;
  }
  
  sub init { $_[0]->reset }
  
  sub start_preload {
      my $self = shift;
  
      confess "preload cannot be started, Test2::API has already been initialized"
          if $self->{+FINALIZED} || $self->{+LOADED};
  
      return $self->{+PRELOAD} = 1;
  }
  
  sub stop_preload {
      my $self = shift;
  
      return 0 unless $self->{+PRELOAD};
      $self->{+PRELOAD} = 0;
  
      $self->post_preload_reset();
  
      return 1;
  }
  
  sub post_preload_reset {
      my $self = shift;
  
      delete $self->{+_PID};
      delete $self->{+_TID};
  
      $self->{+ADD_UUID_VIA} = undef unless exists $self->{+ADD_UUID_VIA};
  
      $self->{+CONTEXTS} = {};
  
      $self->{+FORMATTERS} = [];
  
      $self->{+FINALIZED} = undef;
      $self->{+IPC}       = undef;
      $self->{+IPC_DISABLED} = $ENV{T2_NO_IPC} ? 1 : 0;
  
      $self->{+IPC_TIMEOUT} = DEFAULT_IPC_TIMEOUT() unless defined $self->{+IPC_TIMEOUT};
  
      $self->{+LOADED} = 0;
  
      $self->{+STACK} ||= Test2::API::Stack->new;
  }
  
  sub reset {
      my $self = shift;
  
      delete $self->{+_PID};
      delete $self->{+_TID};
  
      $self->{+ADD_UUID_VIA} = undef;
  
      $self->{+CONTEXTS} = {};
  
      $self->{+IPC_DRIVERS} = [];
      $self->{+IPC_POLLING} = undef;
  
      $self->{+FORMATTERS} = [];
      $self->{+FORMATTER}  = undef;
  
      $self->{+FINALIZED}    = undef;
      $self->{+IPC}          = undef;
      $self->{+IPC_DISABLED} = $ENV{T2_NO_IPC} ? 1 : 0;
  
      $self->{+IPC_TIMEOUT} = DEFAULT_IPC_TIMEOUT() unless defined $self->{+IPC_TIMEOUT};
  
      $self->{+NO_WAIT} = 0;
      $self->{+LOADED}  = 0;
  
      $self->{+EXIT_CALLBACKS}            = [];
      $self->{+POST_LOAD_CALLBACKS}       = [];
      $self->{+CONTEXT_ACQUIRE_CALLBACKS} = [];
      $self->{+CONTEXT_INIT_CALLBACKS}    = [];
      $self->{+CONTEXT_RELEASE_CALLBACKS} = [];
      $self->{+PRE_SUBTEST_CALLBACKS}     = [];
  
      $self->{+STACK} = Test2::API::Stack->new;
  }
  
  sub _finalize {
      my $self = shift;
      my ($caller) = @_;
      $caller ||= [caller(1)];
  
      confess "Attempt to initialize Test2::API during preload"
          if $self->{+PRELOAD};
  
      $self->{+FINALIZED} = $caller;
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      unless ($self->{+FORMATTER}) {
          my ($formatter, $source);
          if ($ENV{T2_FORMATTER}) {
              $source = "set by the 'T2_FORMATTER' environment variable";
  
              if ($ENV{T2_FORMATTER} =~ m/^(\+)?(.*)$/) {
                  $formatter = $1 ? $2 : "Test2::Formatter::$2"
              }
              else {
                  $formatter = '';
              }
          }
          elsif (@{$self->{+FORMATTERS}}) {
              ($formatter) = @{$self->{+FORMATTERS}};
              $source = "Most recently added";
          }
          else {
              $formatter = 'Test2::Formatter::TAP';
              $source    = 'default formatter';
          }
  
          unless (ref($formatter) || $formatter->can('write')) {
              my $file = pkg_to_file($formatter);
              my ($ok, $err) = try { require $file };
              unless ($ok) {
                  my $line   = "* COULD NOT LOAD FORMATTER '$formatter' ($source) *";
                  my $border = '*' x length($line);
                  die "\n\n  $border\n  $line\n  $border\n\n$err";
              }
          }
  
          $self->{+FORMATTER} = $formatter;
      }
  
      # Turn on IPC if threads are on, drivers are registered, or the Test2::IPC
      # module is loaded.
      return if $self->{+IPC_DISABLED};
      return unless USE_THREADS || $INC{'Test2/IPC.pm'} || @{$self->{+IPC_DRIVERS}};
  
      # Turn on polling by default, people expect it.
      $self->enable_ipc_polling;
  
      unless (@{$self->{+IPC_DRIVERS}}) {
          my ($ok, $error) = try { require Test2::IPC::Driver::Files };
          die $error unless $ok;
          push @{$self->{+IPC_DRIVERS}} => 'Test2::IPC::Driver::Files';
      }
  
      for my $driver (@{$self->{+IPC_DRIVERS}}) {
          next unless $driver->can('is_viable') && $driver->is_viable;
          $self->{+IPC} = $driver->new or next;
          $self->ipc_enable_shm if $self->{+IPC}->use_shm;
          return;
      }
  
      die "IPC has been requested, but no viable drivers were found. Aborting...\n";
  }
  
  sub formatter_set { $_[0]->{+FORMATTER} ? 1 : 0 }
  
  sub add_formatter {
      my $self = shift;
      my ($formatter) = @_;
      unshift @{$self->{+FORMATTERS}} => $formatter;
  
      return unless $self->{+FINALIZED};
  
      # Why is the @CARP_NOT entry not enough?
      local %Carp::Internal = %Carp::Internal;
      $Carp::Internal{'Test2::Formatter'} = 1;
  
      carp "Formatter $formatter loaded too late to be used as the global formatter";
  }
  
  sub add_context_acquire_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-acquire callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_ACQUIRE_CALLBACKS}} => $code;
  }
  
  sub add_context_init_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-init callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_INIT_CALLBACKS}} => $code;
  }
  
  sub add_context_release_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-release callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_RELEASE_CALLBACKS}} => $code;
  }
  
  sub add_post_load_callback {
      my $self = shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Post-load callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+POST_LOAD_CALLBACKS}} => $code;
      $code->() if $self->{+LOADED};
  }
  
  sub add_pre_subtest_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Pre-subtest callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+PRE_SUBTEST_CALLBACKS}} => $code;
  }
  
  sub load {
      my $self = shift;
      unless ($self->{+LOADED}) {
          confess "Attempt to initialize Test2::API during preload"
              if $self->{+PRELOAD};
  
          $self->{+_PID} = $$        unless defined $self->{+_PID};
          $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
          # This is for https://github.com/Test-More/test-more/issues/16
          # and https://rt.perl.org/Public/Bug/Display.html?id=127774
          # END blocks run in reverse order. This insures the END block is loaded
          # as late as possible. It will not solve all cases, but it helps.
          eval "END { Test2::API::test2_set_is_end() }; 1" or die $@;
  
          $self->{+LOADED} = 1;
          $_->() for @{$self->{+POST_LOAD_CALLBACKS}};
      }
      return $self->{+LOADED};
  }
  
  sub add_exit_callback {
      my $self = shift;
      my ($code) = @_;
      my $rtype = reftype($code) || "";
  
      confess "End callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+EXIT_CALLBACKS}} => $code;
  }
  
  sub ipc_disable {
      my $self = shift;
  
      confess "Attempt to disable IPC after it has been initialized"
          if $self->{+IPC};
  
      $self->{+IPC_DISABLED} = 1;
  }
  
  sub add_ipc_driver {
      my $self = shift;
      my ($driver) = @_;
      unshift @{$self->{+IPC_DRIVERS}} => $driver;
  
      return unless $self->{+FINALIZED};
  
      # Why is the @CARP_NOT entry not enough?
      local %Carp::Internal = %Carp::Internal;
      $Carp::Internal{'Test2::IPC::Driver'} = 1;
  
      carp "IPC driver $driver loaded too late to be used as the global ipc driver";
  }
  
  sub enable_ipc_polling {
      my $self = shift;
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      $self->add_context_init_callback(
          # This is called every time a context is created, it needs to be fast.
          # $_[0] is a context object
          sub {
              return unless $self->{+IPC_POLLING};
              return $_[0]->{hub}->cull unless $self->{+IPC_SHM_ID};
  
              my $val;
              if(shmread($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE})) {
                  return if $val eq $self->{+IPC_SHM_LAST};
                  $self->{+IPC_SHM_LAST} = $val;
              }
              else {
                  warn "SHM Read error: $!\n";
              }
  
              $_[0]->{hub}->cull;
          }
      ) unless defined $self->ipc_polling;
  
      $self->set_ipc_polling(1);
  }
  
  sub ipc_enable_shm {
      my $self = shift;
  
      return 1 if defined $self->{+IPC_SHM_ID};
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      my ($ok, $err) = try {
          # SysV IPC can be available but not enabled.
          #
          # In some systems (*BSD) accessing the SysV IPC APIs without
          # them being enabled can cause a SIGSYS.  We suppress the SIGSYS
          # and then get ENOSYS from the calls.
          local $SIG{SYS} = 'IGNORE' if CAN_SIGSYS;
  
          require IPC::SysV;
  
          my $ipc_key = IPC::SysV::IPC_PRIVATE();
          my $shm_size = $self->{+IPC}->can('shm_size') ? $self->{+IPC}->shm_size : 64;
          my $shm_id = shmget($ipc_key, $shm_size, 0666) or die "Could not get shm: $!";
  
          my $initial = 'a' x $shm_size;
          shmwrite($shm_id, $initial, 0, $shm_size) or die "Could not write to shm: $!";
          my $val;
          shmread($shm_id, $val, 0, $shm_size) or die "Could not read from shm: $!";
          die "Read SHM value does not match the initial value ('$val' vs '$initial')"
              unless $val eq $initial;
  
          $self->{+IPC_SHM_SIZE} = $shm_size;
          $self->{+IPC_SHM_ID}   = $shm_id;
          $self->{+IPC_SHM_LAST} = $initial;
      };
  
      return $ok;
  }
  
  sub ipc_free_shm {
      my $self = shift;
  
      my $id = delete $self->{+IPC_SHM_ID};
      return unless defined $id;
  
      shmctl($id, IPC::SysV::IPC_RMID(), 0);
  }
  
  sub get_ipc_pending {
      my $self = shift;
      return -1 unless defined $self->{+IPC_SHM_ID};
      my $val;
      shmread($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE}) or return -1;
      return 0 if $val eq $self->{+IPC_SHM_LAST};
      $self->{+IPC_SHM_LAST} = $val;
      return 1;
  }
  
  sub set_ipc_pending {
      my $self = shift;
  
      return undef unless defined $self->{+IPC_SHM_ID};
  
      my ($val) = @_;
  
      confess "value is required for set_ipc_pending"
          unless $val;
  
      shmwrite($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE});
  }
  
  sub disable_ipc_polling {
      my $self = shift;
      return unless defined $self->{+IPC_POLLING};
      $self->{+IPC_POLLING} = 0;
  }
  
  sub _ipc_wait {
      my ($timeout) = @_;
      my $fail = 0;
  
      $timeout = DEFAULT_IPC_TIMEOUT() unless defined $timeout;
  
      my $ok = eval {
          if (CAN_FORK) {
              local $SIG{ALRM} = sub { die "Timeout waiting on child processes" };
              alarm $timeout;
  
              while (1) {
                  my $pid = CORE::wait();
                  my $err = $?;
                  last if $pid == -1;
                  next unless $err;
                  $fail++;
  
                  my $sig = $err & 127;
                  my $exit = $err >> 8;
                  warn "Process $pid did not exit cleanly (wstat: $err, exit: $exit, sig: $sig)\n";
              }
  
              alarm 0;
          }
  
          if (USE_THREADS) {
              my $start = time;
  
              while (1) {
                  last unless threads->list();
                  die "Timeout waiting on child thread" if time - $start >= $timeout;
                  sleep 1;
                  for my $t (threads->list) {
                      # threads older than 1.34 do not have this :-(
                      next if $t->can('is_joinable') && !$t->is_joinable;
                      $t->join;
                      # In older threads we cannot check if a thread had an error unless
                      # we control it and its return.
                      my $err = $t->can('error') ? $t->error : undef;
                      next unless $err;
                      my $tid = $t->tid();
                      $fail++;
                      chomp($err);
                      warn "Thread $tid did not end cleanly: $err\n";
                  }
              }
          }
  
          1;
      };
      my $error = $@;
  
      return 0 if $ok && !$fail;
      warn $error unless $ok;
      return 255;
  }
  
  sub DESTROY {
      my $self = shift;
  
      return if $self->{+PRELOAD};
  
      return unless defined($self->{+_PID}) && $self->{+_PID} == $$;
      return unless defined($self->{+_TID}) && $self->{+_TID} == get_tid();
  
      shmctl($self->{+IPC_SHM_ID}, IPC::SysV::IPC_RMID(), 0)
          if defined $self->{+IPC_SHM_ID};
  }
  
  sub set_exit {
      my $self = shift;
  
      return if $self->{+PRELOAD};
  
      my $exit     = $?;
      my $new_exit = $exit;
  
      if ($INC{'Test/Builder.pm'} && $Test::Builder::VERSION ne $Test2::API::VERSION) {
          print STDERR <<"        EOT";
  
  ********************************************************************************
  *                                                                              *
  *            Test::Builder -- Test2::API version mismatch detected             *
  *                                                                              *
  ********************************************************************************
     Test2::API Version: $Test2::API::VERSION
  Test::Builder Version: $Test::Builder::VERSION
  
  This is not a supported configuration, you will have problems.
  
          EOT
      }
  
      for my $ctx (values %{$self->{+CONTEXTS}}) {
          next unless $ctx;
  
          next if $ctx->_aborted && ${$ctx->_aborted};
  
          # Only worry about contexts in this PID
          my $trace = $ctx->trace || next;
          next unless $trace->pid && $trace->pid == $$;
  
          # Do not worry about contexts that have no hub
          my $hub = $ctx->hub  || next;
  
          # Do not worry if the state came to a sudden end.
          next if $hub->bailed_out;
          next if defined $hub->skip_reason;
  
          # now we worry
          $trace->alert("context object was never released! This means a testing tool is behaving very badly");
  
          $exit     = 255;
          $new_exit = 255;
      }
  
      if (!defined($self->{+_PID}) or !defined($self->{+_TID}) or $self->{+_PID} != $$ or $self->{+_TID} != get_tid()) {
          $? = $exit;
          return;
      }
  
      my @hubs = $self->{+STACK} ? $self->{+STACK}->all : ();
  
      if (@hubs and $self->{+IPC} and !$self->{+NO_WAIT}) {
          local $?;
          my %seen;
          for my $hub (reverse @hubs) {
              my $ipc = $hub->ipc or next;
              next if $seen{$ipc}++;
              $ipc->waiting();
          }
  
          my $ipc_exit = _ipc_wait($self->{+IPC_TIMEOUT});
          $new_exit ||= $ipc_exit;
      }
  
      # None of this is necessary if we never got a root hub
      if(my $root = shift @hubs) {
          my $trace = Test2::EventFacet::Trace->new(
              frame  => [__PACKAGE__, __FILE__, 0, __PACKAGE__ . '::END'],
              detail => __PACKAGE__ . ' END Block finalization',
          );
          my $ctx = Test2::API::Context->new(
              trace => $trace,
              hub   => $root,
          );
  
          if (@hubs) {
              $ctx->diag("Test ended with extra hubs on the stack!");
              $new_exit  = 255;
          }
  
          unless ($root->no_ending) {
              local $?;
              $root->finalize($trace) unless $root->ended;
              $_->($ctx, $exit, \$new_exit) for @{$self->{+EXIT_CALLBACKS}};
              $new_exit ||= $root->failed;
              $new_exit ||= 255 unless $root->is_passing;
          }
      }
  
      $new_exit = 255 if $new_exit > 255;
  
      if ($new_exit && eval { require Test2::API::Breakage; 1 }) {
          my @warn = Test2::API::Breakage->report();
  
          if (@warn) {
              print STDERR "\nYou have loaded versions of test modules known to have problems with Test2.\nThis could explain some test failures.\n";
              print STDERR "$_\n" for @warn;
              print STDERR "\n";
          }
      }
  
      $? = $new_exit;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Instance - Object used by Test2::API under the hood
  
  =head1 DESCRIPTION
  
  This object encapsulates the global shared state tracked by
  L<Test2>. A single global instance of this package is stored (and
  obscured) by the L<Test2::API> package.
  
  There is no reason to directly use this package. This package is documented for
  completeness. This package can change, or go away completely at any time.
  Directly using, or monkeypatching this package is not supported in any way
  shape or form.
  
  =head1 SYNOPSIS
  
      use Test2::API::Instance;
  
      my $obj = Test2::API::Instance->new;
  
  =over 4
  
  =item $pid = $obj->pid
  
  PID of this instance.
  
  =item $obj->tid
  
  Thread ID of this instance.
  
  =item $obj->reset()
  
  Reset the object to defaults.
  
  =item $obj->load()
  
  Set the internal state to loaded, and run and stored post-load callbacks.
  
  =item $bool = $obj->loaded
  
  Check if the state is set to loaded.
  
  =item $arrayref = $obj->post_load_callbacks
  
  Get the post-load callbacks.
  
  =item $obj->add_post_load_callback(sub { ... })
  
  Add a post-load callback. If C<load()> has already been called then the callback will
  be immediately executed. If C<load()> has not been called then the callback will be
  stored and executed later when C<load()> is called.
  
  =item $hashref = $obj->contexts()
  
  Get a hashref of all active contexts keyed by hub id.
  
  =item $arrayref = $obj->context_acquire_callbacks
  
  Get all context acquire callbacks.
  
  =item $arrayref = $obj->context_init_callbacks
  
  Get all context init callbacks.
  
  =item $arrayref = $obj->context_release_callbacks
  
  Get all context release callbacks.
  
  =item $arrayref = $obj->pre_subtest_callbacks
  
  Get all pre-subtest callbacks.
  
  =item $obj->add_context_init_callback(sub { ... })
  
  Add a context init callback. Subs are called every time a context is created. Subs
  get the newly created context as their only argument.
  
  =item $obj->add_context_release_callback(sub { ... })
  
  Add a context release callback. Subs are called every time a context is released. Subs
  get the released context as their only argument. These callbacks should not
  call release on the context.
  
  =item $obj->add_pre_subtest_callback(sub { ... })
  
  Add a pre-subtest callback. Subs are called every time a subtest is
  going to be run. Subs get the subtest name, coderef, and any
  arguments.
  
  =item $obj->set_exit()
  
  This is intended to be called in an C<END { ... }> block. This will look at
  test state and set $?. This will also call any end callbacks, and wait on child
  processes/threads.
  
  =item $obj->ipc_enable_shm()
  
  Turn on SHM for IPC (if possible)
  
  =item $shm_id = $obj->ipc_shm_id()
  
  If SHM is enabled for IPC this will be the shm_id for it.
  
  =item $shm_size = $obj->ipc_shm_size()
  
  If SHM is enabled for IPC this will be the size of it.
  
  =item $shm_last_val = $obj->ipc_shm_last()
  
  If SHM is enabled for IPC this will return the last SHM value seen.
  
  =item $obj->set_ipc_pending($val)
  
  use the IPC SHM to tell other processes and threads there is a pending event.
  C<$val> should be a unique value no other thread/process will generate.
  
  B<Note:> This will also make the current process see a pending event. It does
  not set C<ipc_shm_last()>, this is important because doing so could hide a
  previous change.
  
  =item $pending = $obj->get_ipc_pending()
  
  This returns -1 if SHM is not enabled for IPC.
  
  This returns 0 if the SHM value matches the last known value, which means there
  are no pending events.
  
  This returns 1 if the SHM value has changed, which means there are probably
  pending events.
  
  When 1 is returned this will set C<< $obj->ipc_shm_last() >>.
  
  =item $timeout = $obj->ipc_timeout;
  
  =item $obj->set_ipc_timeout($timeout);
  
  How long to wait for child processes and threads before aborting.
  
  =item $drivers = $obj->ipc_drivers
  
  Get the list of IPC drivers.
  
  =item $obj->add_ipc_driver($DRIVER_CLASS)
  
  Add an IPC driver to the list. The most recently added IPC driver will become
  the global one during initialization. If a driver is added after initialization
  has occurred a warning will be generated:
  
      "IPC driver $driver loaded too late to be used as the global ipc driver"
  
  =item $bool = $obj->ipc_polling
  
  Check if polling is enabled.
  
  =item $obj->enable_ipc_polling
  
  Turn on polling. This will cull events from other processes and threads every
  time a context is created.
  
  =item $obj->disable_ipc_polling
  
  Turn off IPC polling.
  
  =item $bool = $obj->no_wait
  
  =item $bool = $obj->set_no_wait($bool)
  
  Get/Set no_wait. This option is used to turn off process/thread waiting at exit.
  
  =item $arrayref = $obj->exit_callbacks
  
  Get the exit callbacks.
  
  =item $obj->add_exit_callback(sub { ... })
  
  Add an exit callback. This callback will be called by C<set_exit()>.
  
  =item $bool = $obj->finalized
  
  Check if the object is finalized. Finalization happens when either C<ipc()>,
  C<stack()>, or C<format()> are called on the object. Once finalization happens
  these fields are considered unchangeable (not enforced here, enforced by
  L<Test2>).
  
  =item $ipc = $obj->ipc
  
  Get the one true IPC instance.
  
  =item $obj->ipc_disable
  
  Turn IPC off
  
  =item $bool = $obj->ipc_disabled
  
  Check if IPC is disabled
  
  =item $stack = $obj->stack
  
  Get the one true hub stack.
  
  =item $formatter = $obj->formatter
  
  Get the global formatter. By default this is the C<'Test2::Formatter::TAP'>
  package. This could be any package that implements the C<write()> method. This
  can also be an instantiated object.
  
  =item $bool = $obj->formatter_set()
  
  Check if a formatter has been set.
  
  =item $obj->add_formatter($class)
  
  =item $obj->add_formatter($obj)
  
  Add a formatter. The most recently added formatter will become the global one
  during initialization. If a formatter is added after initialization has occurred
  a warning will be generated:
  
      "Formatter $formatter loaded too late to be used as the global formatter"
  
  =item $obj->set_add_uuid_via(sub { ... })
  
  =item $sub = $obj->add_uuid_via()
  
  This allows you to provide a UUID generator. If provided UUIDs will be attached
  to all events, hubs, and contexts. This is useful for storing, tracking, and
  linking these objects.
  
  The sub you provide should always return a unique identifier. Most things will
  expect a proper UUID string, however nothing in Test2::API enforces this.
  
  The sub will receive exactly 1 argument, the type of thing being tagged
  'context', 'hub', or 'event'. In the future additional things may be tagged, in
  which case new strings will be passed in. These are purely informative, you can
  (and usually should) ignore them.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_INSTANCE

$fatpacked{"Test2/API/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_STACK';
  package Test2::API::Stack;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::Hub();
  
  use Carp qw/confess/;
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub new_hub {
      my $self = shift;
      my %params = @_;
  
      my $class = delete $params{class} || 'Test2::Hub';
  
      my $hub = $class->new(%params);
  
      if (@$self) {
          $hub->inherit($self->[-1], %params);
      }
      else {
          require Test2::API;
          $hub->format(Test2::API::test2_formatter()->new_root)
              unless $hub->format || exists($params{formatter});
  
          my $ipc = Test2::API::test2_ipc();
          if ($ipc && !$hub->ipc && !exists($params{ipc})) {
              $hub->set_ipc($ipc);
              $ipc->add_hub($hub->hid);
          }
      }
  
      push @$self => $hub;
  
      $hub;
  }
  
  sub top {
      my $self = shift;
      return $self->new_hub unless @$self;
      return $self->[-1];
  }
  
  sub peek {
      my $self = shift;
      return @$self ? $self->[-1] : undef;
  }
  
  sub cull {
      my $self = shift;
      $_->cull for reverse @$self;
  }
  
  sub all {
      my $self = shift;
      return @$self;
  }
  
  sub clear {
      my $self = shift;
      @$self = ();
  }
  
  # Do these last without keywords in order to prevent them from getting used
  # when we want the real push/pop.
  
  {
      no warnings 'once';
  
      *push = sub {
          my $self = shift;
          my ($hub) = @_;
          $hub->inherit($self->[-1]) if @$self;
          push @$self => $hub;
      };
  
      *pop = sub {
          my $self = shift;
          my ($hub) = @_;
          confess "No hubs on the stack"
              unless @$self;
          confess "You cannot pop the root hub"
              if 1 == @$self;
          confess "Hub stack mismatch, attempted to pop incorrect hub"
              unless $self->[-1] == $hub;
          pop @$self;
      };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Stack - Object to manage a stack of L<Test2::Hub>
  instances.
  
  =head1 ***INTERNALS NOTE***
  
  B<The internals of this package are subject to change at any time!> The public
  methods provided will not change in backwards incompatible ways, but the
  underlying implementation details might. B<Do not break encapsulation here!>
  
  =head1 DESCRIPTION
  
  This module is used to represent and manage a stack of L<Test2::Hub>
  objects. Hubs are usually in a stack so that you can push a new hub into place
  that can intercept and handle events differently than the primary hub.
  
  =head1 SYNOPSIS
  
      my $stack = Test2::API::Stack->new;
      my $hub = $stack->top;
  
  =head1 METHODS
  
  =over 4
  
  =item $stack = Test2::API::Stack->new()
  
  This will create a new empty stack instance. All arguments are ignored.
  
  =item $hub = $stack->new_hub()
  
  =item $hub = $stack->new_hub(%params)
  
  =item $hub = $stack->new_hub(%params, class => $class)
  
  This will generate a new hub and push it to the top of the stack. Optionally
  you can provide arguments that will be passed into the constructor for the
  L<Test2::Hub> object.
  
  If you specify the C<< 'class' => $class >> argument, the new hub will be an
  instance of the specified class.
  
  Unless your parameters specify C<'formatter'> or C<'ipc'> arguments, the
  formatter and IPC instance will be inherited from the current top hub. You can
  set the parameters to C<undef> to avoid having a formatter or IPC instance.
  
  If there is no top hub, and you do not ask to leave IPC and formatter undef,
  then a new formatter will be created, and the IPC instance from
  L<Test2::API> will be used.
  
  =item $hub = $stack->top()
  
  This will return the top hub from the stack. If there is no top hub yet this
  will create it.
  
  =item $hub = $stack->peek()
  
  This will return the top hub from the stack. If there is no top hub yet this
  will return undef.
  
  =item $stack->cull
  
  This will call C<< $hub->cull >> on all hubs in the stack.
  
  =item @hubs = $stack->all
  
  This will return all the hubs in the stack as a list.
  
  =item $stack->clear
  
  This will completely remove all hubs from the stack. Normally you do not want
  to do this, but there are a few valid reasons for it.
  
  =item $stack->push($hub)
  
  This will push the new hub onto the stack.
  
  =item $stack->pop($hub)
  
  This will pop a hub from the stack, if the hub at the top of the stack does not
  match the hub you expect (passed in as an argument) it will throw an exception.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_STACK

$fatpacked{"Test2/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT';
  package Test2::Event;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Scalar::Util qw/blessed reftype/;
  use Carp qw/croak/;
  
  use Test2::Util::HashBase qw/trace -amnesty uuid -_eid -hubs/;
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util qw/pkg_to_file gen_uid/;
  
  use Test2::EventFacet::About();
  use Test2::EventFacet::Amnesty();
  use Test2::EventFacet::Assert();
  use Test2::EventFacet::Control();
  use Test2::EventFacet::Error();
  use Test2::EventFacet::Info();
  use Test2::EventFacet::Meta();
  use Test2::EventFacet::Parent();
  use Test2::EventFacet::Plan();
  use Test2::EventFacet::Trace();
  use Test2::EventFacet::Hub();
  
  # Legacy tools will expect this to be loaded now
  require Test2::Util::Trace;
  
  my %LOADED_FACETS = (
      'about'   => 'Test2::EventFacet::About',
      'amnesty' => 'Test2::EventFacet::Amnesty',
      'assert'  => 'Test2::EventFacet::Assert',
      'control' => 'Test2::EventFacet::Control',
      'errors'  => 'Test2::EventFacet::Error',
      'info'    => 'Test2::EventFacet::Info',
      'meta'    => 'Test2::EventFacet::Meta',
      'parent'  => 'Test2::EventFacet::Parent',
      'plan'    => 'Test2::EventFacet::Plan',
      'trace'   => 'Test2::EventFacet::Trace',
      'hubs'    => 'Test2::EventFacet::Hub',
  );
  
  sub FACET_TYPES { sort values %LOADED_FACETS }
  
  sub load_facet {
      my $class = shift;
      my ($facet) = @_;
  
      return $LOADED_FACETS{$facet} if exists $LOADED_FACETS{$facet};
  
      my @check = ($facet);
      if ('s' eq substr($facet, -1, 1)) {
          push @check => substr($facet, 0, -1);
      }
      else {
          push @check => $facet . 's';
      }
  
      my $found;
      for my $check (@check) {
          my $mod  = "Test2::EventFacet::" . ucfirst($facet);
          my $file = pkg_to_file($mod);
          next unless eval { require $file; 1 };
          $found = $mod;
          last;
      }
  
      return undef unless $found;
      $LOADED_FACETS{$facet} = $found;
  }
  
  sub causes_fail      { 0 }
  sub increments_count { 0 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  
  sub callback { }
  
  sub terminate { () }
  sub global    { () }
  sub sets_plan { () }
  
  sub summary { ref($_[0]) }
  
  sub related {
      my $self = shift;
      my ($event) = @_;
  
      my $tracea = $self->trace  or return undef;
      my $traceb = $event->trace or return undef;
  
      my $uuida = $tracea->uuid;
      my $uuidb = $traceb->uuid;
      if ($uuida && $uuidb) {
          return 1 if $uuida eq $uuidb;
          return 0;
      }
  
      my $siga = $tracea->signature or return undef;
      my $sigb = $traceb->signature or return undef;
  
      return 1 if $siga eq $sigb;
      return 0;
  }
  
  sub add_hub {
      my $self = shift;
      unshift @{$self->{+HUBS}} => @_;
  }
  
  sub add_amnesty {
      my $self = shift;
  
      for my $am (@_) {
          $am = {%$am} if ref($am) ne 'ARRAY';
          $am = Test2::EventFacet::Amnesty->new($am);
  
          push @{$self->{+AMNESTY}} => $am;
      }
  }
  
  sub eid { $_[0]->{+_EID} ||= gen_uid() }
  
  sub common_facet_data {
      my $self = shift;
  
      my %out;
  
      $out{about} = {package => ref($self) || undef};
      if (my $uuid = $self->uuid) {
          $out{about}->{uuid} = $uuid;
      }
  
      $out{about}->{eid} = $self->{+_EID} || $self->eid;
  
      if (my $trace = $self->trace) {
          $out{trace} = { %$trace };
      }
  
      if (my $hubs = $self->hubs) {
          $out{hubs} = $hubs;
      }
  
      $out{amnesty} = [map {{ %{$_} }} @{$self->{+AMNESTY}}]
          if $self->{+AMNESTY};
  
      if (my $meta = $self->meta_facet_data) {
          $out{meta} = $meta;
      }
  
      return \%out;
  }
  
  sub meta_facet_data {
      my $self = shift;
  
      my $key = Test2::Util::ExternalMeta::META_KEY();
  
      my $hash = $self->{$key} or return undef;
      return {%$hash};
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details}    = $self->summary    || undef;
      $out->{about}->{no_display} = $self->no_display || undef;
  
      # Might be undef, we want to preserve that
      my $terminate = $self->terminate;
      $out->{control} = {
          global    => $self->global    || 0,
          terminate => $terminate,
          has_callback => $self->can('callback') == \&callback ? 0 : 1,
      };
  
      $out->{assert} = {
          no_debug => 1,                     # Legacy behavior
          pass     => $self->causes_fail ? 0 : 1,
          details  => $self->summary,
      } if $self->increments_count;
  
      $out->{parent} = {hid => $self->subtest_id} if $self->subtest_id;
  
      if (my @plan = $self->sets_plan) {
          $out->{plan} = {};
  
          $out->{plan}->{count}   = $plan[0] if defined $plan[0];
          $out->{plan}->{details} = $plan[2] if defined $plan[2];
  
          if ($plan[1]) {
              $out->{plan}->{skip} = 1 if $plan[1] eq 'SKIP';
              $out->{plan}->{none} = 1 if $plan[1] eq 'NO PLAN';
          }
  
          $out->{control}->{terminate} ||= 0 if $out->{plan}->{skip};
      }
  
      if ($self->causes_fail && !$out->{assert}) {
          $out->{errors} = [
              {
                  tag     => 'FAIL',
                  fail    => 1,
                  details => $self->summary,
              }
          ];
      }
  
      my %IGNORE = (trace => 1, about => 1, control => 1);
      my $do_info = !grep { !$IGNORE{$_} } keys %$out;
  
      if ($do_info && !$self->no_display && $self->diagnostics) {
          $out->{info} = [
              {
                  tag     => 'DIAG',
                  debug   => 1,
                  details => $self->summary,
              }
          ];
      }
  
      return $out;
  }
  
  sub facets {
      my $self = shift;
      my %out;
  
      my $data = $self->facet_data;
      my @errors = $self->validate_facet_data($data);
      die join "\n" => @errors if @errors;
  
      for my $facet (keys %$data) {
          my $class = $self->load_facet($facet);
          my $val = $data->{$facet};
  
          unless($class) {
              $out{$facet} = $val;
              next;
          }
  
          my $is_list = reftype($val) eq 'ARRAY' ? 1 : 0;
          if ($is_list) {
              $out{$facet} = [map { $class->new($_) } @$val];
          }
          else {
              $out{$facet} = $class->new($val);
          }
      }
  
      return \%out;
  }
  
  sub validate_facet_data {
      my $class_or_self = shift;
      my ($f, %params);
  
      $f = shift if @_ && (reftype($_[0]) || '') eq 'HASH';
      %params = @_;
  
      $f ||= $class_or_self->facet_data if blessed($class_or_self);
      croak "No facet data" unless $f;
  
      my @errors;
  
      for my $k (sort keys %$f) {
          my $fclass = $class_or_self->load_facet($k);
  
          push @errors => "Could not find a facet class for facet '$k'"
              if $params{require_facet_class} && !$fclass;
  
          next unless $fclass;
  
          my $v = $f->{$k};
          next unless defined($v); # undef is always fine
  
          my $is_list = $fclass->is_list();
          my $got_list = reftype($v) eq 'ARRAY' ? 1 : 0;
  
          push @errors => "Facet '$k' should be a list, but got a single item ($v)"
              if $is_list && !$got_list;
  
          push @errors => "Facet '$k' should not be a list, but got a a list ($v)"
              if $got_list && !$is_list;
      }
  
      return @errors;
  }
  
  sub nested {
      my $self = shift;
  
      Carp::cluck("Use of Test2::Event->nested() is deprecated, use Test2::Event->trace->nested instead")
          if $ENV{AUTHOR_TESTING};
  
      if (my $hubs = $self->{+HUBS}) {
          return $hubs->[0]->{nested} if @$hubs;
      }
  
      my $trace = $self->{+TRACE} or return undef;
      return $trace->{nested};
  }
  
  sub in_subtest {
      my $self = shift;
  
      Carp::cluck("Use of Test2::Event->in_subtest() is deprecated, use Test2::Event->trace->hid instead")
          if $ENV{AUTHOR_TESTING};
  
      my $hubs = $self->{+HUBS};
      if ($hubs && @$hubs) {
          return undef unless $hubs->[0]->{nested};
          return $hubs->[0]->{hid}
      }
  
      my $trace = $self->{+TRACE} or return undef;
      return undef unless $trace->{nested};
      return $trace->{hid};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event - Base class for events
  
  =head1 DESCRIPTION
  
  Base class for all event objects that get passed through
  L<Test2>.
  
  =head1 SYNOPSIS
  
      package Test2::Event::MyEvent;
      use strict;
      use warnings;
  
      # This will make our class an event subclass (required)
      use base 'Test2::Event';
  
      # Add some accessors (optional)
      # You are not obligated to use HashBase, you can use any object tool you
      # want, or roll your own accessors.
      use Test2::Util::HashBase qw/foo bar baz/;
  
      # Use this if you want the legacy API to be written for you, for this to
      # work you will need to implement a facet_data() method.
      use Test2::Util::Facets2Legacy;
  
      # Chance to initialize some defaults
      sub init {
          my $self = shift;
          # no other args in @_
  
          $self->set_foo('xxx') unless defined $self->foo;
  
          ...
      }
  
      # This is the new way for events to convey data to the Test2 system
      sub facet_data {
          my $self = shift;
  
          # Get common facets such as 'about', 'trace' 'amnesty', and 'meta'
          my $facet_data = $self->common_facet_data();
  
          # Are you making an assertion?
          $facet_data->{assert} = {pass => 1, details => 'my assertion'};
          ...
  
          return $facet_data;
      }
  
      1;
  
  =head1 METHODS
  
  =head2 GENERAL
  
  =over 4
  
  =item $trace = $e->trace
  
  Get a snapshot of the L<Test2::EventFacet::Trace> as it was when this event was
  generated
  
  =item $bool_or_undef = $e->related($e2)
  
  Check if 2 events are related. In this case related means their traces share a
  signature meaning they were created with the same context (or at the very least
  by contexts which share an id, which is the same thing unless someone is doing
  something very bad).
  
  This can be used to reliably link multiple events created by the same tool. For
  instance a failing test like C<ok(0, "fail"> will generate 2 events, one being
  a L<Test2::Event::Ok>, the other being a L<Test2::Event::Diag>, both of these
  events are related having been created under the same context and by the same
  initial tool (though multiple tools may have been nested under the initial
  one).
  
  This will return C<undef> if the relationship cannot be checked, which happens
  if either event has an incomplete or missing trace. This will return C<0> if
  the traces are complete, but do not match. C<1> will be returned if there is a
  match.
  
  =item $e->add_amnesty({tag => $TAG, details => $DETAILS});
  
  This can be used to add amnesty to this event. Amnesty only effects failing
  assertions in most cases, but some formatters may display them for passing
  assertions, or even non-assertions as well.
  
  Amnesty will prevent a failed assertion from causing the overall test to fail.
  In other words it marks a failure as expected and allowed.
  
  B<Note:> This is how 'TODO' is implemented under the hood. TODO is essentially
  amnesty with the 'TODO' tag. The details are the reason for the TODO.
  
  =item $uuid = $e->uuid
  
  If UUID tagging is enabled (See L<Test::API>) then any event that has made its
  way through a hub will be tagged with a UUID. A newly created event will not
  yet be tagged in most cases.
  
  =item $class = $e->load_facet($name)
  
  This method is used to load a facet by name (or key). It will attempt to load
  the facet class, if it succeeds it will return the class it loaded. If it fails
  it will return C<undef>. This caches the result at the class level so that
  future calls will be faster.
  
  The C<$name> variable should be the key used to access the facet in a facets
  hashref. For instance the assertion facet has the key 'assert', the information
  facet has the 'info' key, and the error facet has the key 'errors'. You may
  include or omit the 's' at the end of the name, the method is smart enough to
  try both the 's' and no-'s' forms, it will check what you provided first, and
  if that is not found it will add or strip the 's and try again.
  
  =item @classes = $e->FACET_TYPES()
  
  =item @classes = Test2::Event->FACET_TYPES()
  
  This returns a list of all facets that have been loaded using the
  C<load_facet()> method. This will not return any classes that have not been
  loaded, or have been loaded directly without a call to C<load_facet()>.
  
  B<Note:> The core facet types are automatically loaded and populated in this
  list.
  
  =back
  
  =head2 NEW API
  
  =over 4
  
  =item $hashref = $e->common_facet_data();
  
  This can be used by subclasses to generate a starting facet data hashref. This
  will populate the hashref with the trace, meta, amnesty, and about facets.
  These facets are nearly always produced the same way for all events.
  
  =item $hashref = $e->facet_data()
  
  If you do not override this then the default implementation will attempt to
  generate facets from the legacy API. This generation is limited only to what
  the legacy API can provide. It is recommended that you override this method and
  write out explicit facet data.
  
  =item $hashref = $e->facets()
  
  This takes the hashref from C<facet_data()> and blesses each facet into the
  proper C<Test2::EventFacet::*> subclass. If no class can be found for any given
  facet it will be passed along unchanged.
  
  =item @errors = $e->validate_facet_data();
  
  =item @errors = $e->validate_facet_data(%params);
  
  =item @errors = $e->validate_facet_data(\%facets, %params);
  
  =item @errors = Test2::Event->validate_facet_data(%params);
  
  =item @errors = Test2::Event->validate_facet_data(\%facets, %params);
  
  This method will validate facet data and return a list of errors. If no errors
  are found this will return an empty list.
  
  This can be called as an object method with no arguments, in which case the
  C<facet_data()> method will be called to get the facet data to be validated.
  
  When used as an object method the C<\%facet_data> argument may be omitted.
  
  When used as a class method the C<\%facet_data> argument is required.
  
  Remaining arguments will be slurped into a C<%params> hash.
  
  Currently only 1 parameter is defined:
  
  =over 4
  
  =item require_facet_class => $BOOL
  
  When set to true (default is false) this will reject any facets where a facet
  class cannot be found. Normally facets without classes are assumed to be custom
  and are ignored.
  
  =back
  
  =back
  
  =head3 WHAT ARE FACETS?
  
  Facets are how events convey their purpose to the Test2 internals and
  formatters. An event without facets will have no intentional effect on the
  overall test state, and will not be displayed at all by most formatters, except
  perhaps to say that an event of an unknown type was seen.
  
  Facets are produced by the C<facet_data()> subroutine, which you should
  nearly-always override. C<facet_data()> is expected to return a hashref where
  each key is the facet type, and the value is either a hashref with the data for
  that facet, or an array of hashref's. Some facets must be defined as single
  hashrefs, some must be defined as an array of hashrefs, No facets allow both.
  
  C<facet_data()> B<MUST NOT> bless the data it returns, the main hashref, and
  nested facet hashref's B<MUST> be bare, though items contained within each
  facet may be blessed. The data returned by this method B<should> also be copies
  of the internal data in order to prevent accidental state modification.
  
  C<facets()> takes the data from C<facet_data()> and blesses it into the
  C<Test2::EventFacet::*> packages. This is rarely used however, the EventFacet
  packages are primarily for convenience and documentation. The EventFacet
  classes are not used at all internally, instead the raw data is used.
  
  Here is a list of facet types by package. The packages are not used internally,
  but are where the documentation for each type is kept.
  
  B<Note:> Every single facet type has the C<'details'> field. This field is
  always intended for human consumption, and when provided, should explain the
  'why' for the facet. All other fields are facet specific.
  
  =over 4
  
  =item about => {...}
  
  L<Test2::EventFacet::About>
  
  This contains information about the event itself such as the event package
  name. The C<details> field for this facet is an overall summary of the event.
  
  =item assert => {...}
  
  L<Test2::EventFacet::Assert>
  
  This facet is used if an assertion was made. The C<details> field of this facet
  is the description of the assertion.
  
  =item control => {...}
  
  L<Test2::EventFacet::Control>
  
  This facet is used to tell the L<Test2::Event::Hub> about special actions the
  event causes. Things like halting all testing, terminating the current test,
  etc. In this facet the C<details> field explains why any special action was
  taken.
  
  B<Note:> This is how bail-out is implemented.
  
  =item meta => {...}
  
  L<Test2::EventFacet::Meta>
  
  The meta facet contains all the meta-data attached to the event. In this case
  the C<details> field has no special meaning, but may be present if something
  sets the 'details' meta-key on the event.
  
  =item parent => {...}
  
  L<Test2::EventFacet::Parent>
  
  This facet contains nested events and similar details for subtests. In this
  facet the C<details> field will typically be the name of the subtest.
  
  =item plan => {...}
  
  L<Test2::EventFacet::Plan>
  
  This facet tells the system that a plan has been set. The C<details> field of
  this is usually left empty, but when present explains why the plan is what it
  is, this is most useful if the plan is to skip-all.
  
  =item trace => {...}
  
  L<Test2::EventFacet::Trace>
  
  This facet contains information related to when and where the event was
  generated. This is how the test file and line number of a failure is known.
  This facet can also help you to tell if tests are related.
  
  In this facet the C<details> field overrides the "failed at test_file.t line
  42." message provided on assertion failure.
  
  =item amnesty => [{...}, ...]
  
  L<Test2::EventFacet::Amnesty>
  
  The amnesty facet is a list instead of a single item, this is important as
  amnesty can come from multiple places at once.
  
  For each instance of amnesty the C<details> field explains why amnesty was
  granted.
  
  B<Note:> Outside of formatters amnesty only acts to forgive a failing
  assertion.
  
  =item errors => [{...}, ...]
  
  L<Test2::EventFacet::Error>
  
  The errors facet is a list instead of a single item, any number of errors can
  be listed. In this facet C<details> describes the error, or may contain the raw
  error message itself (such as an exception). In perl exception may be blessed
  objects, as such the raw data for this facet may contain nested items which are
  blessed.
  
  Not all errors are considered fatal, there is a C<fail> field that must be set
  for an error to cause the test to fail.
  
  B<Note:> This facet is unique in that the field name is 'errors' while the
  package is 'Error'. This is because this is the only facet type that is both a
  list, and has a name where the plural is not the same as the singular. This may
  cause some confusion, but I feel it will be less confusing than the
  alternative.
  
  =item info => [{...}, ...]
  
  L<Test2::EventFacet::Info>
  
  The 'info' facet is a list instead of a single item, any quantity of extra
  information can be attached to an event. Some information may be critical
  diagnostics, others may be simply commentary in nature, this is determined by
  the C<debug> flag.
  
  For this facet the C<details> flag is the info itself. This info may be a
  string, or it may be a data structure to display. This is one of the few facet
  types that may contain blessed items.
  
  =back
  
  =head2 LEGACY API
  
  =over 4
  
  =item $bool = $e->causes_fail
  
  Returns true if this event should result in a test failure. In general this
  should be false.
  
  =item $bool = $e->increments_count
  
  Should be true if this event should result in a test count increment.
  
  =item $e->callback($hub)
  
  If your event needs to have extra effects on the L<Test2::Hub> you can override
  this method.
  
  This is called B<BEFORE> your event is passed to the formatter.
  
  =item $num = $e->nested
  
  If this event is nested inside of other events, this should be the depth of
  nesting. (This is mainly for subtests)
  
  =item $bool = $e->global
  
  Set this to true if your event is global, that is ALL threads and processes
  should see it no matter when or where it is generated. This is not a common
  thing to want, it is used by bail-out and skip_all to end testing.
  
  =item $code = $e->terminate
  
  This is called B<AFTER> your event has been passed to the formatter. This
  should normally return undef, only change this if your event should cause the
  test to exit immediately.
  
  If you want this event to cause the test to exit you should return the exit
  code here. Exit code of 0 means exit success, any other integer means exit with
  failure.
  
  This is used by L<Test2::Event::Plan> to exit 0 when the plan is
  'skip_all'. This is also used by L<Test2::Event:Bail> to force the test
  to exit with a failure.
  
  This is called after the event has been sent to the formatter in order to
  ensure the event is seen and understood.
  
  =item $msg = $e->summary
  
  This is intended to be a human readable summary of the event. This should
  ideally only be one line long, but you can use multiple lines if necessary. This
  is intended for human consumption. You do not need to make it easy for machines
  to understand.
  
  The default is to simply return the event package name.
  
  =item ($count, $directive, $reason) = $e->sets_plan()
  
  Check if this event sets the testing plan. It will return an empty list if it
  does not. If it does set the plan it will return a list of 1 to 3 items in
  order: Expected Test Count, Test Directive, Reason for directive.
  
  =item $bool = $e->diagnostics
  
  True if the event contains diagnostics info. This is useful because a
  non-verbose harness may choose to hide events that are not in this category.
  Some formatters may choose to send these to STDERR instead of STDOUT to ensure
  they are seen.
  
  =item $bool = $e->no_display
  
  False by default. This will return true on events that should not be displayed
  by formatters.
  
  =item $id = $e->in_subtest
  
  If the event is inside a subtest this should have the subtest ID.
  
  =item $id = $e->subtest_id
  
  If the event is a final subtest event, this should contain the subtest ID.
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT

$fatpacked{"Test2/Event/Bail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_BAIL';
  package Test2::Event::Bail;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{reason buffered};
  
  # Make sure the tests terminate
  sub terminate { 255 };
  
  sub global { 1 };
  
  sub causes_fail { 1 }
  
  sub summary {
      my $self = shift;
      return "Bail out!  " . $self->{+REASON}
          if $self->{+REASON};
  
      return "Bail out!";
  }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{control} = {
          global    => 1,
          halt      => 1,
          details   => $self->{+REASON},
          terminate => 255,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Bail - Bailout!
  
  =head1 DESCRIPTION
  
  The bailout event is generated when things go horribly wrong and you need to
  halt all testing in the current file.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Bail;
  
      my $ctx = context();
      my $event = $ctx->bail('Stuff is broken');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $reason = $e->reason
  
  The reason for the bailout.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_BAIL

$fatpacked{"Test2/Event/Diag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_DIAG';
  package Test2::Event::Diag;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/message/;
  
  sub init {
      $_[0]->{+MESSAGE} = 'undef' unless defined $_[0]->{+MESSAGE};
  }
  
  sub summary { $_[0]->{+MESSAGE} }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{info} = [
          {
              tag     => 'DIAG',
              debug   => 1,
              details => $self->{+MESSAGE},
          }
      ];
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Diag - Diag event type
  
  =head1 DESCRIPTION
  
  Diagnostics messages, typically rendered to STDERR.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Diag;
  
      my $ctx = context();
      my $event = $ctx->diag($message);
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $diag->message
  
  The message for the diag.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_DIAG

$fatpacked{"Test2/Event/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_ENCODING';
  package Test2::Event::Encoding;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/encoding/;
  
  sub init {
      my $self = shift;
      defined $self->{+ENCODING} or croak "'encoding' is a required attribute";
  }
  
  sub summary { 'Encoding set to ' . $_[0]->{+ENCODING} }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
      $out->{control}->{encoding} = $self->{+ENCODING};
      $out->{about}->{details} = $self->summary;
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Encoding - Set the encoding for the output stream
  
  =head1 DESCRIPTION
  
  The encoding event is generated when a test file wants to specify the encoding
  to be used when formatting its output. This event is intended to be produced
  by formatter classes and used for interpreting test names, message contents,
  etc.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Encoding;
  
      my $ctx = context();
      my $event = $ctx->send_event('Encoding', encoding => 'UTF-8');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $encoding = $e->encoding
  
  The encoding being specified.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_ENCODING

$fatpacked{"Test2/Event/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_EXCEPTION';
  package Test2::Event::Exception;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{error};
  
  sub init {
      my $self = shift;
      $self->{+ERROR} = "$self->{+ERROR}";
  }
  
  sub causes_fail { 1 }
  
  sub summary {
      my $self = shift;
      chomp(my $msg = "Exception: " . $self->{+ERROR});
      return $msg;
  }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{errors} = [
          {
              tag     => 'ERROR',
              fail    => 1,
              details => $self->{+ERROR},
          }
      ];
  
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Exception - Exception event
  
  =head1 DESCRIPTION
  
  An exception event will display to STDERR, and will prevent the overall test
  file from passing.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Exception;
  
      my $ctx = context();
      my $event = $ctx->send_event('Exception', error => 'Stuff is broken');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $reason = $e->error
  
  The reason for the exception.
  
  =back
  
  =head1 CAVEATS
  
  Be aware that all exceptions are stringified during construction.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_EXCEPTION

$fatpacked{"Test2/Event/Fail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_FAIL';
  package Test2::Event::Fail;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::EventFacet::Info;
  
  BEGIN {
      require Test2::Event;
      our @ISA = qw(Test2::Event);
      *META_KEY = \&Test2::Util::ExternalMeta::META_KEY;
  }
  
  use Test2::Util::HashBase qw{ -name -info };
  
  #############
  # Old API
  sub summary          { "fail" }
  sub increments_count { 1 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  sub terminate        { () }
  sub global           { () }
  sub sets_plan        { () }
  
  sub causes_fail {
      my $self = shift;
      return 0 if $self->{+AMNESTY} && @{$self->{+AMNESTY}};
      return 1;
  }
  
  #############
  # New API
  
  sub add_info {
      my $self = shift;
  
      for my $in (@_) {
          $in = {%$in} if ref($in) ne 'ARRAY';
          $in = Test2::EventFacet::Info->new($in);
  
          push @{$self->{+INFO}} => $in;
      }
  }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = 'fail';
  
      $out->{assert} = {pass => 0, details => $self->{+NAME}};
  
      $out->{info} = [map {{ %{$_} }} @{$self->{+INFO}}] if $self->{+INFO};
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Fail - Event for a simple failed assertion
  
  =head1 DESCRIPTION
  
  This is an optimal representation of a failed assertion.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub fail {
          my ($name) = @_;
          my $ctx = context();
          $ctx->fail($name);
          $ctx->release;
      }
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_FAIL

$fatpacked{"Test2/Event/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_GENERIC';
  package Test2::Event::Generic;
  use strict;
  use warnings;
  
  use Carp qw/croak/;
  use Scalar::Util qw/reftype/;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase;
  
  my @FIELDS = qw{
      causes_fail increments_count diagnostics no_display callback terminate
      global sets_plan summary facet_data
  };
  my %DEFAULTS = (
      causes_fail      => 0,
      increments_count => 0,
      diagnostics      => 0,
      no_display       => 0,
  );
  
  sub init {
      my $self = shift;
  
      for my $field (@FIELDS) {
          my $val = defined $self->{$field} ? delete $self->{$field} : $DEFAULTS{$field};
          next unless defined $val;
  
          my $set = "set_$field";
          $self->$set($val);
      }
  }
  
  for my $field (@FIELDS) {
      no strict 'refs';
  
      *$field = sub { exists $_[0]->{$field} ? $_[0]->{$field} : () }
          unless exists &{$field};
  
      *{"set_$field"} = sub { $_[0]->{$field} = $_[1] }
          unless exists &{"set_$field"};
  }
  
  sub can {
      my $self = shift;
      my ($name) = @_;
      return $self->SUPER::can($name) unless $name eq 'callback';
      return $self->{callback} || \&Test2::Event::callback;
  }
  
  sub facet_data {
      my $self = shift;
      return $self->{facet_data} || $self->SUPER::facet_data();
  }
  
  sub summary {
      my $self = shift;
      return $self->{summary} if defined $self->{summary};
      $self->SUPER::summary();
  }
  
  sub sets_plan {
      my $self = shift;
      return unless $self->{sets_plan};
      return @{$self->{sets_plan}};
  }
  
  sub callback {
      my $self = shift;
      my $cb = $self->{callback} || return;
      $self->$cb(@_);
  }
  
  sub set_global {
      my $self = shift;
      my ($bool) = @_;
  
      if(!defined $bool) {
          delete $self->{global};
          return undef;
      }
  
      $self->{global} = $bool;
  }
  
  sub set_callback {
      my $self = shift;
      my ($cb) = @_;
  
      if(!defined $cb) {
          delete $self->{callback};
          return undef;
      }
  
      croak "callback must be a code reference"
          unless ref($cb) && reftype($cb) eq 'CODE';
  
      $self->{callback} = $cb;
  }
  
  sub set_terminate {
      my $self = shift;
      my ($exit) = @_;
  
      if(!defined $exit) {
          delete $self->{terminate};
          return undef;
      }
  
      croak "terminate must be a positive integer"
         unless $exit =~ m/^\d+$/;
  
      $self->{terminate} = $exit;
  }
  
  sub set_sets_plan {
      my $self = shift;
      my ($plan) = @_;
  
      if(!defined $plan) {
          delete $self->{sets_plan};
          return undef;
      }
  
      croak "'sets_plan' must be an array reference"
          unless ref($plan) && reftype($plan) eq 'ARRAY';
  
      $self->{sets_plan} = $plan;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Generic - Generic event type.
  
  =head1 DESCRIPTION
  
  This is a generic event that lets you customize all fields in the event API.
  This is useful if you have need for a custom event that does not make sense as
  a published reusable event subclass.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub send_custom_fail {
          my $ctx = shift;
  
          $ctx->send_event('Generic', causes_fail => 1, summary => 'The sky is falling');
  
          $ctx->release;
      }
  
      send_custom_fail();
  
  =head1 METHODS
  
  =over 4
  
  =item $e->facet_data($data)
  
  =item $data = $e->facet_data
  
  Get or set the facet data (see L<Test2::Event>). If no facet_data is set then
  C<< Test2::Event->facet_data >> will be called to produce facets from the other
  data.
  
  =item $e->callback($hub)
  
  Call the custom callback if one is set, otherwise this does nothing.
  
  =item $e->set_callback(sub { ... })
  
  Set the custom callback. The custom callback must be a coderef. The first
  argument to your callback will be the event itself, the second will be the
  L<Test2::Event::Hub> that is using the callback.
  
  =item $bool = $e->causes_fail
  
  =item $e->set_causes_fail($bool)
  
  Get/Set the C<causes_fail> attribute. This defaults to C<0>.
  
  =item $bool = $e->diagnostics
  
  =item $e->set_diagnostics($bool)
  
  Get/Set the C<diagnostics> attribute. This defaults to C<0>.
  
  =item $bool_or_undef = $e->global
  
  =item @bool_or_empty = $e->global
  
  =item $e->set_global($bool_or_undef)
  
  Get/Set the C<diagnostics> attribute. This defaults to an empty list which is
  undef in scalar context.
  
  =item $bool = $e->increments_count
  
  =item $e->set_increments_count($bool)
  
  Get/Set the C<increments_count> attribute. This defaults to C<0>.
  
  =item $bool = $e->no_display
  
  =item $e->set_no_display($bool)
  
  Get/Set the C<no_display> attribute. This defaults to C<0>.
  
  =item @plan = $e->sets_plan
  
  Get the plan if this event sets one. The plan is a list of up to 3 items:
  C<($count, $directive, $reason)>. C<$count> must be defined, the others may be
  undef, or may not exist at all.
  
  =item $e->set_sets_plan(\@plan)
  
  Set the plan. You must pass in an arrayref with up to 3 elements.
  
  =item $summary = $e->summary
  
  =item $e->set_summary($summary_or_undef)
  
  Get/Set the summary. This will default to the event package
  C<'Test2::Event::Generic'>. You can set it to any value. Setting this to
  C<undef> will reset it to the default.
  
  =item $int_or_undef = $e->terminate
  
  =item @int_or_empty = $e->terminate
  
  =item $e->set_terminate($int_or_undef)
  
  This will get/set the C<terminate> attribute. This defaults to undef in scalar
  context, or an empty list in list context. Setting this to undef will clear it
  completely. This must be set to a positive integer (0 or larger).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_GENERIC

$fatpacked{"Test2/Event/Note.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_NOTE';
  package Test2::Event::Note;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/message/;
  
  sub init {
      $_[0]->{+MESSAGE} = 'undef' unless defined $_[0]->{+MESSAGE};
  }
  
  sub summary { $_[0]->{+MESSAGE} }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{info} = [
          {
              tag     => 'NOTE',
              debug   => 0,
              details => $self->{+MESSAGE},
          }
      ];
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Note - Note event type
  
  =head1 DESCRIPTION
  
  Notes, typically rendered to STDOUT.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Note;
  
      my $ctx = context();
      my $event = $ctx->Note($message);
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $note->message
  
  The message for the note.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_NOTE

$fatpacked{"Test2/Event/Ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_OK';
  package Test2::Event::Ok;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{
      pass effective_pass name todo
  };
  
  sub init {
      my $self = shift;
  
      # Do not store objects here, only true or false
      $self->{+PASS} = $self->{+PASS} ? 1 : 0;
      $self->{+EFFECTIVE_PASS} = $self->{+PASS} || (defined($self->{+TODO}) ? 1 : 0);
  }
  
  {
      no warnings 'redefine';
      sub set_todo {
          my $self = shift;
          my ($todo) = @_;
          $self->{+TODO} = $todo;
          $self->{+EFFECTIVE_PASS} = defined($todo) ? 1 : $self->{+PASS};
      }
  }
  
  sub increments_count { 1 };
  
  sub causes_fail { !$_[0]->{+EFFECTIVE_PASS} }
  
  sub summary {
      my $self = shift;
  
      my $name = $self->{+NAME} || "Nameless Assertion";
  
      my $todo = $self->{+TODO};
      if ($todo) {
          $name .= " (TODO: $todo)";
      }
      elsif (defined $todo) {
          $name .= " (TODO)"
      }
  
      return $name;
  }
  
  sub extra_amnesty {
      my $self = shift;
      return unless defined($self->{+TODO}) || ($self->{+EFFECTIVE_PASS} && !$self->{+PASS});
      return {
          tag       => 'TODO',
          details   => $self->{+TODO},
      };
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{assert}  = {
          no_debug => 1,                # Legacy behavior
          pass     => $self->{+PASS},
          details  => $self->{+NAME},
      };
  
      if (my @exra_amnesty = $self->extra_amnesty) {
          unshift @{$out->{amnesty}} => @exra_amnesty;
      }
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Ok - Ok event type
  
  =head1 DESCRIPTION
  
  Ok events are generated whenever you run a test that produces a result.
  Examples are C<ok()>, and C<is()>.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Ok;
  
      my $ctx = context();
      my $event = $ctx->ok($bool, $name, \@diag);
  
  or:
  
      my $ctx   = context();
      my $event = $ctx->send_event(
          'Ok',
          pass => $bool,
          name => $name,
      );
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $rb = $e->pass
  
  The original true/false value of whatever was passed into the event (but
  reduced down to 1 or 0).
  
  =item $name = $e->name
  
  Name of the test.
  
  =item $b = $e->effective_pass
  
  This is the true/false value of the test after TODO and similar modifiers are
  taken into account.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_OK

$fatpacked{"Test2/Event/Pass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PASS';
  package Test2::Event::Pass;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::EventFacet::Info;
  
  BEGIN {
      require Test2::Event;
      our @ISA = qw(Test2::Event);
      *META_KEY = \&Test2::Util::ExternalMeta::META_KEY;
  }
  
  use Test2::Util::HashBase qw{ -name -info };
  
  ##############
  # Old API
  sub summary          { "pass" }
  sub increments_count { 1 }
  sub causes_fail      { 0 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  sub terminate        { () }
  sub global           { () }
  sub sets_plan        { () }
  
  ##############
  # New API
  
  sub add_info {
      my $self = shift;
  
      for my $in (@_) {
          $in = {%$in} if ref($in) ne 'ARRAY';
          $in = Test2::EventFacet::Info->new($in);
  
          push @{$self->{+INFO}} => $in;
      }
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = 'pass';
  
      $out->{assert} = {pass => 1, details => $self->{+NAME}};
  
      $out->{info} = [map {{ %{$_} }} @{$self->{+INFO}}] if $self->{+INFO};
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Pass - Event for a simple passing assertion
  
  =head1 DESCRIPTION
  
  This is an optimal representation of a passing assertion.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub pass {
          my ($name) = @_;
          my $ctx = context();
          $ctx->pass($name);
          $ctx->release;
      }
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_PASS

$fatpacked{"Test2/Event/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PLAN';
  package Test2::Event::Plan;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{max directive reason};
  
  use Carp qw/confess/;
  
  my %ALLOWED = (
      'SKIP'    => 1,
      'NO PLAN' => 1,
  );
  
  sub init {
      if ($_[0]->{+DIRECTIVE}) {
          $_[0]->{+DIRECTIVE} = 'SKIP'    if $_[0]->{+DIRECTIVE} eq 'skip_all';
          $_[0]->{+DIRECTIVE} = 'NO PLAN' if $_[0]->{+DIRECTIVE} eq 'no_plan';
  
          confess "'" . $_[0]->{+DIRECTIVE} . "' is not a valid plan directive"
              unless $ALLOWED{$_[0]->{+DIRECTIVE}};
      }
      else {
          confess "Cannot have a reason without a directive!"
              if defined $_[0]->{+REASON};
  
          confess "No number of tests specified"
              unless defined $_[0]->{+MAX};
  
          confess "Plan test count '" . $_[0]->{+MAX}  . "' does not appear to be a valid positive integer"
              unless $_[0]->{+MAX} =~ m/^\d+$/;
  
          $_[0]->{+DIRECTIVE} = '';
      }
  }
  
  sub sets_plan {
      my $self = shift;
      return (
          $self->{+MAX},
          $self->{+DIRECTIVE},
          $self->{+REASON},
      );
  }
  
  sub terminate {
      my $self = shift;
      # On skip_all we want to terminate the hub
      return 0 if $self->{+DIRECTIVE} && $self->{+DIRECTIVE} eq 'SKIP';
      return undef;
  }
  
  sub summary {
      my $self = shift;
      my $max = $self->{+MAX};
      my $directive = $self->{+DIRECTIVE};
      my $reason = $self->{+REASON};
  
      return "Plan is $max assertions"
          if $max || !$directive;
  
      return "Plan is '$directive', $reason"
          if $reason;
  
      return "Plan is '$directive'";
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{control}->{terminate} = $self->{+DIRECTIVE} eq 'SKIP' ? 0 : undef
          unless defined $out->{control}->{terminate};
  
      $out->{plan} = {count => $self->{+MAX}};
      $out->{plan}->{details} = $self->{+REASON} if defined $self->{+REASON};
  
      if (my $dir = $self->{+DIRECTIVE}) {
          $out->{plan}->{skip} = 1 if $dir eq 'SKIP';
          $out->{plan}->{none} = 1 if $dir eq 'NO PLAN';
      }
  
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Plan - The event of a plan
  
  =head1 DESCRIPTION
  
  Plan events are fired off whenever a plan is declared, done testing is called,
  or a subtext completes.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Plan;
  
      my $ctx = context();
  
      # Plan for 10 tests to run
      my $event = $ctx->plan(10);
  
      # Plan to skip all tests (will exit 0)
      $ctx->plan(0, skip_all => "These tests need to be skipped");
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $num = $plan->max
  
  Get the number of expected tests
  
  =item $dir = $plan->directive
  
  Get the directive (such as TODO, skip_all, or no_plan).
  
  =item $reason = $plan->reason
  
  Get the reason for the directive.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_PLAN

$fatpacked{"Test2/Event/Skip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SKIP';
  package Test2::Event::Skip;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event::Ok; our @ISA = qw(Test2::Event::Ok) }
  use Test2::Util::HashBase qw{reason};
  
  sub init {
      my $self = shift;
      $self->SUPER::init;
      $self->{+EFFECTIVE_PASS} = 1;
  }
  
  sub causes_fail { 0 }
  
  sub summary {
      my $self = shift;
      my $out = $self->SUPER::summary(@_);
  
      if (my $reason = $self->reason) {
          $out .= " (SKIP: $reason)";
      }
      else {
          $out .= " (SKIP)";
      }
  
      return $out;
  }
  
  sub extra_amnesty {
      my $self = shift;
  
      my @out;
  
      push @out => {
          tag       => 'TODO',
          details   => $self->{+TODO},
      } if defined $self->{+TODO};
  
      push @out => {
          tag       => 'skip',
          details   => $self->{+REASON},
          inherited => 0,
      };
  
      return @out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Skip - Skip event type
  
  =head1 DESCRIPTION
  
  Skip events bump test counts just like L<Test2::Event::Ok> events, but
  they can never fail.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Skip;
  
      my $ctx = context();
      my $event = $ctx->skip($name, $reason);
  
  or:
  
      my $ctx   = context();
      my $event = $ctx->send_event(
          'Skip',
          name   => $name,
          reason => $reason,
      );
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $reason = $e->reason
  
  The original true/false value of whatever was passed into the event (but
  reduced down to 1 or 0).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST2_EVENT_SKIP

$fatpacked{"Test2/Event/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SUBTEST';
  package Test2::Event::Subtest;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Event::Ok; our @ISA = qw(Test2::Event::Ok) }
  use Test2::Util::HashBase qw{subevents buffered subtest_id subtest_uuid};
  
  sub init {
      my $self = shift;
      $self->SUPER::init();
      $self->{+SUBEVENTS} ||= [];
      if ($self->{+EFFECTIVE_PASS}) {
          $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}};
      }
  }
  
  {
      no warnings 'redefine';
  
      sub set_subevents {
          my $self      = shift;
          my @subevents = @_;
  
          if ($self->{+EFFECTIVE_PASS}) {
              $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @subevents;
          }
  
          $self->{+SUBEVENTS} = \@subevents;
      }
  
      sub set_effective_pass {
          my $self = shift;
          my ($pass) = @_;
  
          if ($pass) {
              $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}};
          }
          elsif ($self->{+EFFECTIVE_PASS} && !$pass) {
              for my $s (grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}}) {
                  $_->set_effective_pass(0) unless $s->can('todo') && defined $s->todo;
              }
          }
  
          $self->{+EFFECTIVE_PASS} = $pass;
      }
  }
  
  sub summary {
      my $self = shift;
  
      my $name = $self->{+NAME} || "Nameless Subtest";
  
      my $todo = $self->{+TODO};
      if ($todo) {
          $name .= " (TODO: $todo)";
      }
      elsif (defined $todo) {
          $name .= " (TODO)";
      }
  
      return $name;
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->SUPER::facet_data();
  
      $out->{parent} = {
          hid      => $self->subtest_id,
          children => [map {$_->facet_data} @{$self->{+SUBEVENTS}}],
          buffered => $self->{+BUFFERED},
      };
  
      return $out;
  }
  
  sub add_amnesty {
      my $self = shift;
  
      for my $am (@_) {
          $am = {%$am} if ref($am) ne 'ARRAY';
          $am = Test2::EventFacet::Amnesty->new($am);
  
          push @{$self->{+AMNESTY}} => $am;
  
          for my $e (@{$self->{+SUBEVENTS}}) {
              $e->add_amnesty($am->clone(inherited => 1));
          }
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Subtest - Event for subtest types
  
  =head1 DESCRIPTION
  
  This class represents a subtest. This class is a subclass of
  L<Test2::Event::Ok>.
  
  =head1 ACCESSORS
  
  This class inherits from L<Test2::Event::Ok>.
  
  =over 4
  
  =item $arrayref = $e->subevents
  
  Returns the arrayref containing all the events from the subtest
  
  =item $bool = $e->buffered
  
  True if the subtest is buffered, that is all subevents render at once. If this
  is false it means all subevents render as they are produced.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_SUBTEST

$fatpacked{"Test2/Event/TAP/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_TAP_VERSION';
  package Test2::Event::TAP::Version;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/version/;
  
  sub init {
      my $self = shift;
      defined $self->{+VERSION} or croak "'version' is a required attribute";
  }
  
  sub summary { 'TAP version ' . $_[0]->{+VERSION} }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = $self->summary;
  
      push @{$out->{info}} => {
          tag     => 'INFO',
          debug   => 0,
          details => $self->summary,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::TAP::Version - Event for TAP version.
  
  =head1 DESCRIPTION
  
  This event is used if a TAP formatter wishes to set a version.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Encoding;
  
      my $ctx = context();
      my $event = $ctx->send_event('TAP::Version', version => 42);
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $version = $e->version
  
  The TAP version being parsed.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_TAP_VERSION

$fatpacked{"Test2/Event/V2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_V2';
  package Test2::Event::V2;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Scalar::Util qw/reftype/;
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  
  use Test2::Util::Facets2Legacy qw{
      causes_fail diagnostics global increments_count no_display sets_plan
      subtest_id summary terminate
  };
  
  use Test2::Util::HashBase qw/-about/;
  
  sub non_facet_keys {
      return (
          +UUID,
          Test2::Util::ExternalMeta::META_KEY(),
      );
  }
  
  sub init {
      my $self = shift;
  
      my $uuid;
      if ($uuid = $self->{+UUID}) {
          croak "uuid '$uuid' passed to constructor, but uuid '$self->{+ABOUT}->{uuid}' is already set in the 'about' facet"
              if $self->{+ABOUT}->{uuid} && $self->{+ABOUT}->{uuid} ne $uuid;
  
          $self->{+ABOUT}->{uuid} = $uuid;
      }
      elsif ($uuid = $self->{+ABOUT}->{uuid}) {
          $self->SUPER::set_uuid($uuid);
      }
  
      # Clone the trace, make sure it is blessed
      if (my $trace = $self->{+TRACE}) {
          $self->{+TRACE} = Test2::EventFacet::Trace->new(%$trace);
      }
  }
  
  sub set_uuid {
      my $self = shift;
      my ($uuid) = @_;
      $self->{+ABOUT}->{uuid} = $uuid;
      $self->SUPER::set_uuid($uuid);
  }
  
  sub facet_data {
      my $self = shift;
      my $f = { %{$self} };
  
      delete $f->{$_} for $self->non_facet_keys;
  
      my %out;
      for my $k (keys %$f) {
          next if substr($k, 0, 1) eq '_';
  
          my $data = $f->{$k};
          my $is_list = reftype($data) eq 'ARRAY';
          $out{$k} = $is_list ? [ map { {%{$_}} } @$data ] : {%$data};
      }
  
      if (my $meta = $self->meta_facet_data) {
          $out{meta} = {%$meta, %{$out{meta} || {}}};
      }
  
      return \%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::V2 - Second generation event.
  
  =head1 DESCRIPTION
  
  This is the event type that should be used instead of L<Test2::Event> or its
  legacy subclasses.
  
  =head1 SYNOPSIS
  
  =head2 USING A CONTEXT
  
      use Test2::API qw/context/;
  
      sub my_tool {
          my $ctx = context();
  
          my $event = $ctx->send_ev2(info => [{tag => 'NOTE', details => "This is a note"}]);
  
          $ctx->release;
  
          return $event;
      }
  
  =head2 USING THE CONSTRUCTOR
  
      use Test2::Event::V2;
  
      my $e = Test2::Event::V2->new(
          trace => {frame => [$PKG, $FILE, $LINE, $SUBNAME]},
          info  => [{tag => 'NOTE', details => "This is a note"}],
      );
  
  =head1 METHODS
  
  This class inherits from L<Test2::Event>.
  
  =over 4
  
  =item $fd = $e->facet_data()
  
  This will return a hashref of facet data. Each facet hash will be a shallow
  copy of the original.
  
  =item $about = $e->about()
  
  This will return the 'about' facet hashref.
  
  B<NOTE:> This will return the internal hashref, not a copy.
  
  =item $trace = $e->trace()
  
  This will return the 'trace' facet, normally blessed (but this is not enforced
  when the trace is set using C<set_trace()>.
  
  B<NOTE:> This will return the internal trace, not a copy.
  
  =back
  
  =head2 MUTATION
  
  =over 4
  
  =item $e->add_amnesty({...})
  
  Inherited from L<Test2::Event>. This can be used to add 'amnesty' facets to an
  existing event. Each new item is added to the B<END> of the list.
  
  B<NOTE:> Items B<ARE> blessed when added.
  
  =item $e->add_hub({...})
  
  Inherited from L<Test2::Event>. This is used by hubs to stamp events as they
  pass through. New items are added to the B<START> of the list.
  
  B<NOTE:> Items B<ARE NOT> blessed when added.
  
  =item $e->set_uuid($UUID)
  
  Inherited from L<Test2::Event>, overridden to also vivify/mutate the 'about'
  facet.
  
  =item $e->set_trace($trace)
  
  Inherited from L<Test2::Event> which allows you to change the trace.
  
  B<Note:> This method does not bless/clone the trace for you. Many things will
  expect the trace to be blessed, so you should probably do that.
  
  =back
  
  =head2 LEGACY SUPPORT METHODS
  
  These are all imported from L<Test2::Util::Facets2Legacy>, see that module or
  L<Test2::Event> for documentation on what they do.
  
  =over 4
  
  =item causes_fail
  
  =item diagnostics
  
  =item global
  
  =item increments_count
  
  =item no_display
  
  =item sets_plan
  
  =item subtest_id
  
  =item summary
  
  =item terminate
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_V2

$fatpacked{"Test2/Event/Waiting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_WAITING';
  package Test2::Event::Waiting;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase;
  
  sub global { 1 };
  
  sub summary { "IPC is waiting for children to finish..." }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      push @{$out->{info}} => {
          tag     => 'INFO',
          debug   => 0,
          details => $self->summary,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Waiting - Tell all procs/threads it is time to be done
  
  =head1 DESCRIPTION
  
  This event has no data of its own. This event is sent out by the IPC system
  when the main process/thread is ready to end.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_WAITING

$fatpacked{"Test2/EventFacet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET';
  package Test2::EventFacet;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::Util::HashBase qw/-details/;
  use Carp qw/croak/;
  
  my $SUBLEN = length(__PACKAGE__ . '::');
  sub facet_key {
      my $key = ref($_[0]) || $_[0];
      substr($key, 0, $SUBLEN, '');
      return lc($key);
  }
  
  sub is_list { 0 }
  
  sub clone {
      my $self = shift;
      my $type = ref($self);
      return bless {%$self, @_}, $type;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet - Base class for all event facets.
  
  =head1 DESCRIPTION
  
  Base class for all event facets.
  
  =head1 METHODS
  
  =over 4
  
  =item $key = $facet_class->facet_key()
  
  This will return the key for the facet in the facet data hash.
  
  =item $bool = $facet_class->is_list()
  
  This will return true if the facet should be in a list instead of a single
  item.
  
  =item $clone = $facet->clone()
  
  =item $clone = $facet->clone(%replace)
  
  This will make a shallow clone of the facet. You may specify fields to override
  as arguments.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET

$fatpacked{"Test2/EventFacet/About.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ABOUT';
  package Test2::EventFacet::About;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -package -no_display -uuid -eid };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::About - Facet with event details.
  
  =head1 DESCRIPTION
  
  This facet has information about the event, such as event package.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $about->{details}
  
  =item $string = $about->details()
  
  Summary about the event.
  
  =item $package = $about->{package}
  
  =item $package = $about->package()
  
  Event package name.
  
  =item $bool = $about->{no_display}
  
  =item $bool = $about->no_display()
  
  True if the event should be skipped by formatters.
  
  =item $uuid = $about->{uuid}
  
  =item $uuid = $about->uuid()
  
  Will be set to a uuid if uuid tagging was enabled.
  
  =item $uuid = $about->{eid}
  
  =item $uuid = $about->eid()
  
  A unique (for the test job) identifier for the event.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ABOUT

$fatpacked{"Test2/EventFacet/Amnesty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_AMNESTY';
  package Test2::EventFacet::Amnesty;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -inherited };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Amnesty - Facet for assertion amnesty.
  
  =head1 DESCRIPTION
  
  This package represents what is expected in units of amnesty.
  
  =head1 NOTES
  
  This facet appears in a list instead of being a single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $amnesty->{details}
  
  =item $string = $amnesty->details()
  
  Human readable explanation of why amnesty was granted.
  
  Example: I<Not implemented yet, will fix>
  
  =item $short_string = $amnesty->{tag}
  
  =item $short_string = $amnesty->tag()
  
  Short string (usually 10 characters or less, not enforced, but may be truncated
  by renderers) categorizing the amnesty.
  
  =item $bool = $amnesty->{inherited}
  
  =item $bool = $amnesty->inherited()
  
  This will be true if the amnesty was granted to a parent event and inherited by
  this event, which is a child, such as an assertion within a subtest that is
  marked todo.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_AMNESTY

$fatpacked{"Test2/EventFacet/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ASSERT';
  package Test2::EventFacet::Assert;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -pass -no_debug -number };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Assert - Facet representing an assertion.
  
  =head1 DESCRIPTION
  
  The assertion facet is provided by any event representing an assertion that was
  made.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $assert->{details}
  
  =item $string = $assert->details()
  
  Human readable description of the assertion.
  
  =item $bool = $assert->{pass}
  
  =item $bool = $assert->pass()
  
  True if the assertion passed.
  
  =item $bool = $assert->{no_debug}
  
  =item $bool = $assert->no_debug()
  
  Set this to true if you have provided custom diagnostics and do not want the
  defaults to be displayed.
  
  =item $int = $assert->{number}
  
  =item $int = $assert->number()
  
  (Optional) assertion number. This may be omitted or ignored. This is usually
  only useful when parsing/processing TAP.
  
  B<Note>: This is not set by the Test2 system, assertion number is not known
  until AFTER the assertion has been processed. This attribute is part of the
  spec only for harnesses.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ASSERT

$fatpacked{"Test2/EventFacet/Control.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_CONTROL';
  package Test2::EventFacet::Control;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -global -terminate -halt -has_callback -encoding };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Control - Facet for hub actions and behaviors.
  
  =head1 DESCRIPTION
  
  This facet is used when the event needs to give instructions to the Test2
  internals.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $control->{details}
  
  =item $string = $control->details()
  
  Human readable explanation for the special behavior.
  
  =item $bool = $control->{global}
  
  =item $bool = $control->global()
  
  True if the event is global in nature and should be seen by all hubs.
  
  =item $exit = $control->{terminate}
  
  =item $exit = $control->terminate()
  
  Defined if the test should immediately exit, the value is the exit code and may
  be C<0>.
  
  =item $bool = $control->{halt}
  
  =item $bool = $control->halt()
  
  True if all testing should be halted immediately.
  
  =item $bool = $control->{has_callback}
  
  =item $bool = $control->has_callback()
  
  True if the C<callback($hub)> method on the event should be called.
  
  =item $encoding = $control->{encoding}
  
  =item $encoding = $control->encoding()
  
  This can be used to change the encoding from this event onward.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_CONTROL

$fatpacked{"Test2/EventFacet/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ERROR';
  package Test2::EventFacet::Error;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub facet_key { 'errors' }
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -fail };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Error - Facet for errors that need to be shown.
  
  =head1 DESCRIPTION
  
  This facet is used when an event needs to convey errors.
  
  =head1 NOTES
  
  This facet has the hash key C<'errors'>, and is a list of facets instead of a
  single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $error->{details}
  
  =item $string = $error->details()
  
  Explanation of the error, or the error itself (such as an exception). In perl
  exceptions may be blessed objects, so this field may contain a blessed object.
  
  =item $short_string = $error->{tag}
  
  =item $short_string = $error->tag()
  
  Short tag to categorize the error. This is usually 10 characters or less,
  formatters may truncate longer tags.
  
  =item $bool = $error->{fail}
  
  =item $bool = $error->fail()
  
  Not all errors are fatal, some are displayed having already been handled. Set
  this to true if you want the error to cause the test to fail. Without this the
  error is simply a diagnostics message that has no effect on the overall
  pass/fail result.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ERROR

$fatpacked{"Test2/EventFacet/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_HUB';
  package Test2::EventFacet::Hub;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  sub facet_key { 'hubs' }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{-pid -tid -hid -nested -buffered -uuid -ipc};
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Hub - Facet for the hubs an event passes through.
  
  =head1 DESCRIPTION
  
  These are a record of the hubs an event passes through. Most recent hub is the
  first one in the list.
  
  =head1 FACET FIELDS
  
  =over 4
  
  =item $string = $trace->{details}
  
  =item $string = $trace->details()
  
  The hub class or subclass
  
  =item $int = $trace->{pid}
  
  =item $int = $trace->pid()
  
  PID of the hub this event was sent to.
  
  =item $int = $trace->{tid}
  
  =item $int = $trace->tid()
  
  The thread ID of the hub the event was sent to.
  
  =item $hid = $trace->{hid}
  
  =item $hid = $trace->hid()
  
  The ID of the hub that the event was send to.
  
  =item $huuid = $trace->{huuid}
  
  =item $huuid = $trace->huuid()
  
  The UUID of the hub that the event was sent to.
  
  =item $int = $trace->{nested}
  
  =item $int = $trace->nested()
  
  How deeply nested the hub was.
  
  =item $bool = $trace->{buffered}
  
  =item $bool = $trace->buffered()
  
  True if the event was buffered and not sent to the formatter independent of a
  parent (This should never be set when nested is C<0> or C<undef>).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_HUB

$fatpacked{"Test2/EventFacet/Info.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_INFO';
  package Test2::EventFacet::Info;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{-tag -debug -important};
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Info - Facet for information a developer might care about.
  
  =head1 DESCRIPTION
  
  This facet represents messages intended for humans that will help them either
  understand a result, or diagnose a failure.
  
  =head1 NOTES
  
  This facet appears in a list instead of being a single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string_or_structure = $info->{details}
  
  =item $string_or_structure = $info->details()
  
  Human readable string or data structure, this is the information to display.
  Formatters are free to render the structures however they please. This may
  contain a blessed object.
  
  =item $short_string = $info->{tag}
  
  =item $short_string = $info->tag()
  
  Short tag to categorize the info. This is usually 10 characters or less,
  formatters may truncate longer tags.
  
  =item $bool = $info->{debug}
  
  =item $bool = $info->debug()
  
  Set this to true if the message is critical, or explains a failure. This is
  info that should be displayed by formatters even in less-verbose modes.
  
  When false the information is not considered critical and may not be rendered
  in less-verbose modes.
  
  =item $bool = $info->{important}
  
  =item $bool = $info->important
  
  This should be set for non debug messages that are still important enough to
  show when a formatter is in quiet mode. A formatter should send these to STDOUT
  not STDERR, but should show them even in non-verbose mode.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_INFO

$fatpacked{"Test2/EventFacet/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_META';
  package Test2::EventFacet::Meta;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use vars qw/$AUTOLOAD/;
  
  # replace set_details
  {
      no warnings 'redefine';
      sub set_details { $_[0]->{'set_details'} }
  }
  
  sub can {
      my $self = shift;
      my ($name) = @_;
  
      my $existing = $self->SUPER::can($name);
      return $existing if $existing;
  
      # Only vivify when called on an instance, do not vivify for a class. There
      # are a lot of magic class methods used in things like serialization (or
      # the forks.pm module) which cause problems when vivified.
      return undef unless ref($self);
  
      my $sub = sub { $_[0]->{$name} };
      {
          no strict 'refs';
          *$name = $sub;
      }
  
      return $sub;
  }
  
  sub AUTOLOAD {
      my $name = $AUTOLOAD;
      $name =~ s/^.*:://g;
      my $sub = $_[0]->can($name);
      goto &$sub;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Meta - Facet for meta-data
  
  =head1 DESCRIPTION
  
  This facet can contain any random meta-data that has been attached to the
  event.
  
  =head1 METHODS AND FIELDS
  
  Any/all fields and accessors are autovivified into existence. There is no way
  to know what metadata may be added, so any is allowed.
  
  =over 4
  
  =item $anything = $meta->{anything}
  
  =item $anything = $meta->anything()
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_META

$fatpacked{"Test2/EventFacet/Parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PARENT';
  package Test2::EventFacet::Parent;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/confess/;
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -hid -children -buffered };
  
  sub init {
      confess "Attribute 'hid' must be set"
          unless defined $_[0]->{+HID};
  
      $_[0]->{+CHILDREN} ||= [];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Parent - Base class for all event facets.
  
  =head1 DESCRIPTION
  
  This facet is used when an event contains other events, such as a subtest.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $parent->{details}
  
  =item $string = $parent->details()
  
  Human readable description of the event.
  
  =item $hid = $parent->{hid}
  
  =item $hid = $parent->hid()
  
  Hub ID of the hub that is represented in the parent-child relationship.
  
  =item $arrayref = $parent->{children}
  
  =item $arrayref = $parent->children()
  
  Arrayref containing the facet-data hashes of events nested under this one.
  
  I<To get the actual events you need to get them from the parent event directly>
  
  =item $bool = $parent->{buffered}
  
  =item $bool = $parent->buffered()
  
  True if the subtest is buffered (meaning the formatter has probably not seen
  them yet).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_PARENT

$fatpacked{"Test2/EventFacet/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PLAN';
  package Test2::EventFacet::Plan;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -count -skip -none };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Plan - Facet for setting the plan
  
  =head1 DESCRIPTION
  
  Events use this facet when they need to set the plan.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $plan->{details}
  
  =item $string = $plan->details()
  
  Human readable explanation for the plan being set. This is normally not
  rendered by most formatters except when the C<skip> field is also set.
  
  =item $positive_int = $plan->{count}
  
  =item $positive_int = $plan->count()
  
  Set the number of expected assertions. This should usually be set to C<0> when
  C<skip> or C<none> are also set.
  
  =item $bool = $plan->{skip}
  
  =item $bool = $plan->skip()
  
  When true the entire test should be skipped. This is usually paired with an
  explanation in the C<details> field, and a C<control> facet that has
  C<terminate> set to C<0>.
  
  =item $bool = $plan->{none}
  
  =item $bool = $plan->none()
  
  This is mainly used by legacy L<Test::Builder> tests which set the plan to C<no
  plan>, a construct that predates the much better C<done_testing()>.
  
  If you are using this in non-legacy code you may need to reconsider the course
  of your life, maybe a hermitage would suite you?
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_PLAN

$fatpacked{"Test2/EventFacet/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_RENDER';
  package Test2::EventFacet::Render;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -facet -mode };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Render - Facet that dictates how to render an event.
  
  =head1 DESCRIPTION
  
  This facet is used to dictate how the event should be rendered by the standard
  test2 rendering tools. If this facet is present then ONLY what is specified by
  it will be rendered. It is assumed that anything important or note-worthy will
  be present here, no other facets will be considered for rendering/display.
  
  This facet is a list type, you can add as many items as needed.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $render->[#]->{details}
  
  =item $string = $render->[#]->details()
  
  Human readable text for display.
  
  =item $string = $render->[#]->{tag}
  
  =item $string = $render->[#]->tag()
  
  Tag that should prefix/identify the main text.
  
  =item $string = $render->[#]->{facet}
  
  =item $string = $render->[#]->facet()
  
  Optional, if the display text was generated from another facet this should
  state what facet it was.
  
  =item $mode = $render->[#]->mode{}
  
  =item $mode = $render->[#]->mode()
  
  =over 4
  
  =item calculated
  
  Calculated means the facet was generated from another facet. Calculated facets
  may be cleared and regenerated whenever the event state changes.
  
  =item replace
  
  Replace means the facet is intended to replace the normal rendering of the
  event.
  
  =back
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_RENDER

$fatpacked{"Test2/EventFacet/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_TRACE';
  package Test2::EventFacet::Trace;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  
  use Test2::Util qw/get_tid pkg_to_file gen_uid/;
  use Carp qw/confess/;
  
  use Test2::Util::HashBase qw{^frame ^pid ^tid ^cid -hid -nested details -buffered -uuid -huuid};
  
  {
      no warnings 'once';
      *DETAIL = \&DETAILS;
      *detail = \&details;
      *set_detail = \&set_details;
  }
  
  sub init {
      confess "The 'frame' attribute is required"
          unless $_[0]->{+FRAME};
  
      $_[0]->{+DETAILS} = delete $_[0]->{detail} if $_[0]->{detail};
  
      unless (defined($_[0]->{+PID}) || defined($_[0]->{+TID}) || defined($_[0]->{+CID})) {
          $_[0]->{+PID} = $$        unless defined $_[0]->{+PID};
          $_[0]->{+TID} = get_tid() unless defined $_[0]->{+TID};
      }
  }
  
  sub snapshot {
      my ($orig, @override) = @_;
      bless {%$orig, @override}, __PACKAGE__;
  }
  
  sub signature {
      my $self = shift;
  
      # Signature is only valid if all of these fields are defined, there is no
      # signature if any is missing. '0' is ok, but '' is not.
      return join ':' => map { (defined($_) && length($_)) ? $_ : return undef } (
          $self->{+CID},
          $self->{+PID},
          $self->{+TID},
          $self->{+FRAME}->[1],
          $self->{+FRAME}->[2],
      );
  }
  
  sub debug {
      my $self = shift;
      return $self->{+DETAILS} if $self->{+DETAILS};
      my ($pkg, $file, $line) = $self->call;
      return "at $file line $line";
  }
  
  sub alert {
      my $self = shift;
      my ($msg) = @_;
      warn $msg . ' ' . $self->debug . ".\n";
  }
  
  sub throw {
      my $self = shift;
      my ($msg) = @_;
      die $msg . ' ' . $self->debug . ".\n";
  }
  
  sub call { @{$_[0]->{+FRAME}} }
  
  sub package { $_[0]->{+FRAME}->[0] }
  sub file    { $_[0]->{+FRAME}->[1] }
  sub line    { $_[0]->{+FRAME}->[2] }
  sub subname { $_[0]->{+FRAME}->[3] }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Trace - Debug information for events
  
  =head1 DESCRIPTION
  
  The L<Test2::API::Context> object, as well as all L<Test2::Event> types need to
  have access to information about where they were created.  This object
  represents that information.
  
  =head1 SYNOPSIS
  
      use Test2::EventFacet::Trace;
  
      my $trace = Test2::EventFacet::Trace->new(
          frame => [$package, $file, $line, $subname],
      );
  
  =head1 FACET FIELDS
  
  =over 4
  
  =item $string = $trace->{details}
  
  =item $string = $trace->details()
  
  Used as a custom trace message that will be used INSTEAD of
  C<< at <FILE> line <LINE> >> when calling C<< $trace->debug >>.
  
  =item $frame = $trace->{frame}
  
  =item $frame = $trace->frame()
  
  Get the call frame arrayref.
  
  =item $int = $trace->{pid}
  
  =item $int = $trace->pid()
  
  The process ID in which the event was generated.
  
  =item $int = $trace->{tid}
  
  =item $int = $trace->tid()
  
  The thread ID in which the event was generated.
  
  =item $id = $trace->{cid}
  
  =item $id = $trace->cid()
  
  The ID of the context that was used to create the event.
  
  =item $uuid = $trace->{uuid}
  
  =item $uuid = $trace->uuid()
  
  The UUID of the context that was used to create the event. (If uuid tagging was
  enabled)
  
  =back
  
  =head2 DISCOURAGED HUB RELATED FIELDS
  
  These fields were not always set properly by tools. These are B<MOSTLY>
  deprecated by the L<Test2::EventFacet::Hub> facets. These fields are not
  required, and may only reflect the hub that was current when the event was
  created, which is not necessarily the same as the hub the event was sent
  through.
  
  Some tools did do a good job setting these to the correct hub, but you cannot
  always rely on that. Use the 'hubs' facet list instead.
  
  =over 4
  
  =item $hid = $trace->{hid}
  
  =item $hid = $trace->hid()
  
  The ID of the hub that was current when the event was created.
  
  =item $huuid = $trace->{huuid}
  
  =item $huuid = $trace->huuid()
  
  The UUID of the hub that was current when the event was created. (If uuid
  tagging was enabled).
  
  =item $int = $trace->{nested}
  
  =item $int = $trace->nested()
  
  How deeply nested the event is.
  
  =item $bool = $trace->{buffered}
  
  =item $bool = $trace->buffered()
  
  True if the event was buffered and not sent to the formatter independent of a
  parent (This should never be set when nested is C<0> or C<undef>).
  
  =back
  
  =head1 METHODS
  
  B<Note:> All facet frames are also methods.
  
  =over 4
  
  =item $trace->set_detail($msg)
  
  =item $msg = $trace->detail
  
  Used to get/set a custom trace message that will be used INSTEAD of
  C<< at <FILE> line <LINE> >> when calling C<< $trace->debug >>.
  
  C<detail()> is an alias to the C<details> facet field for backwards
  compatibility.
  
  =item $str = $trace->debug
  
  Typically returns the string C<< at <FILE> line <LINE> >>. If C<detail> is set
  then its value will be returned instead.
  
  =item $trace->alert($MESSAGE)
  
  This issues a warning at the frame (filename and line number where
  errors should be reported).
  
  =item $trace->throw($MESSAGE)
  
  This throws an exception at the frame (filename and line number where
  errors should be reported).
  
  =item ($package, $file, $line, $subname) = $trace->call()
  
  Get the caller details for the debug-info. This is where errors should be
  reported.
  
  =item $pkg = $trace->package
  
  Get the debug-info package.
  
  =item $file = $trace->file
  
  Get the debug-info filename.
  
  =item $line = $trace->line
  
  Get the debug-info line number.
  
  =item $subname = $trace->subname
  
  Get the debug-info subroutine name.
  
  =item $sig = trace->signature
  
  Get a signature string that identifies this trace. This is used to check if
  multiple events are related. The signature includes pid, tid, file, line
  number, and the cid.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_TRACE

$fatpacked{"Test2/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER';
  package Test2::Formatter;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  my %ADDED;
  sub import {
      my $class = shift;
      return if $class eq __PACKAGE__;
      return if $ADDED{$class}++;
      require Test2::API;
      Test2::API::test2_formatter_add($class);
  }
  
  sub new_root {
      my $class = shift;
      return $class->new(@_);
  }
  
  sub hide_buffered { 1 }
  
  sub terminate { }
  
  sub finalize { }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Formatter - Namespace for formatters.
  
  =head1 DESCRIPTION
  
  This is the namespace for formatters. This is an empty package.
  
  =head1 CREATING FORMATTERS
  
  A formatter is any package or object with a C<write($event, $num)> method.
  
      package Test2::Formatter::Foo;
      use strict;
      use warnings;
  
      sub write {
          my $self_or_class = shift;
          my ($event, $assert_num) = @_;
          ...
      }
  
      sub hide_buffered { 1 }
  
      sub terminate { }
  
      sub finalize { }
  
      sub new_root {
          my $class = shift;
          ...
          $class->new(@_);
      }
  
      1;
  
  The C<write> method is a method, so it either gets a class or instance. The two
  arguments are the C<$event> object it should record, and the C<$assert_num>
  which is the number of the current assertion (ok), or the last assertion if
  this event is not itself an assertion. The assertion number may be any integer 0
  or greater, and may be undefined in some cases.
  
  The C<hide_buffered()> method must return a boolean. This is used to tell
  buffered subtests whether or not to send it events as they are being buffered.
  See L<Test2::API/"run_subtest(...)"> for more information.
  
  The C<terminate> and C<finalize> methods are optional methods called that you
  can implement if the format you're generating needs to handle these cases, for
  example if you are generating XML and need close open tags.
  
  The C<terminate> method is called when an event's C<terminate> method returns
  true, for example when a L<Test2::Event::Plan> has a C<'skip_all'> plan, or
  when a L<Test2::Event::Bail> event is sent. The C<terminate> method is passed
  a single argument, the L<Test2::Event> object which triggered the terminate.
  
  The C<finalize> method is always the last thing called on the formatter, I<<
  except when C<terminate> is called for a Bail event >>. It is passed the
  following arguments:
  
  The C<new_root> method is called when C<Test2::API::Stack> Initializes the root
  hub for the first time. Most formatters will simply have this call C<<
  $class->new >>, which is the default behavior. Some formatters however may want
  to take extra action during construction of the root formatter, this is where
  they can do that.
  
  =over 4
  
  =item * The number of tests that were planned
  
  =item * The number of tests actually seen
  
  =item * The number of tests which failed
  
  =item * A boolean indicating whether or not the test suite passed
  
  =item * A boolean indicating whether or not this call is for a subtest
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_FORMATTER

$fatpacked{"Test2/Formatter/TAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER_TAP';
  package Test2::Formatter::TAP;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::Util qw/clone_io/;
  
  use Test2::Util::HashBase qw{
      no_numbers handles _encoding _last_fh
      -made_assertion
  };
  
  sub OUT_STD() { 0 }
  sub OUT_ERR() { 1 }
  
  BEGIN { require Test2::Formatter; our @ISA = qw(Test2::Formatter) }
  
  sub _autoflush {
      my($fh) = pop;
      my $old_fh = select $fh;
      $| = 1;
      select $old_fh;
  }
  
  _autoflush(\*STDOUT);
  _autoflush(\*STDERR);
  
  sub hide_buffered { 1 }
  
  sub init {
      my $self = shift;
  
      $self->{+HANDLES} ||= $self->_open_handles;
      if(my $enc = delete $self->{encoding}) {
          $self->encoding($enc);
      }
  }
  
  sub _open_handles {
      my $self = shift;
  
      require Test2::API;
      my $out = clone_io(Test2::API::test2_stdout());
      my $err = clone_io(Test2::API::test2_stderr());
  
      _autoflush($out);
      _autoflush($err);
  
      return [$out, $err];
  }
  
  sub encoding {
      my $self = shift;
  
      if ($] ge "5.007003" and @_) {
          my ($enc) = @_;
          my $handles = $self->{+HANDLES};
  
          # https://rt.perl.org/Public/Bug/Display.html?id=31923
          # If utf8 is requested we use ':utf8' instead of ':encoding(utf8)' in
          # order to avoid the thread segfault.
          if ($enc =~ m/^utf-?8$/i) {
              binmode($_, ":utf8") for @$handles;
          }
          else {
              binmode($_, ":encoding($enc)") for @$handles;
          }
          $self->{+_ENCODING} = $enc;
      }
  
      return $self->{+_ENCODING};
  }
  
  if ($^C) {
      no warnings 'redefine';
      *write = sub {};
  }
  sub write {
      my ($self, $e, $num, $f) = @_;
  
      # The most common case, a pass event with no amnesty and a normal name.
      return if $self->print_optimal_pass($e, $num);
  
      $f ||= $e->facet_data;
  
      $self->encoding($f->{control}->{encoding}) if $f->{control}->{encoding};
  
      my @tap = $self->event_tap($f, $num) or return;
  
      $self->{+MADE_ASSERTION} = 1 if $f->{assert};
  
      my $nesting = $f->{trace}->{nested} || 0;
      my $handles = $self->{+HANDLES};
      my $indent = '    ' x $nesting;
  
      # Local is expensive! Only do it if we really need to.
      local($\, $,) = (undef, '') if $\ || $,;
      for my $set (@tap) {
          no warnings 'uninitialized';
          my ($hid, $msg) = @$set;
          next unless $msg;
          my $io = $handles->[$hid] or next;
  
          print $io "\n"
              if $ENV{HARNESS_ACTIVE}
              && !$ENV{HARNESS_IS_VERBOSE}
              && $hid == OUT_ERR
              && $self->{+_LAST_FH} != $io
              && $msg =~ m/^#\s*Failed test /;
  
          $msg =~ s/^/$indent/mg if $nesting;
          print $io $msg;
          $self->{+_LAST_FH} = $io;
      }
  }
  
  sub print_optimal_pass {
      my ($self, $e, $num) = @_;
  
      my $type = ref($e);
  
      # Only optimal if this is a Pass or a passing Ok
      return unless $type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass});
  
      # Amnesty requires further processing (todo is a form of amnesty)
      return if ($e->{amnesty} && @{$e->{amnesty}}) || defined($e->{todo});
  
      # A name with a newline or hash symbol needs extra processing
      return if defined($e->{name}) && (-1 != index($e->{name}, "\n") || -1 != index($e->{name}, '#'));
  
      my $ok = 'ok';
      $ok .= " $num" if $num && !$self->{+NO_NUMBERS};
      $ok .= defined($e->{name}) ? " - $e->{name}\n" : "\n";
  
      if (my $nesting = $e->{trace}->{nested}) {
          my $indent = '    ' x $nesting;
          $ok = "$indent$ok";
      }
  
      my $io = $self->{+HANDLES}->[OUT_STD];
  
      local($\, $,) = (undef, '') if $\ || $,;
      print $io $ok;
      $self->{+_LAST_FH} = $io;
  
      return 1;
  }
  
  sub event_tap {
      my ($self, $f, $num) = @_;
  
      my @tap;
  
      # If this IS the first event the plan should come first
      # (plan must be before or after assertions, not in the middle)
      push @tap => $self->plan_tap($f) if $f->{plan} && !$self->{+MADE_ASSERTION};
  
      # The assertion is most important, if present.
      if ($f->{assert}) {
          push @tap => $self->assert_tap($f, $num);
          push @tap => $self->debug_tap($f, $num) unless $f->{assert}->{no_debug} || $f->{assert}->{pass};
      }
  
      # Almost as important as an assertion
      push @tap => $self->error_tap($f) if $f->{errors};
  
      # Now lets see the diagnostics messages
      push @tap => $self->info_tap($f) if $f->{info};
  
      # If this IS NOT the first event the plan should come last
      # (plan must be before or after assertions, not in the middle)
      push @tap => $self->plan_tap($f) if $self->{+MADE_ASSERTION} && $f->{plan};
  
      # Bail out
      push @tap => $self->halt_tap($f) if $f->{control}->{halt};
  
      return @tap if @tap;
      return @tap if $f->{control}->{halt};
      return @tap if grep { $f->{$_} } qw/assert plan info errors/;
  
      # Use the summary as a fallback if nothing else is usable.
      return $self->summary_tap($f, $num);
  }
  
  sub error_tap {
      my $self = shift;
      my ($f) = @_;
  
      my $IO = ($f->{amnesty} && @{$f->{amnesty}}) ? OUT_STD : OUT_ERR;
  
      return map {
          my $details = $_->{details};
  
          my $msg;
          if (ref($details)) {
              require Data::Dumper;
              my $dumper = Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);
              chomp($msg = $dumper->Dump);
          }
          else {
              chomp($msg = $details);
              $msg =~ s/^/# /;
              $msg =~ s/\n/\n# /g;
          }
  
          [$IO, "$msg\n"];
      } @{$f->{errors}};
  }
  
  sub plan_tap {
      my $self = shift;
      my ($f) = @_;
      my $plan = $f->{plan} or return;
  
      return if $plan->{none};
  
      if ($plan->{skip}) {
          my $reason = $plan->{details} or return [OUT_STD, "1..0 # SKIP\n"];
          chomp($reason);
          return [OUT_STD, '1..0 # SKIP ' . $reason . "\n"];
      }
  
      return [OUT_STD, "1.." . $plan->{count} . "\n"];
  }
  
  sub no_subtest_space { 0 }
  sub assert_tap {
      my $self = shift;
      my ($f, $num) = @_;
  
      my $assert = $f->{assert} or return;
      my $pass = $assert->{pass};
      my $name = $assert->{details};
  
      my $ok = $pass ? 'ok' : 'not ok';
      $ok .= " $num" if $num && !$self->{+NO_NUMBERS};
  
      # The regex form is ~250ms, the index form is ~50ms
      my @extra;
      defined($name) && (
          (index($name, "\n") != -1 && (($name, @extra) = split(/\n\r?/, $name, -1))),
          ((index($name, "#" ) != -1  || substr($name, -1) eq '\\') && (($name =~ s|\\|\\\\|g), ($name =~ s|#|\\#|g)))
      );
  
      my $extra_space = @extra ? ' ' x (length($ok) + 2) : '';
      my $extra_indent = '';
  
      my ($directives, $reason, $is_skip);
      if ($f->{amnesty}) {
          my %directives;
  
          for my $am (@{$f->{amnesty}}) {
              next if $am->{inherited};
              my $tag = $am->{tag} or next;
              $is_skip = 1 if $tag eq 'skip';
  
              $directives{$tag} ||= $am->{details};
          }
  
          my %seen;
          my @order = grep { !$seen{$_}++ } sort keys %directives;
  
          $directives = ' # ' . join ' & ' => @order;
  
          for my $tag ('skip', @order) {
              next unless defined($directives{$tag}) && length($directives{$tag});
              $reason = $directives{$tag};
              last;
          }
      }
  
      $ok .= " - $name" if defined $name && !($is_skip && !$name);
  
      my @subtap;
      if ($f->{parent} && $f->{parent}->{buffered}) {
          $ok .= ' {';
  
          # In a verbose harness we indent the extra since they will appear
          # inside the subtest braces. This helps readability. In a non-verbose
          # harness we do not do this because it is less readable.
          if ($ENV{HARNESS_IS_VERBOSE} || !$ENV{HARNESS_ACTIVE}) {
              $extra_indent = "    ";
              $extra_space = ' ';
          }
  
          # Render the sub-events, we use our own counter for these.
          my $count = 0;
          @subtap = map {
              my $f2 = $_;
  
              # Bump the count for any event that should bump it.
              $count++ if $f2->{assert};
  
              # This indents all output lines generated for the sub-events.
              # index 0 is the filehandle, index 1 is the message we want to indent.
              map { $_->[1] =~ s/^(.*\S.*)$/    $1/mg; $_ } $self->event_tap($f2, $count);
          } @{$f->{parent}->{children}};
  
          push @subtap => [OUT_STD, "}\n"];
      }
  
      if ($directives) {
          $directives = ' # TODO & SKIP' if $directives eq ' # TODO & skip';
          $ok .= $directives;
          $ok .= " $reason" if defined($reason);
      }
  
      $extra_space = ' ' if $self->no_subtest_space;
  
      my @out = ([OUT_STD, "$ok\n"]);
      push @out => map {[OUT_STD, "${extra_indent}#${extra_space}$_\n"]} @extra if @extra;
      push @out => @subtap;
  
      return @out;
  }
  
  sub debug_tap {
      my ($self, $f, $num) = @_;
  
      # Figure out the debug info, this is typically the file name and line
      # number, but can also be a custom message. If no trace object is provided
      # then we have nothing useful to display.
      my $name  = $f->{assert}->{details};
      my $trace = $f->{trace};
  
      my $debug = "[No trace info available]";
      if ($trace->{details}) {
          $debug = $trace->{details};
      }
      elsif ($trace->{frame}) {
          my ($pkg, $file, $line) = @{$trace->{frame}};
          $debug = "at $file line $line." if $file && $line;
      }
  
      my $amnesty = $f->{amnesty} && @{$f->{amnesty}}
          ? ' (with amnesty)'
          : '';
  
      # Create the initial diagnostics. If the test has a name we put the debug
      # info on a second line, this behavior is inherited from Test::Builder.
      my $msg = defined($name)
          ? qq[# Failed test${amnesty} '$name'\n# $debug\n]
          : qq[# Failed test${amnesty} $debug\n];
  
      my $IO = $f->{amnesty} && @{$f->{amnesty}} ? OUT_STD : OUT_ERR;
  
      return [$IO, $msg];
  }
  
  sub halt_tap {
      my ($self, $f) = @_;
  
      return if $f->{trace}->{nested} && !$f->{trace}->{buffered};
      my $details = $f->{control}->{details};
  
      return [OUT_STD, "Bail out!\n"] unless defined($details) && length($details);
      return [OUT_STD, "Bail out!  $details\n"];
  }
  
  sub info_tap {
      my ($self, $f) = @_;
  
      return map {
          my $details = $_->{details};
  
          my $IO = $_->{debug} && !($f->{amnesty} && @{$f->{amnesty}}) ? OUT_ERR : OUT_STD;
  
          my $msg;
          if (ref($details)) {
              require Data::Dumper;
              my $dumper = Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);
              chomp($msg = $dumper->Dump);
          }
          else {
              chomp($msg = $details);
              $msg =~ s/^/# /;
              $msg =~ s/\n/\n# /g;
          }
  
          [$IO, "$msg\n"];
      } @{$f->{info}};
  }
  
  sub summary_tap {
      my ($self, $f, $num) = @_;
  
      return if $f->{about}->{no_display};
  
      my $summary = $f->{about}->{details} or return;
      chomp($summary);
      $summary =~ s/^/# /smg;
  
      return [OUT_STD, "$summary\n"];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Formatter::TAP - Standard TAP formatter
  
  =head1 DESCRIPTION
  
  This is what takes events and turns them into TAP.
  
  =head1 SYNOPSIS
  
      use Test2::Formatter::TAP;
      my $tap = Test2::Formatter::TAP->new();
  
      # Switch to utf8
      $tap->encoding('utf8');
  
      $tap->write($event, $number); # Output an event
  
  =head1 METHODS
  
  =over 4
  
  =item $bool = $tap->no_numbers
  
  =item $tap->set_no_numbers($bool)
  
  Use to turn numbers on and off.
  
  =item $arrayref = $tap->handles
  
  =item $tap->set_handles(\@handles);
  
  Can be used to get/set the filehandles. Indexes are identified by the
  C<OUT_STD> and C<OUT_ERR> constants.
  
  =item $encoding = $tap->encoding
  
  =item $tap->encoding($encoding)
  
  Get or set the encoding. By default no encoding is set, the original settings
  of STDOUT and STDERR are used.
  
  This directly modifies the stored filehandles, it does not create new ones.
  
  =item $tap->write($e, $num)
  
  Write an event to the console.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_FORMATTER_TAP

$fatpacked{"Test2/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB';
  package Test2::Hub;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/carp croak confess/;
  use Test2::Util qw/get_tid gen_uid/;
  
  use Scalar::Util qw/weaken/;
  use List::Util qw/first/;
  
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util::HashBase qw{
      pid tid hid ipc
      nested buffered
      no_ending
      _filters
      _pre_filters
      _listeners
      _follow_ups
      _formatter
      _context_acquire
      _context_init
      _context_release
  
      uuid
      active
      count
      failed
      ended
      bailed_out
      _passing
      _plan
      skip_reason
  };
  
  my $UUID_VIA;
  
  sub init {
      my $self = shift;
  
      $self->{+PID} = $$;
      $self->{+TID} = get_tid();
      $self->{+HID} = gen_uid();
  
      $UUID_VIA ||= Test2::API::_add_uuid_via_ref();
      $self->{+UUID} = ${$UUID_VIA}->('hub') if $$UUID_VIA;
  
      $self->{+NESTED}   = 0 unless defined $self->{+NESTED};
      $self->{+BUFFERED} = 0 unless defined $self->{+BUFFERED};
  
      $self->{+COUNT}    = 0;
      $self->{+FAILED}   = 0;
      $self->{+_PASSING} = 1;
  
      if (my $formatter = delete $self->{formatter}) {
          $self->format($formatter);
      }
  
      if (my $ipc = $self->{+IPC}) {
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub is_subtest { 0 }
  
  sub _tb_reset {
      my $self = shift;
  
      # Nothing to do
      return if $self->{+PID} == $$ && $self->{+TID} == get_tid();
  
      $self->{+PID} = $$;
      $self->{+TID} = get_tid();
      $self->{+HID} = gen_uid();
  
      if (my $ipc = $self->{+IPC}) {
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub reset_state {
      my $self = shift;
  
      $self->{+COUNT} = 0;
      $self->{+FAILED} = 0;
      $self->{+_PASSING} = 1;
  
      delete $self->{+_PLAN};
      delete $self->{+ENDED};
      delete $self->{+BAILED_OUT};
      delete $self->{+SKIP_REASON};
  }
  
  sub inherit {
      my $self = shift;
      my ($from, %params) = @_;
  
      $self->{+NESTED} ||= 0;
  
      $self->{+_FORMATTER} = $from->{+_FORMATTER}
          unless $self->{+_FORMATTER} || exists($params{formatter});
  
      if ($from->{+IPC} && !$self->{+IPC} && !exists($params{ipc})) {
          my $ipc = $from->{+IPC};
          $self->{+IPC} = $ipc;
          $ipc->add_hub($self->{+HID});
      }
  
      if (my $ls = $from->{+_LISTENERS}) {
          push @{$self->{+_LISTENERS}} => grep { $_->{inherit} } @$ls;
      }
  
      if (my $pfs = $from->{+_PRE_FILTERS}) {
          push @{$self->{+_PRE_FILTERS}} => grep { $_->{inherit} } @$pfs;
      }
  
      if (my $fs = $from->{+_FILTERS}) {
          push @{$self->{+_FILTERS}} => grep { $_->{inherit} } @$fs;
      }
  }
  
  sub format {
      my $self = shift;
  
      my $old = $self->{+_FORMATTER};
      ($self->{+_FORMATTER}) = @_ if @_;
  
      return $old;
  }
  
  sub is_local {
      my $self = shift;
      return $$ == $self->{+PID}
          && get_tid() == $self->{+TID};
  }
  
  sub listen {
      my $self = shift;
      my ($sub, %params) = @_;
  
      carp "Useless addition of a listener in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "listen only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_LISTENERS}} => { %params, code => $sub };
  
      $sub; # Intentional return.
  }
  
  sub unlisten {
      my $self = shift;
  
      carp "Useless removal of a listener in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      my %subs = map {$_ => $_} @_;
  
      @{$self->{+_LISTENERS}} = grep { !$subs{$_->{code}} } @{$self->{+_LISTENERS}};
  }
  
  sub filter {
      my $self = shift;
      my ($sub, %params) = @_;
  
      carp "Useless addition of a filter in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "filter only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_FILTERS}} => { %params, code => $sub };
  
      $sub; # Intentional Return
  }
  
  sub unfilter {
      my $self = shift;
      carp "Useless removal of a filter in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
      my %subs = map {$_ => $_} @_;
      @{$self->{+_FILTERS}} = grep { !$subs{$_->{code}} } @{$self->{+_FILTERS}};
  }
  
  sub pre_filter {
      my $self = shift;
      my ($sub, %params) = @_;
  
      croak "pre_filter only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_PRE_FILTERS}} => { %params, code => $sub };
  
      $sub; # Intentional Return
  }
  
  sub pre_unfilter {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_PRE_FILTERS}} = grep { !$subs{$_->{code}} } @{$self->{+_PRE_FILTERS}};
  }
  
  sub follow_up {
      my $self = shift;
      my ($sub) = @_;
  
      carp "Useless addition of a follow-up in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "follow_up only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_FOLLOW_UPS}} => $sub;
  }
  
  *add_context_aquire = \&add_context_acquire;
  sub add_context_acquire {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_acquire only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_ACQUIRE}} => $sub;
  
      $sub; # Intentional return.
  }
  
  *remove_context_aquire = \&remove_context_acquire;
  sub remove_context_acquire {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_ACQUIRE}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_ACQUIRE}};
  }
  
  sub add_context_init {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_init only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_INIT}} => $sub;
  
      $sub; # Intentional return.
  }
  
  sub remove_context_init {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_INIT}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_INIT}};
  }
  
  sub add_context_release {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_release only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_RELEASE}} => $sub;
  
      $sub; # Intentional return.
  }
  
  sub remove_context_release {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_RELEASE}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_RELEASE}};
  }
  
  sub send {
      my $self = shift;
      my ($e) = @_;
  
      $e->eid;
  
      $e->add_hub(
          {
              details => ref($self),
  
              buffered => $self->{+BUFFERED},
              hid      => $self->{+HID},
              nested   => $self->{+NESTED},
              pid      => $self->{+PID},
              tid      => $self->{+TID},
              uuid     => $self->{+UUID},
  
              ipc => $self->{+IPC} ? 1 : 0,
          }
      );
  
      $e->set_uuid(${$UUID_VIA}->('event')) if $$UUID_VIA;
  
      if ($self->{+_PRE_FILTERS}) {
          for (@{$self->{+_PRE_FILTERS}}) {
              $e = $_->{code}->($self, $e);
              return unless $e;
          }
      }
  
      my $ipc = $self->{+IPC} || return $self->process($e);
  
      if($e->global) {
          $ipc->send($self->{+HID}, $e, 'GLOBAL');
          return $self->process($e);
      }
  
      return $ipc->send($self->{+HID}, $e)
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      $self->process($e);
  }
  
  sub process {
      my $self = shift;
      my ($e) = @_;
  
      if ($self->{+_FILTERS}) {
          for (@{$self->{+_FILTERS}}) {
              $e = $_->{code}->($self, $e);
              return unless $e;
          }
      }
  
      # Optimize the most common case
      my $type = ref($e);
      if ($type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass})) {
          my $count = ++($self->{+COUNT});
          $self->{+_FORMATTER}->write($e, $count) if $self->{+_FORMATTER};
  
          if ($self->{+_LISTENERS}) {
              $_->{code}->($self, $e, $count) for @{$self->{+_LISTENERS}};
          }
  
          return $e;
      }
  
      my $f = $e->facet_data;
  
      my $fail = 0;
      $fail = 1 if $f->{assert} && !$f->{assert}->{pass};
      $fail = 1 if $f->{errors} && grep { $_->{fail} } @{$f->{errors}};
      $fail = 0 if $f->{amnesty};
  
      $self->{+COUNT}++ if $f->{assert};
      $self->{+FAILED}++ if $fail && $f->{assert};
      $self->{+_PASSING} = 0 if $fail;
  
      my $code = $f->{control}->{terminate};
      my $count = $self->{+COUNT};
  
      if (my $plan = $f->{plan}) {
          if ($plan->{skip}) {
              $self->plan('SKIP');
              $self->set_skip_reason($plan->{details} || 1);
              $code ||= 0;
          }
          elsif ($plan->{none}) {
              $self->plan('NO PLAN');
          }
          else {
              $self->plan($plan->{count});
          }
      }
  
      $e->callback($self) if $f->{control}->{has_callback};
  
      $self->{+_FORMATTER}->write($e, $count, $f) if $self->{+_FORMATTER};
  
      if ($self->{+_LISTENERS}) {
          $_->{code}->($self, $e, $count, $f) for @{$self->{+_LISTENERS}};
      }
  
      if ($f->{control}->{halt}) {
          $code ||= 255;
          $self->set_bailed_out($e);
      }
  
      if (defined $code) {
          $self->{+_FORMATTER}->terminate($e, $f) if $self->{+_FORMATTER};
          $self->terminate($code, $e, $f);
      }
  
      return $e;
  }
  
  sub terminate {
      my $self = shift;
      my ($code) = @_;
      exit($code);
  }
  
  sub cull {
      my $self = shift;
  
      my $ipc = $self->{+IPC} || return;
      return if $self->{+PID} != $$ || $self->{+TID} != get_tid();
  
      # No need to do IPC checks on culled events
      $self->process($_) for $ipc->cull($self->{+HID});
  }
  
  sub finalize {
      my $self = shift;
      my ($trace, $do_plan) = @_;
  
      $self->cull();
  
      my $plan   = $self->{+_PLAN};
      my $count  = $self->{+COUNT};
      my $failed = $self->{+FAILED};
      my $active = $self->{+ACTIVE};
  
      # return if NOTHING was done.
      unless ($active || $do_plan || defined($plan) || $count || $failed) {
          $self->{+_FORMATTER}->finalize($plan, $count, $failed, 0, $self->is_subtest) if $self->{+_FORMATTER};
          return;
      }
  
      unless ($self->{+ENDED}) {
          if ($self->{+_FOLLOW_UPS}) {
              $_->($trace, $self) for reverse @{$self->{+_FOLLOW_UPS}};
          }
  
          # These need to be refreshed now
          $plan   = $self->{+_PLAN};
          $count  = $self->{+COUNT};
          $failed = $self->{+FAILED};
  
          if (($plan && $plan eq 'NO PLAN') || ($do_plan && !$plan)) {
              $self->send(
                  Test2::Event::Plan->new(
                      trace => $trace,
                      max => $count,
                  )
              );
          }
          $plan = $self->{+_PLAN};
      }
  
      my $frame = $trace->frame;
      if($self->{+ENDED}) {
          my (undef, $ffile, $fline) = @{$self->{+ENDED}};
          my (undef, $sfile, $sline) = @$frame;
  
          die <<"        EOT"
  Test already ended!
  First End:  $ffile line $fline
  Second End: $sfile line $sline
          EOT
      }
  
      $self->{+ENDED} = $frame;
      my $pass = $self->is_passing(); # Generate the final boolean.
  
      $self->{+_FORMATTER}->finalize($plan, $count, $failed, $pass, $self->is_subtest) if $self->{+_FORMATTER};
  
      return $pass;
  }
  
  sub is_passing {
      my $self = shift;
  
      ($self->{+_PASSING}) = @_ if @_;
  
      # If we already failed just return 0.
      my $pass = $self->{+_PASSING} or return 0;
      return $self->{+_PASSING} = 0 if $self->{+FAILED};
  
      my $count = $self->{+COUNT};
      my $ended = $self->{+ENDED};
      my $plan = $self->{+_PLAN};
  
      return $pass if !$count && $plan && $plan =~ m/^SKIP$/;
  
      return $self->{+_PASSING} = 0
          if $ended && (!$count || !$plan);
  
      return $pass unless $plan && $plan =~ m/^\d+$/;
  
      if ($ended) {
          return $self->{+_PASSING} = 0 if $count != $plan;
      }
      else {
          return $self->{+_PASSING} = 0 if $count > $plan;
      }
  
      return $pass;
  }
  
  sub plan {
      my $self = shift;
  
      return $self->{+_PLAN} unless @_;
  
      my ($plan) = @_;
  
      confess "You cannot unset the plan"
          unless defined $plan;
  
      confess "You cannot change the plan"
          if $self->{+_PLAN} && $self->{+_PLAN} !~ m/^NO PLAN$/;
  
      confess "'$plan' is not a valid plan! Plan must be an integer greater than 0, 'NO PLAN', or 'SKIP'"
          unless $plan =~ m/^(\d+|NO PLAN|SKIP)$/;
  
      $self->{+_PLAN} = $plan;
  }
  
  sub check_plan {
      my $self = shift;
  
      return undef unless $self->{+ENDED};
      my $plan = $self->{+_PLAN} || return undef;
  
      return 1 if $plan !~ m/^\d+$/;
  
      return 1 if $plan == $self->{+COUNT};
      return 0;
  }
  
  sub DESTROY {
      my $self = shift;
      my $ipc = $self->{+IPC} || return;
      return unless $$ == $self->{+PID};
      return unless get_tid() == $self->{+TID};
      $ipc->drop_hub($self->{+HID});
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub - The conduit through which all events flow.
  
  =head1 SYNOPSIS
  
      use Test2::Hub;
  
      my $hub = Test2::Hub->new();
      $hub->send(...);
  
  =head1 DESCRIPTION
  
  The hub is the place where all events get processed and handed off to the
  formatter. The hub also tracks test state, and provides several hooks into the
  event pipeline.
  
  =head1 COMMON TASKS
  
  =head2 SENDING EVENTS
  
      $hub->send($event)
  
  The C<send()> method is used to issue an event to the hub. This method will
  handle thread/fork sync, filters, listeners, TAP output, etc.
  
  =head2 ALTERING OR REMOVING EVENTS
  
  You can use either C<filter()> or C<pre_filter()>, depending on your
  needs. Both have identical syntax, so only C<filter()> is shown here.
  
      $hub->filter(sub {
          my ($hub, $event) = @_;
  
          my $action = get_action($event);
  
          # No action should be taken
          return $event if $action eq 'none';
  
          # You want your filter to remove the event
          return undef if $action eq 'delete';
  
          if ($action eq 'do_it') {
              my $new_event = copy_event($event);
              ... Change your copy of the event ...
              return $new_event;
          }
  
          die "Should not happen";
      });
  
  By default, filters are not inherited by child hubs. That means if you start a
  subtest, the subtest will not inherit the filter. You can change this behavior
  with the C<inherit> parameter:
  
      $hub->filter(sub { ... }, inherit => 1);
  
  =head2 LISTENING FOR EVENTS
  
      $hub->listen(sub {
          my ($hub, $event, $number) = @_;
  
          ... do whatever you want with the event ...
  
          # return is ignored
      });
  
  By default listeners are not inherited by child hubs. That means if you start a
  subtest, the subtest will not inherit the listener. You can change this behavior
  with the C<inherit> parameter:
  
      $hub->listen(sub { ... }, inherit => 1);
  
  
  =head2 POST-TEST BEHAVIORS
  
      $hub->follow_up(sub {
          my ($trace, $hub) = @_;
  
          ... do whatever you need to ...
  
          # Return is ignored
      });
  
  follow_up subs are called only once, either when done_testing is called, or in
  an END block.
  
  =head2 SETTING THE FORMATTER
  
  By default an instance of L<Test2::Formatter::TAP> is created and used.
  
      my $old = $hub->format(My::Formatter->new);
  
  Setting the formatter will REPLACE any existing formatter. You may set the
  formatter to undef to prevent output. The old formatter will be returned if one
  was already set. Only one formatter is allowed at a time.
  
  =head1 METHODS
  
  =over 4
  
  =item $hub->send($event)
  
  This is where all events enter the hub for processing.
  
  =item $hub->process($event)
  
  This is called by send after it does any IPC handling. You can use this to
  bypass the IPC process, but in general you should avoid using this.
  
  =item $old = $hub->format($formatter)
  
  Replace the existing formatter instance with a new one. Formatters must be
  objects that implement a C<< $formatter->write($event) >> method.
  
  =item $sub = $hub->listen(sub { ... }, %optional_params)
  
  You can use this to record all events AFTER they have been sent to the
  formatter. No changes made here will be meaningful, except possibly to other
  listeners.
  
      $hub->listen(sub {
          my ($hub, $event, $number) = @_;
  
          ... do whatever you want with the event ...
  
          # return is ignored
      });
  
  Normally listeners are not inherited by child hubs such as subtests. You can
  add the C<< inherit => 1 >> parameter to allow a listener to be inherited.
  
  =item $hub->unlisten($sub)
  
  You can use this to remove a listen callback. You must pass in the coderef
  returned by the C<listen()> method.
  
  =item $sub = $hub->filter(sub { ... }, %optional_params)
  
  =item $sub = $hub->pre_filter(sub { ... }, %optional_params)
  
  These can be used to add filters. Filters can modify, replace, or remove events
  before anything else can see them.
  
      $hub->filter(
          sub {
              my ($hub, $event) = @_;
  
              return $event;    # No Changes
              return;           # Remove the event
  
              # Or you can modify an event before returning it.
              $event->modify;
              return $event;
          }
      );
  
  If you are not using threads, forking, or IPC then the only difference between
  a C<filter> and a C<pre_filter> is that C<pre_filter> subs run first. When you
  are using threads, forking, or IPC, pre_filters happen to events before they
  are sent to their destination proc/thread, ordinary filters happen only in the
  destination hub/thread.
  
  You cannot add a regular filter to a hub if the hub was created in another
  process or thread. You can always add a pre_filter.
  
  =item $hub->unfilter($sub)
  
  =item $hub->pre_unfilter($sub)
  
  These can be used to remove filters and pre_filters. The C<$sub> argument is
  the reference returned by C<filter()> or C<pre_filter()>.
  
  =item $hub->follow_op(sub { ... })
  
  Use this to add behaviors that are called just before the hub is finalized. The
  only argument to your codeblock will be a L<Test2::EventFacet::Trace> instance.
  
      $hub->follow_up(sub {
          my ($trace, $hub) = @_;
  
          ... do whatever you need to ...
  
          # Return is ignored
      });
  
  follow_up subs are called only once, ether when done_testing is called, or in
  an END block.
  
  =item $sub = $hub->add_context_acquire(sub { ... });
  
  Add a callback that will be called every time someone tries to acquire a
  context. It gets a single argument, a reference of the hash of parameters
  being used the construct the context. This is your chance to change the
  parameters by directly altering the hash.
  
      test2_add_callback_context_acquire(sub {
          my $params = shift;
          $params->{level}++;
      });
  
  This is a very scary API function. Please do not use this unless you need to.
  This is here for L<Test::Builder> and backwards compatibility. This has you
  directly manipulate the hash instead of returning a new one for performance
  reasons.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_acquire($sub);
  
  This can be used to remove a context acquire hook.
  
  =item $sub = $hub->add_context_init(sub { ... });
  
  This allows you to add callbacks that will trigger every time a new context is
  created for the hub. The only argument to the sub will be the
  L<Test2::API::Context> instance that was created.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_init($sub);
  
  This can be used to remove a context init hook.
  
  =item $sub = $hub->add_context_release(sub { ... });
  
  This allows you to add callbacks that will trigger every time a context for
  this hub is released. The only argument to the sub will be the
  L<Test2::API::Context> instance that was released. These will run in reverse
  order.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_release($sub);
  
  This can be used to remove a context release hook.
  
  =item $hub->cull()
  
  Cull any IPC events (and process them).
  
  =item $pid = $hub->pid()
  
  Get the process id under which the hub was created.
  
  =item $tid = $hub->tid()
  
  Get the thread id under which the hub was created.
  
  =item $hud = $hub->hid()
  
  Get the identifier string of the hub.
  
  =item $uuid = $hub->uuid()
  
  If UUID tagging is enabled (see L<Test2::API>) then the hub will have a UUID.
  
  =item $ipc = $hub->ipc()
  
  Get the IPC object used by the hub.
  
  =item $hub->set_no_ending($bool)
  
  =item $bool = $hub->no_ending
  
  This can be used to disable auto-ending behavior for a hub. The auto-ending
  behavior is triggered by an end block and is used to cull IPC events, and
  output the final plan if the plan was 'no_plan'.
  
  =item $bool = $hub->active
  
  =item $hub->set_active($bool)
  
  These are used to get/set the 'active' attribute. When true this attribute will
  force C<< hub->finalize() >> to take action even if there is no plan, and no
  tests have been run. This flag is useful for plugins that add follow-up
  behaviors that need to run even if no events are seen.
  
  =back
  
  =head2 STATE METHODS
  
  =over 4
  
  =item $hub->reset_state()
  
  Reset all state to the start. This sets the test count to 0, clears the plan,
  removes the failures, etc.
  
  =item $num = $hub->count
  
  Get the number of tests that have been run.
  
  =item $num = $hub->failed
  
  Get the number of failures (Not all failures come from a test fail, so this
  number can be larger than the count).
  
  =item $bool = $hub->ended
  
  True if the testing has ended. This MAY return the stack frame of the tool that
  ended the test, but that is not guaranteed.
  
  =item $bool = $hub->is_passing
  
  =item $hub->is_passing($bool)
  
  Check if the overall test run is a failure. Can also be used to set the
  pass/fail status.
  
  =item $hub->plan($plan)
  
  =item $plan = $hub->plan
  
  Get or set the plan. The plan must be an integer larger than 0, the string
  'no_plan', or the string 'skip_all'.
  
  =item $bool = $hub->check_plan
  
  Check if the plan and counts match, but only if the tests have ended. If tests
  have not ended this will return undef, otherwise it will be a true/false.
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB

$fatpacked{"Test2/Hub/Interceptor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR';
  package Test2::Hub::Interceptor;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::Hub::Interceptor::Terminator();
  
  BEGIN { require Test2::Hub; our @ISA = qw(Test2::Hub) }
  use Test2::Util::HashBase;
  
  sub init {
      my $self = shift;
      $self->SUPER::init();
      $self->{+NESTED} = 0;
  }
  
  sub inherit {
      my $self = shift;
      my ($from, %params) = @_;
  
      $self->{+NESTED} = 0;
  
      if ($from->{+IPC} && !$self->{+IPC} && !exists($params{ipc})) {
          my $ipc = $from->{+IPC};
          $self->{+IPC} = $ipc;
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub terminate {
      my $self = shift;
      my ($code) = @_;
  
      eval {
          no warnings 'exiting';
          last T2_SUBTEST_WRAPPER;
      };
      my $err = $@;
  
      # Fallback
      die bless(\$err, 'Test2::Hub::Interceptor::Terminator');
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Interceptor - Hub used by interceptor to grab results.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_INTERCEPTOR

$fatpacked{"Test2/Hub/Interceptor/Terminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR_TERMINATOR';
  package Test2::Hub::Interceptor::Terminator;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Interceptor::Terminator - Exception class used by
  Test2::Hub::Interceptor
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_INTERCEPTOR_TERMINATOR

$fatpacked{"Test2/Hub/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_SUBTEST';
  package Test2::Hub::Subtest;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Hub; our @ISA = qw(Test2::Hub) }
  use Test2::Util::HashBase qw/nested exit_code manual_skip_all/;
  use Test2::Util qw/get_tid/;
  
  sub is_subtest { 1 }
  
  sub inherit {
      my $self = shift;
      my ($from) = @_;
  
      $self->SUPER::inherit($from);
  
      $self->{+NESTED} = $from->nested + 1;
  }
  
  {
      # Legacy
      no warnings 'once';
      *ID = \&Test2::Hub::HID;
      *id = \&Test2::Hub::hid;
      *set_id = \&Test2::Hub::set_hid;
  }
  
  sub send {
      my $self = shift;
      my ($e) = @_;
  
      my $out = $self->SUPER::send($e);
  
      return $out if $self->{+MANUAL_SKIP_ALL};
  
      my $f = $e->facet_data;
  
      my $plan = $f->{plan} or return $out;
      return $out unless $plan->{skip};
  
      my $trace = $f->{trace} or die "Missing Trace!";
      return $out unless $trace->{pid} != $self->pid
                      || $trace->{tid} != $self->tid;
  
      no warnings 'exiting';
      last T2_SUBTEST_WRAPPER;
  }
  
  sub terminate {
      my $self = shift;
      my ($code, $e, $f) = @_;
      $self->set_exit_code($code);
  
      return if $self->{+MANUAL_SKIP_ALL};
  
      $f ||= $e->facet_data;
  
      if(my $plan = $f->{plan}) {
          my $trace = $f->{trace} or die "Missing Trace!";
          return if $plan->{skip}
                 && ($trace->{pid} != $$ || $trace->{tid} != get_tid);
      }
  
      no warnings 'exiting';
      last T2_SUBTEST_WRAPPER;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Subtest - Hub used by subtests
  
  =head1 DESCRIPTION
  
  Subtests make use of this hub to route events.
  
  =head1 TOGGLES
  
  =over 4
  
  =item $bool = $hub->manual_skip_all
  
  =item $hub->set_manual_skip_all($bool)
  
  The default is false.
  
  Normally a skip-all plan event will cause a subtest to stop executing. This is
  accomplished via C<last LABEL> to a label inside the subtest code. Most of the
  time this is perfectly fine. There are times however where this flow control
  causes bad things to happen.
  
  This toggle lets you turn off the abort logic for the hub. When this is toggled
  to true B<you> are responsible for ensuring no additional events are generated.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_SUBTEST

$fatpacked{"Test2/IPC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC';
  package Test2::IPC;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::API::Instance;
  use Test2::Util qw/get_tid/;
  use Test2::API qw{
      test2_init_done
      test2_ipc
      test2_has_ipc
      test2_ipc_enable_polling
      test2_pid
      test2_stack
      test2_tid
      context
  };
  
  use Carp qw/confess/;
  
  our @EXPORT_OK = qw/cull/;
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub unimport { Test2::API::test2_ipc_disable() }
  
  sub import {
      goto &Exporter::import if test2_has_ipc || !test2_init_done();
  
      confess "IPC is disabled" if Test2::API::test2_ipc_disabled();
      confess "Cannot add IPC in a child process (" . test2_pid() . " vs $$)" if test2_pid() != $$;
      confess "Cannot add IPC in a child thread (" . test2_tid() . " vs " . get_tid() . ")"  if test2_tid() != get_tid();
  
      Test2::API::_set_ipc(_make_ipc());
      apply_ipc(test2_stack());
  
      goto &Exporter::import;
  }
  
  sub _make_ipc {
      # Find a driver
      my ($driver) = Test2::API::test2_ipc_drivers();
      unless ($driver) {
          require Test2::IPC::Driver::Files;
          $driver = 'Test2::IPC::Driver::Files';
      }
  
      return $driver->new();
  }
  
  sub apply_ipc {
      my $stack = shift;
  
      my ($root) = @$stack;
  
      return unless $root;
  
      confess "Cannot add IPC in a child process" if $root->pid != $$;
      confess "Cannot add IPC in a child thread"  if $root->tid != get_tid();
  
      my $ipc = $root->ipc || test2_ipc() || _make_ipc();
  
      # Add the IPC to all hubs
      for my $hub (@$stack) {
          my $has = $hub->ipc;
          confess "IPC Mismatch!" if $has && $has != $ipc;
          next if $has;
          $hub->set_ipc($ipc);
          $ipc->add_hub($hub->hid);
      }
  
      test2_ipc_enable_polling();
  
      return $ipc;
  }
  
  sub cull {
      my $ctx = context();
      $ctx->hub->cull;
      $ctx->release;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC - Turn on IPC for threading or forking support.
  
  =head1 SYNOPSIS
  
  You should C<use Test2::IPC;> as early as possible in your test file. If you
  import this module after API initialization it will attempt to retrofit IPC
  onto the existing hubs.
  
  =head2 DISABLING IT
  
  You can use C<no Test2::IPC;> to disable IPC for good. You can also use the
  T2_NO_IPC env var.
  
  =head1 EXPORTS
  
  All exports are optional.
  
  =over 4
  
  =item cull()
  
  Cull allows you to collect results from other processes or threads on demand.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC

$fatpacked{"Test2/IPC/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER';
  package Test2::IPC::Driver;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/confess/;
  use Test2::Util::HashBase qw{no_fatal no_bail};
  
  use Test2::API qw/test2_ipc_add_driver/;
  
  my %ADDED;
  sub import {
      my $class = shift;
      return if $class eq __PACKAGE__;
      return if $ADDED{$class}++;
      test2_ipc_add_driver($class);
  }
  
  sub use_shm { 0 }
  
  for my $meth (qw/send cull add_hub drop_hub waiting is_viable/) {
      no strict 'refs';
      *$meth = sub {
          my $thing = shift;
          confess "'$thing' did not define the required method '$meth'."
      };
  }
  
  # Print the error and call exit. We are not using 'die' cause this is a
  # catastrophic error that should never be caught. If we get here it
  # means some serious shit has happened in a child process, the only way
  # to inform the parent may be to exit false.
  
  sub abort {
      my $self = shift;
      chomp(my ($msg) = @_);
  
      $self->driver_abort($msg) if $self->can('driver_abort');
  
      print STDERR "IPC Fatal Error: $msg\n";
      print STDOUT "Bail out! IPC Fatal Error: $msg\n" unless $self->no_bail;
  
      CORE::exit(255) unless $self->no_fatal;
  }
  
  sub abort_trace {
      my $self = shift;
      my ($msg) = @_;
      # Older versions of Carp do not export longmess() function, so it needs to be called with package name
      $self->abort(Carp::longmess($msg));
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC::Driver - Base class for Test2 IPC drivers.
  
  =head1 SYNOPSIS
  
      package Test2::IPC::Driver::MyDriver;
  
      use base 'Test2::IPC::Driver';
  
      ...
  
  =head1 METHODS
  
  =over 4
  
  =item $self->abort($msg)
  
  If an IPC encounters a fatal error it should use this. This will print the
  message to STDERR with C<'IPC Fatal Error: '> prefixed to it, then it will
  forcefully exit 255. IPC errors may occur in threads or processes other than
  the main one, this method provides the best chance of the harness noticing the
  error.
  
  =item $self->abort_trace($msg)
  
  This is the same as C<< $ipc->abort($msg) >> except that it uses
  C<Carp::longmess> to add a stack trace to the message.
  
  =item $false = $self->use_shm
  
  The base class always returns false for this method. You may override it if you
  wish to use the SHM made available in L<Test2::API>/L<Test2::API::Instance>.
  
  =back
  
  =head1 LOADING DRIVERS
  
  Test2::IPC::Driver has an C<import()> method. All drivers inherit this import
  method. This import method registers the driver.
  
  In most cases you just need to load the desired IPC driver to make it work. You
  should load this driver as early as possible. A warning will be issued if you
  load it too late for it to be effective.
  
      use Test2::IPC::Driver::MyDriver;
      ...
  
  =head1 WRITING DRIVERS
  
      package Test2::IPC::Driver::MyDriver;
      use strict;
      use warnings;
  
      use base 'Test2::IPC::Driver';
  
      sub is_viable {
          return 0 if $^O eq 'win32'; # Will not work on windows.
          return 1;
      }
  
      sub add_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Make it possible to contact the hub
      }
  
      sub drop_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Nothing should try to reach the hub anymore.
      }
  
      sub send {
          my $self = shift;
          my ($hid, $e, $global) = @_;
  
          ... # Send the event to the proper hub.
  
          # If you are using the SHM you should notify other procs/threads that
          # there is a pending event.
          Test2::API::test2_ipc_set_pending($uniq_val);
      }
  
      sub cull {
          my $self = shift;
          my ($hid) = @_;
  
          my @events = ...; # Here is where you get the events for the hub
  
          return @events;
      }
  
      sub waiting {
          my $self = shift;
  
          ... # Notify all listening procs and threads that the main
          ... # process/thread is waiting for them to finish.
      }
  
      1;
  
  =head2 METHODS SUBCLASSES MUST IMPLEMENT
  
  =over 4
  
  =item $ipc->is_viable
  
  This should return true if the driver works in the current environment. This
  should return false if it does not. This is a CLASS method.
  
  =item $ipc->add_hub($hid)
  
  This is used to alert the driver that a new hub is expecting events. The driver
  should keep track of the process and thread ids, the hub should only be dropped
  by the proc+thread that started it.
  
      sub add_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Make it possible to contact the hub
      }
  
  =item $ipc->drop_hub($hid)
  
  This is used to alert the driver that a hub is no longer accepting events. The
  driver should keep track of the process and thread ids, the hub should only be
  dropped by the proc+thread that started it (This is the drivers responsibility
  to enforce).
  
      sub drop_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Nothing should try to reach the hub anymore.
      }
  
  =item $ipc->send($hid, $event);
  
  =item $ipc->send($hid, $event, $global);
  
  Used to send events from the current process/thread to the specified hub in its
  process+thread.
  
      sub send {
          my $self = shift;
          my ($hid, $e) = @_;
  
          ... # Send the event to the proper hub.
  
          # If you are using the SHM you should notify other procs/threads that
          # there is a pending event.
          Test2::API::test2_ipc_set_pending($uniq_val);
      }
  
  If C<$global> is true then the driver should send the event to all hubs in all
  processes and threads.
  
  =item @events = $ipc->cull($hid)
  
  Used to collect events that have been sent to the specified hub.
  
      sub cull {
          my $self = shift;
          my ($hid) = @_;
  
          my @events = ...; # Here is where you get the events for the hub
  
          return @events;
      }
  
  =item $ipc->waiting()
  
  This is called in the parent process when it is complete and waiting for all
  child processes and threads to complete.
  
      sub waiting {
          my $self = shift;
  
          ... # Notify all listening procs and threads that the main
          ... # process/thread is waiting for them to finish.
      }
  
  =back
  
  =head2 METHODS SUBCLASSES MAY IMPLEMENT OR OVERRIDE
  
  =over 4
  
  =item $ipc->driver_abort($msg)
  
  This is a hook called by C<< Test2::IPC::Driver->abort() >>. This is your
  chance to cleanup when an abort happens. You cannot prevent the abort, but you
  can gracefully except it.
  
  =item $bool = $ipc->use_shm()
  
  True if you want to make use of the L<Test2::API>/L<Test2::API::Instance> SHM.
  
  =item $bites = $ipc->shm_size()
  
  Use this to customize the size of the SHM space. There are no guarantees about
  what the size will be if you do not implement this.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC_DRIVER

$fatpacked{"Test2/IPC/Driver/Files.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER_FILES';
  package Test2::IPC::Driver::Files;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::IPC::Driver; our @ISA = qw(Test2::IPC::Driver) }
  
  use Test2::Util::HashBase qw{tempdir event_ids read_ids timeouts tid pid globals};
  
  use Scalar::Util qw/blessed/;
  use File::Temp();
  use Storable();
  use File::Spec();
  use POSIX();
  
  use Test2::Util qw/try get_tid pkg_to_file IS_WIN32 ipc_separator do_rename do_unlink try_sig_mask/;
  use Test2::API qw/test2_ipc_set_pending/;
  
  sub use_shm { 1 }
  sub shm_size() { 64 }
  
  sub is_viable { 1 }
  
  sub init {
      my $self = shift;
  
      my $tmpdir = File::Temp::tempdir(
          $ENV{T2_TEMPDIR_TEMPLATE} || "test2" . ipc_separator . $$ . ipc_separator . "XXXXXX",
          CLEANUP => 0,
          TMPDIR => 1,
      );
  
      $self->abort_trace("Could not get a temp dir") unless $tmpdir;
  
      $self->{+TEMPDIR} = File::Spec->canonpath($tmpdir);
  
      print STDERR "\nIPC Temp Dir: $tmpdir\n\n"
          if $ENV{T2_KEEP_TEMPDIR};
  
      $self->{+EVENT_IDS} = {};
      $self->{+READ_IDS} = {};
      $self->{+TIMEOUTS} = {};
  
      $self->{+TID} = get_tid();
      $self->{+PID} = $$;
  
      $self->{+GLOBALS} = {};
  
      return $self;
  }
  
  sub hub_file {
      my $self = shift;
      my ($hid) = @_;
      my $tdir = $self->{+TEMPDIR};
      return File::Spec->catfile($tdir, "HUB" . ipc_separator . $hid);
  }
  
  sub event_file {
      my $self = shift;
      my ($hid, $e) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
      my $type = blessed($e) or $self->abort("'$e' is not a blessed object!");
  
      $self->abort("'$e' is not an event object!")
          unless $type->isa('Test2::Event');
  
      my $tid = get_tid();
      my $eid = $self->{+EVENT_IDS}->{$hid}->{$$}->{$tid} += 1;
  
      my @type = split '::', $type;
      my $name = join(ipc_separator, $hid, $$, $tid, $eid, @type);
  
      return File::Spec->catfile($tempdir, $name);
  }
  
  sub add_hub {
      my $self = shift;
      my ($hid) = @_;
  
      my $hfile = $self->hub_file($hid);
  
      $self->abort_trace("File for hub '$hid' already exists")
          if -e $hfile;
  
      open(my $fh, '>', $hfile) or $self->abort_trace("Could not create hub file '$hid': $!");
      print $fh "$$\n" . get_tid() . "\n";
      close($fh);
  }
  
  sub drop_hub {
      my $self = shift;
      my ($hid) = @_;
  
      my $tdir = $self->{+TEMPDIR};
      my $hfile = $self->hub_file($hid);
  
      $self->abort_trace("File for hub '$hid' does not exist")
          unless -e $hfile;
  
      open(my $fh, '<', $hfile) or $self->abort_trace("Could not open hub file '$hid': $!");
      my ($pid, $tid) = <$fh>;
      close($fh);
  
      $self->abort_trace("A hub file can only be closed by the process that started it\nExpected $pid, got $$")
          unless $pid == $$;
  
      $self->abort_trace("A hub file can only be closed by the thread that started it\nExpected $tid, got " . get_tid())
          unless get_tid() == $tid;
  
      if ($ENV{T2_KEEP_TEMPDIR}) {
          my ($ok, $err) = do_rename($hfile, File::Spec->canonpath("$hfile.complete"));
          $self->abort_trace("Could not rename file '$hfile' -> '$hfile.complete': $err") unless $ok
      }
      else {
          my ($ok, $err) = do_unlink($hfile);
          $self->abort_trace("Could not remove file for hub '$hid': $err") unless $ok
      }
  
      opendir(my $dh, $tdir) or $self->abort_trace("Could not open temp dir!");
      for my $file (readdir($dh)) {
          next if $file =~ m{\.complete$};
          next unless $file =~ m{^$hid};
          $self->abort_trace("Not all files from hub '$hid' have been collected!");
      }
      closedir($dh);
  }
  
  sub send {
      my $self = shift;
      my ($hid, $e, $global) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
      my $hfile = $self->hub_file($hid);
      my $dest = $global ? 'GLOBAL' : $hid;
  
      $self->abort(<<"    EOT") unless $global || -f $hfile;
  hub '$hid' is not available, failed to send event!
  
  There was an attempt to send an event to a hub in a parent process or thread,
  but that hub appears to be gone. This can happen if you fork, or start a new
  thread from inside subtest, and the parent finishes the subtest before the
  child returns.
  
  This can also happen if the parent process is done testing before the child
  finishes. Test2 normally waits automatically in the root process, but will not
  do so if Test::Builder is loaded for legacy reasons.
      EOT
  
      my $file = $self->event_file($dest, $e);
      my $ready = File::Spec->canonpath("$file.ready");
  
      if ($global) {
          my $name = $ready;
          $name =~ s{^.*(GLOBAL)}{GLOBAL};
          $self->{+GLOBALS}->{$hid}->{$name}++;
      }
  
      # Write and rename the file.
      my ($ren_ok, $ren_err);
      my ($ok, $err) = try_sig_mask {
          Storable::store($e, $file);
          ($ren_ok, $ren_err) = do_rename("$file", $ready);
      };
  
      if ($ok) {
          $self->abort("Could not rename file '$file' -> '$ready': $ren_err") unless $ren_ok;
          test2_ipc_set_pending(substr($file, -(shm_size)));
      }
      else {
          my $src_file = __FILE__;
          $err =~ s{ at \Q$src_file\E.*$}{};
          chomp($err);
          my $tid = get_tid();
          my $trace = $e->trace->debug;
          my $type = blessed($e);
  
          $self->abort(<<"        EOT");
  
  *******************************************************************************
  There was an error writing an event:
  Destination: $dest
  Origin PID:  $$
  Origin TID:  $tid
  Event Type:  $type
  Event Trace: $trace
  File Name:   $file
  Ready Name:  $ready
  Error: $err
  *******************************************************************************
  
          EOT
      }
  
      return 1;
  }
  
  sub driver_abort {
      my $self = shift;
      my ($msg) = @_;
  
      local ($@, $!, $?, $^E);
      eval {
          my $abort = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
          open(my $fh, '>>', $abort) or die "Could not open abort file: $!";
          print $fh $msg, "\n";
          close($fh) or die "Could not close abort file: $!";
          1;
      } or warn $@;
  }
  
  sub cull {
      my $self = shift;
      my ($hid) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
  
      opendir(my $dh, $tempdir) or $self->abort("could not open IPC temp dir ($tempdir)!");
  
      my $read = $self->{+READ_IDS};
      my $timeouts = $self->{+TIMEOUTS};
  
      my @out;
      for my $info (sort cmp_events map { $self->should_read_event($hid, $_) } readdir($dh)) {
          unless ($info->{global}) {
              my $next = $self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}} ||= 1;
  
              $timeouts->{$info->{file}} ||= time;
  
              if ($next != $info->{eid}) {
                  # Wait up to N seconds for missing events
                  next unless 5 < time - $timeouts->{$info->{file}};
                  $self->abort("Missing event HID: $info->{hid}, PID: $info->{pid}, TID: $info->{tid}, EID: $info->{eid}.");
              }
  
              $self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}} = $info->{eid} + 1;
          }
  
          my $full = $info->{full_path};
          my $obj = $self->read_event_file($full);
          push @out => $obj;
  
          # Do not remove global events
          next if $info->{global};
  
          if ($ENV{T2_KEEP_TEMPDIR}) {
              my $complete = File::Spec->canonpath("$full.complete");
              my ($ok, $err) = do_rename($full, $complete);
              $self->abort("Could not rename IPC file '$full', '$complete': $err") unless $ok;
          }
          else {
              my ($ok, $err) = do_unlink("$full");
              $self->abort("Could not unlink IPC file '$full': $err") unless $ok;
          }
      }
  
      closedir($dh);
      return @out;
  }
  
  sub parse_event_filename {
      my $self = shift;
      my ($file) = @_;
  
      # The || is to force 0 in false
      my $complete = substr($file, -9, 9) eq '.complete' || 0 and substr($file, -9, 9, "");
      my $ready    = substr($file, -6, 6) eq '.ready'    || 0 and substr($file, -6, 6, "");
  
      my @parts = split ipc_separator, $file;
      my ($global, $hid) = $parts[0] eq 'GLOBAL' ? (1, shift @parts) : (0, join ipc_separator, splice(@parts, 0, 4));
      my ($pid, $tid, $eid) = splice(@parts, 0, 3);
      my $type = join '::' => @parts;
  
      return {
          file     => $file,
          ready    => $ready,
          complete => $complete,
          global   => $global,
          type     => $type,
          hid      => $hid,
          pid      => $pid,
          tid      => $tid,
          eid      => $eid,
      };
  }
  
  sub should_read_event {
      my $self = shift;
      my ($hid, $file) = @_;
  
      return if substr($file, 0, 1) eq '.';
      return if substr($file, 0, 3) eq 'HUB';
      CORE::exit(255) if $file eq 'ABORT';
  
      my $parsed = $self->parse_event_filename($file);
  
      return if $parsed->{complete};
      return unless $parsed->{ready};
      return unless $parsed->{global} || $parsed->{hid} eq $hid;
  
      return if $parsed->{global} && $self->{+GLOBALS}->{$hid}->{$file}++;
  
      # Untaint the path.
      my $full = File::Spec->catfile($self->{+TEMPDIR}, $file);
      ($full) = ($full =~ m/^(.*)$/gs) if ${^TAINT};
  
      $parsed->{full_path} = $full;
  
      return $parsed;
  }
  
  sub cmp_events {
      # Globals first
      return -1 if $a->{global} && !$b->{global};
      return  1 if $b->{global} && !$a->{global};
  
      return $a->{pid} <=> $b->{pid}
          || $a->{tid} <=> $b->{tid}
          || $a->{eid} <=> $b->{eid};
  }
  
  sub read_event_file {
      my $self = shift;
      my ($file) = @_;
  
      my $obj = Storable::retrieve($file);
      $self->abort("Got an unblessed object: '$obj'")
          unless blessed($obj);
  
      unless ($obj->isa('Test2::Event')) {
          my $pkg  = blessed($obj);
          my $mod_file = pkg_to_file($pkg);
          my ($ok, $err) = try { require $mod_file };
  
          $self->abort("Event has unknown type ($pkg), tried to load '$mod_file' but failed: $err")
              unless $ok;
  
          $self->abort("'$obj' is not a 'Test2::Event' object")
              unless $obj->isa('Test2::Event');
      }
  
      return $obj;
  }
  
  sub waiting {
      my $self = shift;
      require Test2::Event::Waiting;
      $self->send(
          GLOBAL => Test2::Event::Waiting->new(
              trace => Test2::EventFacet::Trace->new(frame => [caller()]),
          ),
          'GLOBAL'
      );
      return;
  }
  
  sub DESTROY {
      my $self = shift;
  
      return unless defined $self->pid;
      return unless defined $self->tid;
  
      return unless $$        == $self->pid;
      return unless get_tid() == $self->tid;
  
      my $tempdir = $self->{+TEMPDIR};
  
      my $aborted = 0;
      my $abort_file = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
      if (-e $abort_file) {
          $aborted = 1;
          my ($ok, $err) = do_unlink($abort_file);
          warn $err unless $ok;
      }
  
      opendir(my $dh, $tempdir) or $self->abort("Could not open temp dir! ($tempdir)");
      while(my $file = readdir($dh)) {
          next if $file =~ m/^\.+$/;
          next if $file =~ m/\.complete$/;
          my $full = File::Spec->catfile($tempdir, $file);
  
          my $sep = ipc_separator;
          if ($aborted || $file =~ m/^(GLOBAL|HUB$sep)/) {
              $full =~ m/^(.*)$/;
              $full = $1; # Untaint it
              next if $ENV{T2_KEEP_TEMPDIR};
              my ($ok, $err) = do_unlink($full);
              $self->abort("Could not unlink IPC file '$full': $err") unless $ok;
              next;
          }
  
          $self->abort("Leftover files in the directory ($full)!\n");
      }
      closedir($dh);
  
      if ($ENV{T2_KEEP_TEMPDIR}) {
          print STDERR "# Not removing temp dir: $tempdir\n";
          return;
      }
  
      my $abort = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
      unlink($abort) if -e $abort;
      rmdir($tempdir) or warn "Could not remove IPC temp dir ($tempdir)";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC::Driver::Files - Temp dir + Files concurrency model.
  
  =head1 DESCRIPTION
  
  This is the default, and fallback concurrency model for L<Test2>. This
  sends events between processes and threads using serialized files in a
  temporary directory. This is not particularly fast, but it works everywhere.
  
  =head1 SYNOPSIS
  
      use Test2::IPC::Driver::Files;
  
      # IPC is now enabled
  
  =head1 ENVIRONMENT VARIABLES
  
  =over 4
  
  =item T2_KEEP_TEMPDIR=0
  
  When true, the tempdir used by the IPC driver will not be deleted when the test
  is done.
  
  =item T2_TEMPDIR_TEMPLATE='test2-XXXXXX'
  
  This can be used to set the template for the IPC temp dir. The template should
  follow template specifications from L<File::Temp>.
  
  =back
  
  =head1 SEE ALSO
  
  See L<Test2::IPC::Driver> for methods.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC_DRIVER_FILES

$fatpacked{"Test2/Tools/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TINY';
  package Test2::Tools::Tiny;
  use strict;
  use warnings;
  
  BEGIN {
      if ($] lt "5.008") {
          require Test::Builder::IO::Scalar;
      }
  }
  
  use Scalar::Util qw/blessed/;
  
  use Test2::Util qw/try/;
  use Test2::API qw/context run_subtest test2_stack/;
  
  use Test2::Hub::Interceptor();
  use Test2::Hub::Interceptor::Terminator();
  
  our $VERSION = '1.302136';
  
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  our @EXPORT = qw{
      ok is isnt like unlike is_deeply diag note skip_all todo plan done_testing
      warnings exception tests capture
  };
  
  sub ok($;$@) {
      my ($bool, $name, @diag) = @_;
      my $ctx = context();
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub is($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($got) && defined($want)) {
          $bool = "$got" eq "$want";
      }
      elsif (defined($got) xor defined($want)) {
          $bool = 0;
      }
      else {    # Both are undef
          $bool = 1;
      }
  
      return $ctx->pass_and_release($name) if $bool;
  
      $got  = '*NOT DEFINED*' unless defined $got;
      $want = '*NOT DEFINED*' unless defined $want;
      unshift @diag => (
          "GOT:      $got",
          "EXPECTED: $want",
      );
  
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub isnt($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($got) && defined($want)) {
          $bool = "$got" ne "$want";
      }
      elsif (defined($got) xor defined($want)) {
          $bool = 1;
      }
      else {    # Both are undef
          $bool = 0;
      }
  
      return $ctx->pass_and_release($name) if $bool;
  
      unshift @diag => "Strings are the same (they should not be)"
          unless $bool;
  
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub like($$;$@) {
      my ($thing, $pattern, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($thing)) {
          $bool = "$thing" =~ $pattern;
          unshift @diag => (
              "Value: $thing",
              "Does not match: $pattern"
          ) unless $bool;
      }
      else {
          $bool = 0;
          unshift @diag => "Got an undefined value.";
      }
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub unlike($$;$@) {
      my ($thing, $pattern, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($thing)) {
          $bool = "$thing" !~ $pattern;
          unshift @diag => (
              "Unexpected pattern match (it should not match)",
              "Value:   $thing",
              "Matches: $pattern"
          ) unless $bool;
      }
      else {
          $bool = 0;
          unshift @diag => "Got an undefined value.";
      }
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub is_deeply($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      no warnings 'once';
      require Data::Dumper;
  
      # Otherwise numbers might be unquoted
      local $Data::Dumper::Useperl  = 1;
  
      local $Data::Dumper::Sortkeys = 1;
      local $Data::Dumper::Deparse  = 1;
      local $Data::Dumper::Freezer  = 'XXX';
      local *UNIVERSAL::XXX         = sub {
          my ($thing) = @_;
          if (ref($thing)) {
              $thing = {%$thing}  if "$thing" =~ m/=HASH/;
              $thing = [@$thing]  if "$thing" =~ m/=ARRAY/;
              $thing = \"$$thing" if "$thing" =~ m/=SCALAR/;
          }
          $_[0] = $thing;
      };
  
      my $g = Data::Dumper::Dumper($got);
      my $w = Data::Dumper::Dumper($want);
  
      my $bool = $g eq $w;
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, $g, $w, @diag);
  }
  
  sub diag {
      my $ctx = context();
      $ctx->diag(join '', @_);
      $ctx->release;
  }
  
  sub note {
      my $ctx = context();
      $ctx->note(join '', @_);
      $ctx->release;
  }
  
  sub skip_all {
      my ($reason) = @_;
      my $ctx = context();
      $ctx->plan(0, SKIP => $reason);
      $ctx->release if $ctx;
  }
  
  sub todo {
      my ($reason, $sub) = @_;
      my $ctx = context();
  
      # This code is mostly copied from Test2::Todo in the Test2-Suite
      # distribution.
      my $hub    = test2_stack->top;
      my $filter = $hub->pre_filter(
          sub {
              my ($active_hub, $event) = @_;
              if ($active_hub == $hub) {
                  $event->set_todo($reason) if $event->can('set_todo');
                  $event->add_amnesty({tag => 'TODO', details => $reason});
              }
              else {
                  $event->add_amnesty({tag => 'TODO', details => $reason, inherited => 1});
              }
              return $event;
          },
          inherit => 1,
          todo    => $reason,
      );
      $sub->();
      $hub->pre_unfilter($filter);
  
      $ctx->release if $ctx;
  }
  
  sub plan {
      my ($max) = @_;
      my $ctx = context();
      $ctx->plan($max);
      $ctx->release;
  }
  
  sub done_testing {
      my $ctx = context();
      $ctx->done_testing;
      $ctx->release;
  }
  
  sub warnings(&) {
      my $code = shift;
      my @warnings;
      local $SIG{__WARN__} = sub { push @warnings => @_ };
      $code->();
      return \@warnings;
  }
  
  sub exception(&) {
      my $code = shift;
      local ($@, $!, $SIG{__DIE__});
      my $ok = eval { $code->(); 1 };
      my $error = $@ || 'SQUASHED ERROR';
      return $ok ? undef : $error;
  }
  
  sub tests {
      my ($name, $code) = @_;
      my $ctx = context();
  
      my $be = caller->can('before_each');
  
      $be->($name) if $be;
  
      my $bool = run_subtest($name, $code, 1);
  
      $ctx->release;
  
      return $bool;
  }
  
  sub capture(&) {
      my $code = shift;
  
      my ($err, $out) = ("", "");
  
      my $handles = test2_stack->top->format->handles;
      my ($ok, $e);
      {
          my ($out_fh, $err_fh);
  
          ($ok, $e) = try {
            # Scalar refs as filehandles were added in 5.8.
            if ($] ge "5.008") {
              open($out_fh, '>', \$out) or die "Failed to open a temporary STDOUT: $!";
              open($err_fh, '>', \$err) or die "Failed to open a temporary STDERR: $!";
            }
            # Emulate scalar ref filehandles with a tie.
            else {
              $out_fh = Test::Builder::IO::Scalar->new(\$out) or die "Failed to open a temporary STDOUT";
              $err_fh = Test::Builder::IO::Scalar->new(\$err) or die "Failed to open a temporary STDERR";
            }
  
              test2_stack->top->format->set_handles([$out_fh, $err_fh, $out_fh]);
  
              $code->();
          };
      }
      test2_stack->top->format->set_handles($handles);
  
      die $e unless $ok;
  
      $err =~ s/ $/_/mg;
      $out =~ s/ $/_/mg;
  
      return {
          STDOUT => $out,
          STDERR => $err,
      };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Tools::Tiny - Tiny set of tools for unfortunate souls who cannot use
  L<Test2::Suite>.
  
  =head1 DESCRIPTION
  
  You should really look at L<Test2::Suite>. This package is some very basic
  essential tools implemented using L<Test2>. This exists only so that L<Test2>
  and other tools required by L<Test2::Suite> can be tested. This is the package
  L<Test2> uses to test itself.
  
  =head1 USE Test2::Suite INSTEAD
  
  Use L<Test2::Suite> if at all possible.
  
  =head1 EXPORTS
  
  =over 4
  
  =item ok($bool, $name)
  
  =item ok($bool, $name, @diag)
  
  Run a simple assertion.
  
  =item is($got, $want, $name)
  
  =item is($got, $want, $name, @diag)
  
  Assert that 2 strings are the same.
  
  =item isnt($got, $do_not_want, $name)
  
  =item isnt($got, $do_not_want, $name, @diag)
  
  Assert that 2 strings are not the same.
  
  =item like($got, $regex, $name)
  
  =item like($got, $regex, $name, @diag)
  
  Check that the input string matches the regex.
  
  =item unlike($got, $regex, $name)
  
  =item unlike($got, $regex, $name, @diag)
  
  Check that the input string does not match the regex.
  
  =item is_deeply($got, $want, $name)
  
  =item is_deeply($got, $want, $name, @diag)
  
  Check 2 data structures. Please note that this is a I<DUMB> implementation that
  compares the output of L<Data::Dumper> against both structures.
  
  =item diag($msg)
  
  Issue a diagnostics message to STDERR.
  
  =item note($msg)
  
  Issue a diagnostics message to STDOUT.
  
  =item skip_all($reason)
  
  Skip all tests.
  
  =item todo $reason => sub { ... }
  
  Run a block in TODO mode.
  
  =item plan($count)
  
  Set the plan.
  
  =item done_testing()
  
  Set the plan to the current test count.
  
  =item $warnings = warnings { ... }
  
  Capture an arrayref of warnings from the block.
  
  =item $exception = exception { ... }
  
  Capture an exception.
  
  =item tests $name => sub { ... }
  
  Run a subtest.
  
  =item $output = capture { ... }
  
  Capture STDOUT and STDERR output.
  
  Result looks like this:
  
      {
          STDOUT => "...",
          STDERR => "...",
      }
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_TOOLS_TINY

$fatpacked{"Test2/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL';
  package Test2::Util;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use POSIX();
  use Config qw/%Config/;
  use Carp qw/croak/;
  
  BEGIN {
      local ($@, $!, $SIG{__DIE__});
      *HAVE_PERLIO = eval { require PerlIO; PerlIO->VERSION(1.02); } ? sub() { 1 } : sub() { 0 };
  }
  
  our @EXPORT_OK = qw{
      try
  
      pkg_to_file
  
      get_tid USE_THREADS
      CAN_THREAD
      CAN_REALLY_FORK
      CAN_FORK
  
      CAN_SIGSYS
  
      IS_WIN32
  
      ipc_separator
  
      gen_uid
  
      do_rename do_unlink
  
      try_sig_mask
  
      clone_io
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  BEGIN {
      *IS_WIN32 = ($^O eq 'MSWin32') ? sub() { 1 } : sub() { 0 };
  }
  
  sub _can_thread {
      return 0 unless $] >= 5.008001;
      return 0 unless $Config{'useithreads'};
  
      # Threads are broken on perl 5.10.0 built with gcc 4.8+
      if ($] == 5.010000 && $Config{'ccname'} eq 'gcc' && $Config{'gccversion'}) {
          my @parts = split /\./, $Config{'gccversion'};
          return 0 if $parts[0] > 4 || ($parts[0] == 4 && $parts[1] >= 8);
      }
  
      # Change to a version check if this ever changes
      return 0 if $INC{'Devel/Cover.pm'};
      return 1;
  }
  
  sub _can_fork {
      return 1 if $Config{d_fork};
      return 0 unless IS_WIN32 || $^O eq 'NetWare';
      return 0 unless $Config{useithreads};
      return 0 unless $Config{ccflags} =~ /-DPERL_IMPLICIT_SYS/;
  
      return _can_thread();
  }
  
  BEGIN {
      no warnings 'once';
      *CAN_THREAD      = _can_thread()   ? sub() { 1 } : sub() { 0 };
  }
  my $can_fork;
  sub CAN_FORK () {
      return $can_fork
          if defined $can_fork;
      $can_fork = !!_can_fork();
      no warnings 'redefine';
      *CAN_FORK = $can_fork ? sub() { 1 } : sub() { 0 };
      $can_fork;
  }
  my $can_really_fork;
  sub CAN_REALLY_FORK () {
      return $can_really_fork
          if defined $can_really_fork;
      $can_really_fork = !!$Config{d_fork};
      no warnings 'redefine';
      *CAN_REALLY_FORK = $can_really_fork ? sub() { 1 } : sub() { 0 };
      $can_really_fork;
  }
  
  sub _manual_try(&;@) {
      my $code = shift;
      my $args = \@_;
      my $err;
  
      my $die = delete $SIG{__DIE__};
  
      eval { $code->(@$args); 1 } or $err = $@ || "Error was squashed!\n";
  
      $die ? $SIG{__DIE__} = $die : delete $SIG{__DIE__};
  
      return (!defined($err), $err);
  }
  
  sub _local_try(&;@) {
      my $code = shift;
      my $args = \@_;
      my $err;
  
      no warnings;
      local $SIG{__DIE__};
      eval { $code->(@$args); 1 } or $err = $@ || "Error was squashed!\n";
  
      return (!defined($err), $err);
  }
  
  # Older versions of perl have a nasty bug on win32 when localizing a variable
  # before forking or starting a new thread. So for those systems we use the
  # non-local form. When possible though we use the faster 'local' form.
  BEGIN {
      if (IS_WIN32 && $] < 5.020002) {
          *try = \&_manual_try;
      }
      else {
          *try = \&_local_try;
      }
  }
  
  BEGIN {
      if (CAN_THREAD) {
          if ($INC{'threads.pm'}) {
              # Threads are already loaded, so we do not need to check if they
              # are loaded each time
              *USE_THREADS = sub() { 1 };
              *get_tid     = sub() { threads->tid() };
          }
          else {
              # :-( Need to check each time to see if they have been loaded.
              *USE_THREADS = sub() { $INC{'threads.pm'} ? 1 : 0 };
              *get_tid     = sub() { $INC{'threads.pm'} ? threads->tid() : 0 };
          }
      }
      else {
          # No threads, not now, not ever!
          *USE_THREADS = sub() { 0 };
          *get_tid     = sub() { 0 };
      }
  }
  
  sub pkg_to_file {
      my $pkg = shift;
      my $file = $pkg;
      $file =~ s{(::|')}{/}g;
      $file .= '.pm';
      return $file;
  }
  
  sub ipc_separator() { "~" }
  
  my $UID = 1;
  sub gen_uid() { join ipc_separator() => ($$, get_tid(), time, $UID++) }
  
  sub _check_for_sig_sys {
      my $sig_list = shift;
      return $sig_list =~ m/\bSYS\b/;
  }
  
  BEGIN {
      if (_check_for_sig_sys($Config{sig_name})) {
          *CAN_SIGSYS = sub() { 1 };
      }
      else {
          *CAN_SIGSYS = sub() { 0 };
      }
  }
  
  my %PERLIO_SKIP = (
      unix => 1,
      via  => 1,
  );
  
  sub clone_io {
      my ($fh) = @_;
      my $fileno = fileno($fh);
  
      return $fh if !defined($fileno) || !length($fileno) || $fileno < 0;
  
      open(my $out, '>&' . $fileno) or die "Can't dup fileno $fileno: $!";
  
      my %seen;
      my @layers = HAVE_PERLIO ? grep { !$PERLIO_SKIP{$_} and !$seen{$_}++ } PerlIO::get_layers($fh) : ();
      binmode($out, join(":", "", "raw", @layers));
  
      my $old = select $fh;
      my $af  = $|;
      select $out;
      $| = $af;
      select $old;
  
      return $out;
  }
  
  BEGIN {
      if (IS_WIN32) {
          my $max_tries = 5;
  
          *do_rename = sub {
              my ($from, $to) = @_;
  
              my $err;
              for (1 .. $max_tries) {
                  return (1) if rename($from, $to);
                  $err = "$!";
                  last if $_ == $max_tries;
                  sleep 1;
              }
  
              return (0, $err);
          };
          *do_unlink = sub {
              my ($file) = @_;
  
              my $err;
              for (1 .. $max_tries) {
                  return (1) if unlink($file);
                  $err = "$!";
                  last if $_ == $max_tries;
                  sleep 1;
              }
  
              return (0, "$!");
          };
      }
      else {
          *do_rename = sub {
              my ($from, $to) = @_;
              return (1) if rename($from, $to);
              return (0, "$!");
          };
          *do_unlink = sub {
              my ($file) = @_;
              return (1) if unlink($file);
              return (0, "$!");
          };
      }
  }
  
  sub try_sig_mask(&) {
      my $code = shift;
  
      my ($old, $blocked);
      unless(IS_WIN32) {
          my $to_block = POSIX::SigSet->new(
              POSIX::SIGINT(),
              POSIX::SIGALRM(),
              POSIX::SIGHUP(),
              POSIX::SIGTERM(),
              POSIX::SIGUSR1(),
              POSIX::SIGUSR2(),
          );
          $old = POSIX::SigSet->new;
          $blocked = POSIX::sigprocmask(POSIX::SIG_BLOCK(), $to_block, $old);
          # Silently go on if we failed to log signals, not much we can do.
      }
  
      my ($ok, $err) = &try($code);
  
      # If our block was successful we want to restore the old mask.
      POSIX::sigprocmask(POSIX::SIG_SETMASK(), $old, POSIX::SigSet->new()) if defined $blocked;
  
      return ($ok, $err);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util - Tools used by Test2 and friends.
  
  =head1 DESCRIPTION
  
  Collection of tools used by L<Test2> and friends.
  
  =head1 EXPORTS
  
  All exports are optional. You must specify subs to import.
  
  =over 4
  
  =item ($success, $error) = try { ... }
  
  Eval the codeblock, return success or failure, and the error message. This code
  protects $@ and $!, they will be restored by the end of the run. This code also
  temporarily blocks $SIG{DIE} handlers.
  
  =item protect { ... }
  
  Similar to try, except that it does not catch exceptions. The idea here is to
  protect $@ and $! from changes. $@ and $! will be restored to whatever they
  were before the run so long as it is successful. If the run fails $! will still
  be restored, but $@ will contain the exception being thrown.
  
  =item CAN_FORK
  
  True if this system is capable of true or pseudo-fork.
  
  =item CAN_REALLY_FORK
  
  True if the system can really fork. This will be false for systems where fork
  is emulated.
  
  =item CAN_THREAD
  
  True if this system is capable of using threads.
  
  =item USE_THREADS
  
  Returns true if threads are enabled, false if they are not.
  
  =item get_tid
  
  This will return the id of the current thread when threads are enabled,
  otherwise it returns 0.
  
  =item my $file = pkg_to_file($package)
  
  Convert a package name to a filename.
  
  =item $string = ipc_separator()
  
  Get the IPC separator. Currently this is always the string C<'~'>.
  
  =item $string = gen_uid()
  
  Generate a unique id (NOT A UUID). This will typically be the process id, the
  thread id, the time, and an incrementing integer all joined with the
  C<ipc_separator()>.
  
  These ID's are unique enough for most purposes. For identical ids to be
  generated you must have 2 processes with the same PID generate IDs at the same
  time with the same current state of the incrementing integer. This is a
  perfectly reasonable thing to expect to happen across multiple machines, but is
  quite unlikely to happen on one machine.
  
  This can fail to be unique if a process generates an id, calls exec, and does
  it again after the exec and it all happens in less than a second. It can also
  happen if the systems process id's cycle in less than a second allowing 2
  different programs that use this generator to run with the same PID in less
  than a second. Both these cases are sufficiently unlikely. If you need
  universally unique ids, or ids that are unique in these conditions, look at
  L<Data::UUID>.
  
  =item ($ok, $err) = do_rename($old_name, $new_name)
  
  Rename a file, this wraps C<rename()> in a way that makes it more reliable
  cross-platform when trying to rename files you recently altered.
  
  =item ($ok, $err) = do_unlink($filename)
  
  Unlink a file, this wraps C<unlink()> in a way that makes it more reliable
  cross-platform when trying to unlink files you recently altered.
  
  =item ($ok, $err) = try_sig_mask { ... }
  
  Complete an action with several signals masked, they will be unmasked at the
  end allowing any signals that were intercepted to get handled.
  
  This is primarily used when you need to make several actions atomic (against
  some signals anyway).
  
  Signals that are intercepted:
  
  =over 4
  
  =item SIGINT
  
  =item SIGALRM
  
  =item SIGHUP
  
  =item SIGTERM
  
  =item SIGUSR1
  
  =item SIGUSR2
  
  =back
  
  =back
  
  =head1 NOTES && CAVEATS
  
  =over 4
  
  =item 5.10.0
  
  Perl 5.10.0 has a bug when compiled with newer gcc versions. This bug causes a
  segfault whenever a new thread is launched. Test2 will attempt to detect
  this, and note that the system is not capable of forking when it is detected.
  
  =item Devel::Cover
  
  Devel::Cover does not support threads. CAN_THREAD will return false if
  Devel::Cover is loaded before the check is first run.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL

$fatpacked{"Test2/Util/ExternalMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_EXTERNALMETA';
  package Test2::Util::ExternalMeta;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/croak/;
  
  sub META_KEY() { '_meta' }
  
  our @EXPORT = qw/meta set_meta get_meta delete_meta/;
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub set_meta {
      my $self = shift;
      my ($key, $value) = @_;
  
      validate_key($key);
  
      $self->{+META_KEY} ||= {};
      $self->{+META_KEY}->{$key} = $value;
  }
  
  sub get_meta {
      my $self = shift;
      my ($key) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY} or return undef;
      return $meta->{$key};
  }
  
  sub delete_meta {
      my $self = shift;
      my ($key) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY} or return undef;
      delete $meta->{$key};
  }
  
  sub meta {
      my $self = shift;
      my ($key, $default) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY};
      return undef unless $meta || defined($default);
  
      unless($meta) {
          $meta = {};
          $self->{+META_KEY} = $meta;
      }
  
      $meta->{$key} = $default
          if defined($default) && !defined($meta->{$key});
  
      return $meta->{$key};
  }
  
  sub validate_key {
      my $key = shift;
  
      return if $key && !ref($key);
  
      my $render_key = defined($key) ? "'$key'" : 'undef';
      croak "Invalid META key: $render_key, keys must be true, and may not be references";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::ExternalMeta - Allow third party tools to safely attach meta-data
  to your instances.
  
  =head1 DESCRIPTION
  
  This package lets you define a clear, and consistent way to allow third party
  tools to attach meta-data to your instances. If your object consumes this
  package, and imports its methods, then third party meta-data has a safe place
  to live.
  
  =head1 SYNOPSIS
  
      package My::Object;
      use strict;
      use warnings;
  
      use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  
      ...
  
  Now to use it:
  
      my $inst = My::Object->new;
  
      $inst->set_meta(foo => 'bar');
      my $val = $inst->get_meta('foo');
  
  =head1 WHERE IS THE DATA STORED?
  
  This package assumes your instances are blessed hashrefs, it will not work if
  that is not true. It will store all meta-data in the C<_meta> key on your
  objects hash. If your object makes use of the C<_meta> key in its underlying
  hash, then there is a conflict and you cannot use this package.
  
  =head1 EXPORTS
  
  =over 4
  
  =item $val = $obj->meta($key)
  
  =item $val = $obj->meta($key, $default)
  
  This will get the value for a specified meta C<$key>. Normally this will return
  C<undef> when there is no value for the C<$key>, however you can specify a
  C<$default> value to set when no value is already set.
  
  =item $val = $obj->get_meta($key)
  
  This will get the value for a specified meta C<$key>. This does not have the
  C<$default> overhead that C<meta()> does.
  
  =item $val = $obj->delete_meta($key)
  
  This will remove the value of a specified meta C<$key>. The old C<$val> will be
  returned.
  
  =item $obj->set_meta($key, $val)
  
  Set the value of a specified meta C<$key>.
  
  =back
  
  =head1 META-KEY RESTRICTIONS
  
  Meta keys must be defined, and must be true when used as a boolean. Keys may
  not be references. You are free to stringify a reference C<"$ref"> for use as a
  key, but this package will not stringify it for you.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_EXTERNALMETA

$fatpacked{"Test2/Util/Facets2Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_FACETS2LEGACY';
  package Test2::Util::Facets2Legacy;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/croak confess/;
  use Scalar::Util qw/blessed/;
  
  use base 'Exporter';
  our @EXPORT_OK = qw{
      causes_fail
      diagnostics
      global
      increments_count
      no_display
      sets_plan
      subtest_id
      summary
      terminate
      uuid
  };
  our %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  our $CYCLE_DETECT = 0;
  sub _get_facet_data {
      my $in = shift;
  
      if (blessed($in) && $in->isa('Test2::Event')) {
          confess "Cycle between Facets2Legacy and $in\->facet_data() (Did you forget to override the facet_data() method?)"
              if $CYCLE_DETECT;
  
          local $CYCLE_DETECT = 1;
          return $in->facet_data;
      }
  
      return $in if ref($in) eq 'HASH';
  
      croak "'$in' Does not appear to be either a Test::Event or an EventFacet hashref";
  }
  
  sub causes_fail {
      my $facet_data = _get_facet_data(shift @_);
  
      return 1 if $facet_data->{errors} && grep { $_->{fail} } @{$facet_data->{errors}};
  
      if (my $control = $facet_data->{control}) {
          return 1 if $control->{halt};
          return 1 if $control->{terminate};
      }
  
      return 0 if $facet_data->{amnesty} && @{$facet_data->{amnesty}};
      return 1 if $facet_data->{assert} && !$facet_data->{assert}->{pass};
      return 0;
  }
  
  sub diagnostics {
      my $facet_data = _get_facet_data(shift @_);
      return 1 if $facet_data->{errors} && @{$facet_data->{errors}};
      return 0 unless $facet_data->{info} && @{$facet_data->{info}};
      return (grep { $_->{debug} } @{$facet_data->{info}}) ? 1 : 0;
  }
  
  sub global {
      my $facet_data = _get_facet_data(shift @_);
      return 0 unless $facet_data->{control};
      return $facet_data->{control}->{global};
  }
  
  sub increments_count {
      my $facet_data = _get_facet_data(shift @_);
      return $facet_data->{assert} ? 1 : 0;
  }
  
  sub no_display {
      my $facet_data = _get_facet_data(shift @_);
      return 0 unless $facet_data->{about};
      return $facet_data->{about}->{no_display};
  }
  
  sub sets_plan {
      my $facet_data = _get_facet_data(shift @_);
      my $plan = $facet_data->{plan} or return;
      my @out = ($plan->{count} || 0);
  
      if ($plan->{skip}) {
          push @out => 'SKIP';
          push @out => $plan->{details} if defined $plan->{details};
      }
      elsif ($plan->{none}) {
          push @out => 'NO PLAN'
      }
  
      return @out;
  }
  
  sub subtest_id {
      my $facet_data = _get_facet_data(shift @_);
      return undef unless $facet_data->{parent};
      return $facet_data->{parent}->{hid};
  }
  
  sub summary {
      my $facet_data = _get_facet_data(shift @_);
      return '' unless $facet_data->{about} && $facet_data->{about}->{details};
      return $facet_data->{about}->{details};
  }
  
  sub terminate {
      my $facet_data = _get_facet_data(shift @_);
      return undef unless $facet_data->{control};
      return $facet_data->{control}->{terminate};
  }
  
  sub uuid {
      my $in = shift;
  
      if ($CYCLE_DETECT) {
          if (blessed($in) && $in->isa('Test2::Event')) {
              my $meth = $in->can('uuid');
              $meth = $in->can('SUPER::uuid') if $meth == \&uuid;
              my $uuid = $in->$meth if $meth && $meth != \&uuid;
              return $uuid if $uuid;
          }
  
          return undef;
      }
  
      my $facet_data = _get_facet_data($in);
      return $facet_data->{about}->{uuid} if $facet_data->{about} && $facet_data->{about}->{uuid};
  
      return undef;
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::Facets2Legacy - Convert facet data to the legacy event API.
  
  =head1 DESCRIPTION
  
  This module exports several subroutines from the older event API (see
  L<Test2::Event>). These subroutines can be used as methods on any object that
  provides a custom C<facet_data()> method. These subroutines can also be used as
  functions that take a facet data hashref as arguments.
  
  =head1 SYNOPSIS
  
  =head2 AS METHODS
  
      package My::Event;
  
      use Test2::Util::Facets2Legacy ':ALL';
  
      sub facet_data { return { ... } }
  
  Then to use it:
  
      my $e = My::Event->new(...);
  
      my $causes_fail = $e->causes_fail;
      my $summary     = $e->summary;
      ....
  
  =head2 AS FUNCTIONS
  
      use Test2::Util::Facets2Legacy ':ALL';
  
      my $f = {
          assert => { ... },
          info => [{...}, ...],
          control => {...},
          ...
      };
  
      my $causes_fail = causes_fail($f);
      my $summary     = summary($f);
  
  =head1 NOTE ON CYCLES
  
  When used as methods, all these subroutines call C<< $e->facet_data() >>. The
  default C<facet_data()> method in L<Test2::Event> relies on the legacy methods
  this module emulates in order to work. As a result of this it is very easy to
  create infinite recursion bugs.
  
  These methods have cycle detection and will throw an exception early if a cycle
  is detected. C<uuid()> is currently the only subroutine in this library that
  has a fallback behavior when cycles are detected.
  
  =head1 EXPORTS
  
  Nothing is exported by default. You must specify which methods to import, or
  use the ':ALL' tag.
  
  =over 4
  
  =item $bool = $e->causes_fail()
  
  =item $bool = causes_fail($f)
  
  Check if the event or facets result in a failing state.
  
  =item $bool = $e->diagnostics()
  
  =item $bool = diagnostics($f)
  
  Check if the event or facets contain any diagnostics information.
  
  =item $bool = $e->global()
  
  =item $bool = global($f)
  
  Check if the event or facets need to be globally processed.
  
  =item $bool = $e->increments_count()
  
  =item $bool = increments_count($f)
  
  Check if the event or facets make an assertion.
  
  =item $bool = $e->no_display()
  
  =item $bool = no_display($f)
  
  Check if the event or facets should be rendered or hidden.
  
  =item ($max, $directive, $reason) = $e->sets_plan()
  
  =item ($max, $directive, $reason) = sets_plan($f)
  
  Check if the event or facets set a plan, and return the plan details.
  
  =item $id = $e->subtest_id()
  
  =item $id = subtest_id($f)
  
  Get the subtest id, if any.
  
  =item $string = $e->summary()
  
  =item $string = summary($f)
  
  Get the summary of the event or facets hash, if any.
  
  =item $undef_or_int = $e->terminate()
  
  =item $undef_or_int = terminate($f)
  
  Check if the event or facets should result in process termination, if so the
  exit code is returned (which could be 0). undef is returned if no termination
  is requested.
  
  =item $uuid = $e->uuid()
  
  =item $uuid = uuid($f)
  
  Get the UUID of the facets or event.
  
  B<Note:> This will fall back to C<< $e->SUPER::uuid() >> if a cycle is
  detected and an event is used as the argument.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_FACETS2LEGACY

$fatpacked{"Test2/Util/HashBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_HASHBASE';
  package Test2::Util::HashBase;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  #################################################################
  #                                                               #
  #  This is a generated file! Do not modify this file directly!  #
  #  Use hashbase_inc.pl script to regenerate this file.          #
  #  The script is part of the Object::HashBase distribution.     #
  #  Note: You can modify the version number above this comment   #
  #  if needed, that is fine.                                     #
  #                                                               #
  #################################################################
  
  {
      no warnings 'once';
      $Test2::Util::HashBase::HB_VERSION = '0.006';
      *Test2::Util::HashBase::ATTR_SUBS = \%Object::HashBase::ATTR_SUBS;
      *Test2::Util::HashBase::ATTR_LIST = \%Object::HashBase::ATTR_LIST;
      *Test2::Util::HashBase::VERSION   = \%Object::HashBase::VERSION;
      *Test2::Util::HashBase::CAN_CACHE = \%Object::HashBase::CAN_CACHE;
  }
  
  
  require Carp;
  {
      no warnings 'once';
      $Carp::Internal{+__PACKAGE__} = 1;
  }
  
  BEGIN {
      # these are not strictly equivalent, but for out use we don't care
      # about order
      *_isa = ($] >= 5.010 && require mro) ? \&mro::get_linear_isa : sub {
          no strict 'refs';
          my @packages = ($_[0]);
          my %seen;
          for my $package (@packages) {
              push @packages, grep !$seen{$_}++, @{"$package\::ISA"};
          }
          return \@packages;
      }
  }
  
  my %STRIP = (
      '^' => 1,
      '-' => 1,
  );
  
  sub import {
      my $class = shift;
      my $into  = caller;
  
      # Make sure we list the OLDEST version used to create this class.
      my $ver = $Test2::Util::HashBase::HB_VERSION || $Test2::Util::HashBase::VERSION;
      $Test2::Util::HashBase::VERSION{$into} = $ver if !$Test2::Util::HashBase::VERSION{$into} || $Test2::Util::HashBase::VERSION{$into} > $ver;
  
      my $isa = _isa($into);
      my $attr_list = $Test2::Util::HashBase::ATTR_LIST{$into} ||= [];
      my $attr_subs = $Test2::Util::HashBase::ATTR_SUBS{$into} ||= {};
  
      my %subs = (
          ($into->can('new') ? () : (new => \&_new)),
          (map %{$Test2::Util::HashBase::ATTR_SUBS{$_} || {}}, @{$isa}[1 .. $#$isa]),
          (
              map {
                  my $p = substr($_, 0, 1);
                  my $x = $_;
                  substr($x, 0, 1) = '' if $STRIP{$p};
                  push @$attr_list => $x;
                  my ($sub, $attr) = (uc $x, $x);
                  $sub => ($attr_subs->{$sub} = sub() { $attr }),
                      $attr => sub { $_[0]->{$attr} },
                        $p eq '-' ? ("set_$attr" => sub { Carp::croak("'$attr' is read-only") })
                      : $p eq '^' ? ("set_$attr" => sub { Carp::carp("set_$attr() is deprecated"); $_[0]->{$attr} = $_[1] })
                      : ("set_$attr" => sub { $_[0]->{$attr} = $_[1] }),
              } @_
          ),
      );
  
      no strict 'refs';
      *{"$into\::$_"} = $subs{$_} for keys %subs;
  }
  
  sub attr_list {
      my $class = shift;
  
      my $isa = _isa($class);
  
      my %seen;
      my @list = grep { !$seen{$_}++ } map {
          my @out;
  
          if (0.004 > ($Test2::Util::HashBase::VERSION{$_} || 0)) {
              Carp::carp("$_ uses an inlined version of Test2::Util::HashBase too old to support attr_list()");
          }
          else {
              my $list = $Test2::Util::HashBase::ATTR_LIST{$_};
              @out = $list ? @$list : ()
          }
  
          @out;
      } reverse @$isa;
  
      return @list;
  }
  
  sub _new {
      my $class = shift;
  
      my $self;
  
      if (@_ == 1) {
          my $arg = shift;
          my $type = ref($arg);
  
          if ($type eq 'HASH') {
              $self = bless({%$arg}, $class)
          }
          else {
              Carp::croak("Not sure what to do with '$type' in $class constructor")
                  unless $type eq 'ARRAY';
  
              my %proto;
              my @attributes = attr_list($class);
              while (@$arg) {
                  my $val = shift @$arg;
                  my $key = shift @attributes or Carp::croak("Too many arguments for $class constructor");
                  $proto{$key} = $val;
              }
  
              $self = bless(\%proto, $class);
          }
      }
      else {
          $self = bless({@_}, $class);
      }
  
      $Test2::Util::HashBase::CAN_CACHE{$class} = $self->can('init')
          unless exists $Test2::Util::HashBase::CAN_CACHE{$class};
  
      $self->init if $Test2::Util::HashBase::CAN_CACHE{$class};
  
      $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::HashBase - Build hash based classes.
  
  =head1 SYNOPSIS
  
  A class:
  
      package My::Class;
      use strict;
      use warnings;
  
      # Generate 3 accessors
      use Test2::Util::HashBase qw/foo -bar ^baz/;
  
      # Chance to initialize defaults
      sub init {
          my $self = shift;    # No other args
          $self->{+FOO} ||= "foo";
          $self->{+BAR} ||= "bar";
          $self->{+BAZ} ||= "baz";
      }
  
      sub print {
          print join ", " => map { $self->{$_} } FOO, BAR, BAZ;
      }
  
  Subclass it
  
      package My::Subclass;
      use strict;
      use warnings;
  
      # Note, you should subclass before loading HashBase.
      use base 'My::Class';
      use Test2::Util::HashBase qw/bat/;
  
      sub init {
          my $self = shift;
  
          # We get the constants from the base class for free.
          $self->{+FOO} ||= 'SubFoo';
          $self->{+BAT} ||= 'bat';
  
          $self->SUPER::init();
      }
  
  use it:
  
      package main;
      use strict;
      use warnings;
      use My::Class;
  
      # These are all functionally identical
      my $one   = My::Class->new(foo => 'MyFoo', bar => 'MyBar');
      my $two   = My::Class->new({foo => 'MyFoo', bar => 'MyBar'});
      my $three = My::Class->new(['MyFoo', 'MyBar']);
  
      # Accessors!
      my $foo = $one->foo;    # 'MyFoo'
      my $bar = $one->bar;    # 'MyBar'
      my $baz = $one->baz;    # Defaulted to: 'baz'
  
      # Setters!
      $one->set_foo('A Foo');
  
      #'-bar' means read-only, so the setter will throw an exception (but is defined).
      $one->set_bar('A bar');
  
      # '^baz' means deprecated setter, this will warn about the setter being
      # deprecated.
      $one->set_baz('A Baz');
  
      $one->{+FOO} = 'xxx';
  
  =head1 DESCRIPTION
  
  This package is used to generate classes based on hashrefs. Using this class
  will give you a C<new()> method, as well as generating accessors you request.
  Generated accessors will be getters, C<set_ACCESSOR> setters will also be
  generated for you. You also get constants for each accessor (all caps) which
  return the key into the hash for that accessor. Single inheritance is also
  supported.
  
  =head1 THIS IS A BUNDLED COPY OF HASHBASE
  
  This is a bundled copy of L<Object::HashBase>. This file was generated using
  the
  C</home/exodist/perl5/perlbrew/perls/main/bin/hashbase_inc.pl>
  script.
  
  =head1 METHODS
  
  =head2 PROVIDED BY HASH BASE
  
  =over 4
  
  =item $it = $class->new(%PAIRS)
  
  =item $it = $class->new(\%PAIRS)
  
  =item $it = $class->new(\@ORDERED_VALUES)
  
  Create a new instance.
  
  HashBase will not export C<new()> if there is already a C<new()> method in your
  packages inheritance chain.
  
  B<If you do not want this method you can define your own> you just have to
  declare it before loading L<Test2::Util::HashBase>.
  
      package My::Package;
  
      # predeclare new() so that HashBase does not give us one.
      sub new;
  
      use Test2::Util::HashBase qw/foo bar baz/;
  
      # Now we define our own new method.
      sub new { ... }
  
  This makes it so that HashBase sees that you have your own C<new()> method.
  Alternatively you can define the method before loading HashBase instead of just
  declaring it, but that scatters your use statements.
  
  The most common way to create an object is to pass in key/value pairs where
  each key is an attribute and each value is what you want assigned to that
  attribute. No checking is done to verify the attributes or values are valid,
  you may do that in C<init()> if desired.
  
  If you would like, you can pass in a hashref instead of pairs. When you do so
  the hashref will be copied, and the copy will be returned blessed as an object.
  There is no way to ask HashBase to bless a specific hashref.
  
  In some cases an object may only have 1 or 2 attributes, in which case a
  hashref may be too verbose for your liking. In these cases you can pass in an
  arrayref with only values. The values will be assigned to attributes in the
  order the attributes were listed. When there is inheritance involved the
  attributes from parent classes will come before subclasses.
  
  =back
  
  =head2 HOOKS
  
  =over 4
  
  =item $self->init()
  
  This gives you the chance to set some default values to your fields. The only
  argument is C<$self> with its indexes already set from the constructor.
  
  B<Note:> Test2::Util::HashBase checks for an init using C<< $class->can('init') >>
  during construction. It DOES NOT call C<can()> on the created object. Also note
  that the result of the check is cached, it is only ever checked once, the first
  time an instance of your class is created. This means that adding an C<init()>
  method AFTER the first construction will result in it being ignored.
  
  =back
  
  =head1 ACCESSORS
  
  =head2 READ/WRITE
  
  To generate accessors you list them when using the module:
  
      use Test2::Util::HashBase qw/foo/;
  
  This will generate the following subs in your namespace:
  
  =over 4
  
  =item foo()
  
  Getter, used to get the value of the C<foo> field.
  
  =item set_foo()
  
  Setter, used to set the value of the C<foo> field.
  
  =item FOO()
  
  Constant, returns the field C<foo>'s key into the class hashref. Subclasses will
  also get this function as a constant, not simply a method, that means it is
  copied into the subclass namespace.
  
  The main reason for using these constants is to help avoid spelling mistakes
  and similar typos. It will not help you if you forget to prefix the '+' though.
  
  =back
  
  =head2 READ ONLY
  
      use Test2::Util::HashBase qw/-foo/;
  
  =over 4
  
  =item set_foo()
  
  Throws an exception telling you the attribute is read-only. This is exported to
  override any active setters for the attribute in a parent class.
  
  =back
  
  =head2 DEPRECATED SETTER
  
      use Test2::Util::HashBase qw/^foo/;
  
  =over 4
  
  =item set_foo()
  
  This will set the value, but it will also warn you that the method is
  deprecated.
  
  =back
  
  =head1 SUBCLASSING
  
  You can subclass an existing HashBase class.
  
      use base 'Another::HashBase::Class';
      use Test2::Util::HashBase qw/foo bar baz/;
  
  The base class is added to C<@ISA> for you, and all constants from base classes
  are added to subclasses automatically.
  
  =head1 GETTING A LIST OF ATTRIBUTES FOR A CLASS
  
  Test2::Util::HashBase provides a function for retrieving a list of attributes for an
  Test2::Util::HashBase class.
  
  =over 4
  
  =item @list = Test2::Util::HashBase::attr_list($class)
  
  =item @list = $class->Test2::Util::HashBase::attr_list()
  
  Either form above will work. This will return a list of attributes defined on
  the object. This list is returned in the attribute definition order, parent
  class attributes are listed before subclass attributes. Duplicate attributes
  will be removed before the list is returned.
  
  B<Note:> This list is used in the C<< $class->new(\@ARRAY) >> constructor to
  determine the attribute to which each value will be paired.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for HashBase can be found at
  F<http://github.com/Test-More/HashBase/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_HASHBASE

$fatpacked{"Test2/Util/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TRACE';
  package Test2::Util::Trace;
  require Test2::EventFacet::Trace;
  @ISA = ('Test2::EventFacet::Trace');
  
  our $VERSION = '1.302136';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::Trace - Legacy wrapper fro L<Test2::EventFacet::Trace>.
  
  =head1 DESCRIPTION
  
  All the functionality for this class has been moved to
  L<Test2::EventFacet::Trace>.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_TRACE

$fatpacked{"Types/Serialiser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER';
  =head1 NAME
  
  Types::Serialiser - simple data types for common serialisation formats
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  This module provides some extra datatypes that are used by common
  serialisation formats such as JSON or CBOR. The idea is to have a
  repository of simple/small constants and containers that can be shared by
  different implementations so they become interoperable between each other.
  
  =cut
  
  package Types::Serialiser;
  
  use common::sense; # required to suppress annoying warnings
  
  our $VERSION = '1.0';
  
  =head1 SIMPLE SCALAR CONSTANTS
  
  Simple scalar constants are values that are overloaded to act like simple
  Perl values, but have (class) type to differentiate them from normal Perl
  scalars. This is necessary because these have different representations in
  the serialisation formats.
  
  =head2 BOOLEANS (Types::Serialiser::Boolean class)
  
  This type has only two instances, true and false. A natural representation
  for these in Perl is C<1> and C<0>, but serialisation formats need to be
  able to differentiate between them and mere numbers.
  
  =over 4
  
  =item $Types::Serialiser::true, Types::Serialiser::true
  
  This value represents the "true" value. In most contexts is acts like
  the number C<1>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::true>) or the constant form (C<Types::Serialiser::true>).
  
  The constant is represented as a reference to a scalar containing C<1> -
  implementations are allowed to directly test for this.
  
  =item $Types::Serialiser::false, Types::Serialiser::false
  
  This value represents the "false" value. In most contexts is acts like
  the number C<0>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::false>) or the constant form (C<Types::Serialiser::false>).
  
  The constant is represented as a reference to a scalar containing C<0> -
  implementations are allowed to directly test for this.
  
  =item $is_bool = Types::Serialiser::is_bool $value
  
  Returns true iff the C<$value> is either C<$Types::Serialiser::true> or
  C<$Types::Serialiser::false>.
  
  For example, you could differentiate between a perl true value and a
  C<Types::Serialiser::true> by using this:
  
     $value && Types::Serialiser::is_bool $value
  
  =item $is_true = Types::Serialiser::is_true $value
  
  Returns true iff C<$value> is C<$Types::Serialiser::true>.
  
  =item $is_false = Types::Serialiser::is_false $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::false>.
  
  =back
  
  =head2 ERROR (Types::Serialiser::Error class)
  
  This class has only a single instance, C<error>. It is used to signal
  an encoding or decoding error. In CBOR for example, and object that
  couldn't be encoded will be represented by a CBOR undefined value, which
  is represented by the error value in Perl.
  
  =over 4
  
  =item $Types::Serialiser::error, Types::Serialiser::error
  
  This value represents the "error" value. Accessing values of this type
  will throw an exception.
  
  The constant is represented as a reference to a scalar containing C<undef>
  - implementations are allowed to directly test for this.
  
  =item $is_error = Types::Serialiser::is_error $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::error>.
  
  =back
  
  =cut
  
  BEGIN {
     # for historical reasons, and to avoid extra dependencies in JSON::PP,
     # we alias *Types::Serialiser::Boolean with JSON::PP::Boolean.
     package JSON::PP::Boolean;
  
     *Types::Serialiser::Boolean:: = *JSON::PP::Boolean::;
  }
  
  {
     # this must done before blessing to work around bugs
     # in perl < 5.18 (it seems to be fixed in 5.18).
     package Types::Serialiser::BooleanBase;
  
     use overload
        "0+"     => sub { ${$_[0]} },
        "++"     => sub { $_[0] = ${$_[0]} + 1 },
        "--"     => sub { $_[0] = ${$_[0]} - 1 },
        fallback => 1;
  
     @Types::Serialiser::Boolean::ISA = Types::Serialiser::BooleanBase::;
  }
  
  our $true  = do { bless \(my $dummy = 1), Types::Serialiser::Boolean:: };
  our $false = do { bless \(my $dummy = 0), Types::Serialiser::Boolean:: };
  our $error = do { bless \(my $dummy    ), Types::Serialiser::Error::   };
  
  sub true  () { $true  }
  sub false () { $false }
  sub error () { $error }
  
  sub is_bool  ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_true  ($) {  $_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_false ($) { !$_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_error ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Error::   }
  
  package Types::Serialiser::Error;
  
  sub error {
     require Carp;
     Carp::croak ("caught attempt to use the Types::Serialiser::error value");
  };
  
  use overload
     "0+"     => \&error,
     "++"     => \&error,
     "--"     => \&error,
     fallback => 1;
  
  =head1 NOTES FOR XS USERS
  
  The recommended way to detect whether a scalar is one of these objects
  is to check whether the stash is the C<Types::Serialiser::Boolean> or
  C<Types::Serialiser::Error> stash, and then follow the scalar reference to
  see if it's C<1> (true), C<0> (false) or C<undef> (error).
  
  While it is possible to use an isa test, directly comparing stash pointers
  is faster and guaranteed to work.
  
  For historical reasons, the C<Types::Serialiser::Boolean> stash is
  just an alias for C<JSON::PP::Boolean>. When printed, the classname
  with usually be C<JSON::PP::Boolean>, but isa tests and stash pointer
  comparison will normally work correctly (i.e. Types::Serialiser::true ISA
  JSON::PP::Boolean, but also ISA Types::Serialiser::Boolean).
  
  =head1 A GENERIC OBJECT SERIALIATION PROTOCOL
  
  This section explains the object serialisation protocol used by
  L<CBOR::XS>. It is meant to be generic enough to support any kind of
  generic object serialiser.
  
  This protocol is called "the Types::Serialiser object serialisation
  protocol".
  
  =head2 ENCODING
  
  When the encoder encounters an object that it cannot otherwise encode (for
  example, L<CBOR::XS> can encode a few special types itself, and will first
  attempt to use the special C<TO_CBOR> serialisation protocol), it will
  look up the C<FREEZE> method on the object.
  
  Note that the C<FREEZE> method will normally be called I<during> encoding,
  and I<MUST NOT> change the data structure that is being encoded in any
  way, or it might cause memory corruption or worse.
  
  If it exists, it will call it with two arguments: the object to serialise,
  and a constant string that indicates the name of the data model. For
  example L<CBOR::XS> uses C<CBOR>, and the L<JSON> and L<JSON::XS> modules
  (or any other JSON serialiser), would use C<JSON> as second argument.
  
  The C<FREEZE> method can then return zero or more values to identify the
  object instance. The serialiser is then supposed to encode the class name
  and all of these return values (which must be encodable in the format)
  using the relevant form for Perl objects. In CBOR for example, there is a
  registered tag number for encoded perl objects.
  
  The values that C<FREEZE> returns must be serialisable with the serialiser
  that calls it. Therefore, it is recommended to use simple types such as
  strings and numbers, and maybe array references and hashes (basically, the
  JSON data model). You can always use a more complex format for a specific
  data model by checking the second argument, the data model.
  
  The "data model" is not the same as the "data format" - the data model
  indicates what types and kinds of return values can be returned from
  C<FREEZE>. For example, in C<CBOR> it is permissible to return tagged CBOR
  values, while JSON does not support these at all, so C<JSON> would be a
  valid (but too limited) data model name for C<CBOR::XS>. similarly, a
  serialising format that supports more or less the same data model as JSON
  could use C<JSON> as data model without losing anything.
  
  =head2 DECODING
  
  When the decoder then encounters such an encoded perl object, it should
  look up the C<THAW> method on the stored classname, and invoke it with the
  classname, the constant string to identify the data model/data format, and
  all the return values returned by C<FREEZE>.
  
  =head2 EXAMPLES
  
  See the C<OBJECT SERIALISATION> section in the L<CBOR::XS> manpage for
  more details, an example implementation, and code examples.
  
  Here is an example C<FREEZE>/C<THAW> method pair:
  
     sub My::Object::FREEZE {
        my ($self, $model) = @_;
  
        ($self->{type}, $self->{id}, $self->{variant})
     }
  
     sub My::Object::THAW {
        my ($class, $model, $type, $id, $variant) = @_;
  
        $class->new (type => $type, id => $id, variant => $variant)
     }
  
  =head1 BUGS
  
  The use of L<overload> makes this module much heavier than it should be
  (on my system, this module: 4kB RSS, overload: 260kB RSS).
  
  =head1 SEE ALSO
  
  Currently, L<JSON::XS> and L<CBOR::XS> use these types.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER

$fatpacked{"Types/Serialiser/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER_ERROR';
  =head1 NAME
  
  Types::Serialiser::Error - dummy module for Types::Serialiser
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules that assume that class name equals module name. See
  L<Types::Serialiser> for more info about this class.
  
  =cut
  
  use Types::Serialiser ();
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER_ERROR

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  my %require_attempted;
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          if (not exists $require_attempted{$ic}) {
              # Try to load it
              my $_old_error = $@;
              eval "require $ic";
              die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
              $@ = $_old_error;
          }
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  use Scalar::Util 'blessed';
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && blessed($base) && $base->isa(__PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if blessed($other) and $other->isa(__PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = $] < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use URI::_punycode;
    $punycode = encode_punycode($unicode);
    $unicode  = decode_punycode($punycode);
  
  =head1 DESCRIPTION
  
  URI::_punycode is a module to encode / decode Unicode strings into
  Punycode, an efficient encoding of Unicode for use with IDNA.
  
  This module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode
  strings.
  
  =head1 FUNCTIONS
  
  This module exports following functions by default.
  
  =over 4
  
  =item encode_punycode
  
    $punycode = encode_punycode($unicode);
  
  takes Unicode string (UTF8-flagged variable) and returns Punycode
  encoding for it.
  
  =item decode_punycode
  
    $unicode = decode_punycode($punycode)
  
  takes Punycode encoding and returns original Unicode string.
  
  =back
  
  These functions throw exceptions on failure. You can catch 'em via
  C<eval>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of
  IDNA::Punycode v0.02 which was the basis for this module.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, RFC 3492
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = map { $_ => $r->{$_} } sort keys %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;
  
  use strict;
  use warnings;
  
  use parent 'URI::ssh';
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  my %require_attempted;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
              if (not exists $require_attempted{$impclass}) {
                  # Try to load it
                  my $_old_error = $@;
                  eval "require $impclass";
                  die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
                  $@ = $_old_error;
              }
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  our $VERSION = '1.71';
  $VERSION = eval $VERSION;
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OK';
  package ok;
  our $VERSION = '1.302136';
  
  use strict;
  use Test::More ();
  
  sub import {
      shift;
  
      if (@_) {
          goto &Test::More::pass if $_[0] eq 'ok';
          goto &Test::More::use_ok;
      }
  
      # No argument list - croak as if we are prototyped like use_ok()
      my (undef, $file, $line) = caller();
      ($file =~ /^\(eval/) or die "Not enough arguments for 'use ok' at $file line $line\n";
  }
  
  
  __END__
  
  =encoding UTF-8
  
  =head1 NAME
  
  ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.
  
  Please see L<Test::use::ok> for the full description.
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
OK

$fatpacked{"private-Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PRIVATE-ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.15009";
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  sub import {
      shift;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      Error::subs->import(@_);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
  
      unless (@_) {
         $LAST = undef;
         return;
      }
  
      my $pkg = shift;
      return unless ref($pkg);
  
      undef $ERROR{$pkg} if defined $ERROR{$pkg};
  }
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  # Allow error propagation, ie
  #
  # $ber->encode(...) or
  #    return Error->prior($ber)->associate($ldap);
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
  
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  
  sub blessed {
  	my $item = shift;
  	local $@; # don't kill an outer $@
  	ref $item and eval { $item->can('can') };
  }
  
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->());
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN);
  			my $ok = eval {
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = defined($Error::THROWN)
  				    ? $Error::THROWN : $@;
                  $err = $Error::ObjectifyCallback->({'text' =>$err})
                      unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
  	    my $ok = eval {
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = defined($Error::THROWN)
  			? $Error::THROWN : $@;
  
          $err = $Error::ObjectifyCallback->({'text' =>$err})
              unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
      local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = defined($Error::THROWN) ? $Error::THROWN : $@
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
  	unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
  
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple -text => "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to its constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =over 4
  
  =item Error::Simple
  
  This class can be used to hold simple error strings and values. Its
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this information will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  =back
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overridden by the user.
  
  It accepts a single argument which is a hash reference to named parameters.
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  =head1 MAINTAINER
  
  Shlomi Fish <shlomif@iglu.org.il>
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =cut
PRIVATE-ERROR

$fatpacked{"x86_64-linux/JSON/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_JSON_XS';
  =head1 NAME
  
  JSON::XS - JSON serialising/deserialising, done correctly and fast
  
  =encoding utf-8
  
  JSON::XS - 正しくて高速な JSON シリアライザ/デシリアライザ
             (http://fleur.hio.jp/perldoc/mix/lib/JSON/XS.html)
  
  =head1 SYNOPSIS
  
   use JSON::XS;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::XS->new->ascii->pretty->allow_nonref;
   $pretty_printed_unencoded = $coder->encode ($perl_scalar);
   $perl_scalar = $coder->decode ($unicode_json_text);
  
   # Note that JSON version 2.0 and above will automatically use JSON::XS
   # if available, at virtually no speed overhead either, so you should
   # be able to just:
   
   use JSON;
  
   # and do the same things, except that you have a pure-perl fallback now.
  
  =head1 DESCRIPTION
  
  This module converts Perl data structures to JSON and vice versa. Its
  primary goal is to be I<correct> and its secondary goal is to be
  I<fast>. To reach the latter goal it was written in C.
  
  Beginning with version 2.0 of the JSON module, when both JSON and
  JSON::XS are installed, then JSON will fall back on JSON::XS (this can be
  overridden) with no overhead due to emulation (by inheriting constructor
  and methods). If JSON::XS is not available, it will fall back to the
  compatible JSON::PP module as backend, so using JSON instead of JSON::XS
  gives you a portable JSON API that can be fast when you need and doesn't
  require a C compiler when that is a problem.
  
  As this is the n-th-something JSON module on CPAN, what was the reason
  to write yet another JSON module? While it seems there are many JSON
  modules, none of them correctly handle all corner cases, and in most cases
  their maintainers are unresponsive, gone missing, or not listening to bug
  reports for other reasons.
  
  See MAPPING, below, on how JSON::XS maps perl values to JSON values and
  vice versa.
  
  =head2 FEATURES
  
  =over 4
  
  =item * correct Unicode handling
  
  This module knows how to handle Unicode, documents how and when it does
  so, and even documents what "correct" means.
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  =item * fast
  
  Compared to other JSON modules and other serialisers such as Storable,
  this module usually compares favourably in terms of speed, too.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an object
  oriented interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format
  possible (nice for simple line-based protocols), a pure-ASCII format
  (for when your transport is not 8-bit clean, still supports the whole
  Unicode range), or a pretty-printed format (for when you want to read that
  stuff). Or you can combine those features in whatever way you like.
  
  =back
  
  =cut
  
  package JSON::XS;
  
  use common::sense;
  
  our $VERSION = 3.01;
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(encode_json decode_json);
  
  use Exporter;
  use XSLoader;
  
  use Types::Serialiser ();
  
  =head1 FUNCTIONAL INTERFACE
  
  The following convenience methods are provided by this module. They are
  exported by default:
  
  =over 4
  
  =item $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
     $json_text = JSON::XS->new->utf8->encode ($perl_scalar)
  
  Except being faster.
  
  =item $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
     $perl_scalar = JSON::XS->new->utf8->decode ($json_text)
  
  Except being faster.
  
  =back
  
  
  =head1 A FEW NOTES ON UNICODE AND PERL
  
  Since this often leads to confusion, here are a few very clear words on
  how Unicode works in Perl, modulo bugs.
  
  =over 4
  
  =item 1. Perl strings can store characters with ordinal values > 255.
  
  This enables you to store Unicode characters as single characters in a
  Perl string - very natural.
  
  =item 2. Perl does I<not> associate an encoding with your strings.
  
  ... until you force it to, e.g. when matching it against a regex, or
  printing the scalar to a file, in which case Perl either interprets your
  string as locale-encoded text, octets/binary, or as Unicode, depending
  on various settings. In no case is an encoding stored together with your
  data, it is I<use> that decides encoding, not any magical meta data.
  
  =item 3. The internal utf-8 flag has no meaning with regards to the
  encoding of your string.
  
  Just ignore that flag unless you debug a Perl bug, a module written in
  XS or want to dive into the internals of perl. Otherwise it will only
  confuse you, as, despite the name, it says nothing about how your string
  is encoded. You can have Unicode strings with that flag set, with that
  flag clear, and you can have binary data with that flag set and that flag
  clear. Other possibilities exist, too.
  
  If you didn't know about that flag, just the better, pretend it doesn't
  exist.
  
  =item 4. A "Unicode String" is simply a string where each character can be
  validly interpreted as a Unicode code point.
  
  If you have UTF-8 encoded data, it is no longer a Unicode string, but a
  Unicode string encoded in UTF-8, giving you a binary string.
  
  =item 5. A string containing "high" (> 255) character values is I<not> a UTF-8 string.
  
  It's a fact. Learn to live with it.
  
  =back
  
  I hope this helps :)
  
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =over 4
  
  =item $json = new JSON::XS
  
  Creates a new JSON::XS object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::XS->new->utf8->space_after->encode ({a => [1,2]})
     => {"a": [1, 2]}
  
  =item $json = $json->ascii ([$enable])
  
  =item $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::XS->new->ascii (1)->encode ([chr 0x10401])
    => ["\ud801\udc01"]
  
  =item $json = $json->latin1 ([$enable])
  
  =item $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =item $json = $json->utf8 ([$enable])
  
  =item $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  =item $json = $json->pretty ([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Example, pretty-print some simple structure:
  
     my $json = JSON::XS->new->pretty(1)->encode ({a => [1,2]})
     =>
     {
        "a" : [
           1,
           2
        ]
     }
  
  =item $json = $json->indent ([$enable])
  
  =item $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =item $json = $json->space_before ([$enable])
  
  =item $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =item $json = $json->space_after ([$enable])
  
  =item $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =item $json = $json->relaxed ([$enable])
  
  =item $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =item $json = $json->canonical ([$enable])
  
  =item $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =item $json = $json->allow_nonref ([$enable])
  
  =item $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON::XS->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =item $json = $json->allow_unknown ([$enable])
  
  =item $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =item $json = $json->allow_blessed ([$enable])
  
  =item $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->convert_blessed ([$enable])
  
  =item $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->allow_tags ([$enable])
  
  =item $enabled = $json->allow_tags
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialise the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialise
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =item $json = $json->filter_json_object ([$coderef->($hashref)])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::XS->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]')
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =item $json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::XS
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =item $json = $json->shrink ([$enable])
  
  =item $enabled = $json->get_shrink
  
  Perl usually over-allocates memory a bit when allocating space for
  strings. This flag optionally resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk-to-fit, while all strings generated by C<decode> will also be
  shrunk-to-fit.
  
  If C<$enable> is false, then the normal perl allocation algorithms are used.
  If you work with your data, then this is likely to be faster.
  
  In the future, this setting might control other things, such as converting
  strings that look like integers or floats into integers or floats
  internally (there is no difference on the Perl level), saving space.
  
  =item $json = $json->max_depth ([$maximum_nesting_depth])
  
  =item $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing.
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json = $json->max_size ([$maximum_string_size])
  
  =item $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json_text = $json->encode ($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =item $perl_scalar = $json->decode ($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =item ($perl_scalar, $characters) = $json->decode_prefix ($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON::XS->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =back
  
  
  =head1 INCREMENTAL PARSING
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::XS will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =over 4
  
  =item [void, scalar or list context] = $json->incr_parse ([$string])
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
     my @objs = JSON::XS->new->incr_parse ("[5][7][1,2]");
  
  =item $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =item $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =item $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =back
  
  =head2 LIMITATIONS
  
  All options that affect decoding are supported, except
  C<allow_nonref>. The reason for this is that it cannot be made to work
  sensibly: JSON objects and arrays are self-delimited, i.e. you can
  concatenate them back to back and still decode them perfectly. This does
  not hold true for JSON numbers, however.
  
  For example, is the string C<1> a single JSON number, or is it simply the
  start of C<12>? Or is C<12> a single JSON number, or the concatenation
  of C<1> and C<2>? In neither case you can tell, and this is why JSON::XS
  takes the conservative route and disallows this case.
  
  =head2 EXAMPLES
  
  Some examples will make all this clearer. First, a simple example that
  works similarly to C<decode_prefix>: We want to decode the JSON object at
  the start of a string and identify the portion after the JSON object:
  
     my $text = "[1,2,3] hello";
  
     my $json = new JSON::XS;
  
     my $obj = $json->incr_parse ($text)
        or die "expected JSON object or array at beginning of string";
  
     my $tail = $json->incr_text;
     # $tail now contains " hello"
  
  Easy, isn't it?
  
  Now for a more complicated example: Imagine a hypothetical protocol where
  you read some requests from a TCP stream, and each request is a JSON
  array, without any separation between them (in fact, it is often useful to
  use newlines as "separators", as these get interpreted as whitespace at
  the start of the JSON text, which makes it possible to test said protocol
  with C<telnet>...).
  
  Here is how you'd do it (it is trivial to write this in an event-based
  manner):
  
     my $json = new JSON::XS;
  
     # read some data from the socket
     while (sysread $socket, my $buf, 4096) {
  
        # split and decode as many requests as possible
        for my $request ($json->incr_parse ($buf)) {
           # act on the $request
        }
     }
  
  Another complicated example: Assume you have a string with JSON objects
  or arrays, all separated by (optional) comma characters (e.g. C<[1],[2],
  [3]>). To parse them, we have to skip the commas between the JSON texts,
  and here is where the lvalue-ness of C<incr_text> comes in useful:
  
     my $text = "[1],[2], [3]";
     my $json = new JSON::XS;
  
     # void context, so no parsing done
     $json->incr_parse ($text);
  
     # now extract as many objects as possible. note the
     # use of scalar context so incr_text can be called.
     while (my $obj = $json->incr_parse) {
        # do something with $obj
  
        # now skip the optional comma
        $json->incr_text =~ s/^ \s* , //x;
     }
  
  Now lets go for a very complex example: Assume that you have a gigantic
  JSON array-of-objects, many gigabytes in size, and you want to parse it,
  but you cannot load it into memory fully (this has actually happened in
  the real world :).
  
  Well, you lost, you have to implement your own JSON parser. But JSON::XS
  can still help you: You implement a (very simple) array parser and let
  JSON decode the array elements, which are all full JSON objects on their
  own (this wouldn't work if the array elements could be JSON numbers, for
  example):
  
     my $json = new JSON::XS;
  
     # open the monster
     open my $fh, "<bigfile.json"
        or die "bigfile: $!";
  
     # first parse the initial "["
     for (;;) {
        sysread $fh, my $buf, 65536
           or die "read error: $!";
        $json->incr_parse ($buf); # void context, so no parsing
  
        # Exit the loop once we found and removed(!) the initial "[".
        # In essence, we are (ab-)using the $json object as a simple scalar
        # we append data to.
        last if $json->incr_text =~ s/^ \s* \[ //x;
     }
  
     # now we have the skipped the initial "[", so continue
     # parsing all the elements.
     for (;;) {
        # in this loop we read data until we got a single JSON object
        for (;;) {
           if (my $obj = $json->incr_parse) {
              # do something with $obj
              last;
           }
  
           # add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
        # in this loop we read data until we either found and parsed the
        # separating "," between elements, or the final "]"
        for (;;) {
           # first skip whitespace
           $json->incr_text =~ s/^\s*//;
  
           # if we find "]", we are done
           if ($json->incr_text =~ s/^\]//) {
              print "finished.\n";
              exit;
           }
  
           # if we find ",", we can continue with the next element
           if ($json->incr_text =~ s/^,//) {
              last;
           }
  
           # if we find anything else, we have a parse error!
           if (length $json->incr_text) {
              die "parse error near ", $json->incr_text;
           }
  
           # else add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
  This is a complex example, but most of the complexity comes from the fact
  that we are trying to be correct (bear with me if I am wrong, I never ran
  the above example :).
  
  
  
  =head1 MAPPING
  
  This section describes how JSON::XS maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::XS will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::XS only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<Types::Serialiser::true> and
  C<Types::Serialiser::false>, respectively. They are overloaded to act
  almost exactly like the numbers C<1> and C<0>. You can check whether
  a scalar is a JSON boolean by using the C<Types::Serialiser::is_bool>
  function (after C<use Types::Serialier>, of course).
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALISATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. JSON::XS can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same datastructure will
  serialise to the same JSON text (given same settings and version of
  JSON::XS), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON.
  
  Since C<JSON::XS> uses the boolean model from L<Types::Serialiser>, you
  can also C<use Types::Serialiser> and then use C<Types::Serialiser::false>
  and C<Types::Serialiser::true> to improve readability.
  
     use Types::Serialiser;
     encode_json [\0, Types::Serialiser::true]      # yields [false,true]
  
  =item Types::Serialiser::true, Types::Serialiser::false
  
  These special values from the L<Types::Serialiser> module become JSON true
  and JSON false values, respectively. You can also use C<\1> and C<\0>
  directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a JSON string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a JSON number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialise the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALISATION
  
  What happens when C<JSON::XS> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_tags> settings, which are
  used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<JSON::XS> uses the L<Types::Serialiser> object
  serialisation protocol to create a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialise, and the second argument being the
  constant string C<JSON> to distinguish it from other serialisers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serialiser) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fatc that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<JSON::XS> throws an exception.
  
  =back
  
  =head3 DESERIALISATION
  
  For deserialisation there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialised, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: I a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, C<JSON::XS> will look up the C<THAW> method
  of the package/classname used during serialisation (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<enable_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serialiser, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  
  =head2 JSON and ECMAscript
  
  JSON syntax is based on how literals are represented in javascript (the
  not-standardised predecessor of ECMAscript) which is presumably why it is
  called "JavaScript Object Notation".
  
  However, JSON is not a subset (and also not a superset of course) of
  ECMAscript (the standard) or javascript (whatever browsers actually
  implement).
  
  If you want to use javascript's C<eval> function to "parse" JSON, you
  might run into parse errors for valid JSON texts, or the resulting data
  structure might not be queryable:
  
  One of the problems is that U+2028 and U+2029 are valid characters inside
  JSON strings, but are not allowed in ECMAscript string literals, so the
  following Perl fragment will not output something that can be guaranteed
  to be parsable by javascript's C<eval>:
  
     use JSON::XS;
  
     print encode_json [chr 0x2028];
  
  The right fix for this is to use a proper JSON parser in your javascript
  programs, and not rely on C<eval> (see for example Douglas Crockford's
  F<json2.js> parser).
  
  If this is not an option, you can, as a stop-gap measure, simply encode to
  ASCII-only JSON:
  
     use JSON::XS;
  
     print JSON::XS->new->ascii->encode ([chr 0x2028]);
  
  Note that this will enlarge the resulting JSON text quite a bit if you
  have many non-ASCII characters. You might be tempted to run some regexes
  to only escape U+2028 and U+2029, e.g.:
  
     # DO NOT USE THIS!
     my $json = JSON::XS->new->utf8->encode ([chr 0x2028]);
     $json =~ s/\xe2\x80\xa8/\\u2028/g; # escape U+2028
     $json =~ s/\xe2\x80\xa9/\\u2029/g; # escape U+2029
     print $json;
  
  Note that I<this is a bad idea>: the above only works for U+2028 and
  U+2029 and thus only for fully ECMAscript-compliant parsers. Many existing
  javascript implementations, however, have issues with other characters as
  well - using C<eval> naively simply I<will> cause problems.
  
  Another problem is that some javascript implementations reserve
  some property names for their own purposes (which probably makes
  them non-ECMAscript-compliant). For example, Iceweasel reserves the
  C<__proto__> property name for its own purposes.
  
  If that is a problem, you could parse try to filter the resulting JSON
  output for these property strings, e.g.:
  
     $json =~ s/"__proto__"\s*:/"__proto__renamed":/g;
  
  This works because C<__proto__> is not valid outside of strings, so every
  occurrence of C<"__proto__"\s*:> must be a string used as property name.
  
  If you know of other incompatibilities, please let me know.
  
  
  =head2 JSON and YAML
  
  You often hear that JSON is a subset of YAML. This is, however, a mass
  hysteria(*) and very far from the truth (as of the time of this writing),
  so let me state it clearly: I<in general, there is no way to configure
  JSON::XS to output a data structure as valid YAML> that works in all
  cases.
  
  If you really must use JSON::XS to generate YAML, you should use this
  algorithm (subject to change in future versions):
  
     my $to_yaml = JSON::XS->new->utf8->space_after (1);
     my $yaml = $to_yaml->encode ($ref) . "\n";
  
  This will I<usually> generate JSON texts that also parse as valid
  YAML. Please note that YAML has hardcoded limits on (simple) object key
  lengths that JSON doesn't have and also has different and incompatible
  unicode character escape syntax, so you should make sure that your hash
  keys are noticeably shorter than the 1024 "stream characters" YAML allows
  and that you do not have characters with codepoint values outside the
  Unicode BMP (basic multilingual page). YAML also does not allow C<\/>
  sequences in strings (which JSON::XS does not I<currently> generate, but
  other JSON generators might).
  
  There might be other incompatibilities that I am not aware of (or the YAML
  specification has been changed yet again - it does so quite often). In
  general you should not try to generate YAML with a JSON generator or vice
  versa, or try to parse JSON with a YAML parser or vice versa: chances are
  high that you will run into severe interoperability problems when you
  least expect it.
  
  =over 4
  
  =item (*)
  
  I have been pressured multiple times by Brian Ingerson (one of the
  authors of the YAML specification) to remove this paragraph, despite him
  acknowledging that the actual incompatibilities exist. As I was personally
  bitten by this "JSON is YAML" lie, I refused and said I will continue to
  educate people about these issues, so others do not run into the same
  problem again and again. After this, Brian called me a (quote)I<complete
  and worthless idiot>(unquote).
  
  In my opinion, instead of pressuring and insulting people who actually
  clarify issues with YAML and the wrong statements of some of its
  proponents, I would kindly suggest reading the JSON spec (which is not
  that difficult or long) and finally make YAML compatible to it, and
  educating users about the changes, instead of spreading lies about the
  real compatibility for many I<years> and trying to silence people who
  point out that it isn't true.
  
  Addendum/2009: the YAML 1.2 spec is still incompatible with JSON, even
  though the incompatibilities have been documented (and are known to Brian)
  for many years and the spec makes explicit claims that YAML is a superset
  of JSON. It would be so easy to fix, but apparently, bullying people and
  corrupting userdata is so much easier.
  
  =back
  
  
  =head2 SPEED
  
  It seems that JSON::XS is surprisingly fast, as shown in the following
  tables. They have been generated with the help of the C<eg/bench> program
  in the JSON::XS distribution, to make it easy to compare on your own
  system.
  
  First comes a comparison between various modules using
  a very short single-line JSON string (also available at
  L<http://dist.schmorp.de/misc/json/short.json>).
  
     {"method": "handleMessage", "params": ["user1",
     "we were just talking"], "id": null, "array":[1,11,234,-5,1e5,1e7,
     1,  0]}
  
  It shows the number of encodes/decodes per second (JSON::XS uses
  the functional interface, while JSON::XS/2 uses the OO interface
  with pretty-printing and hashkey sorting enabled, JSON::XS/3 enables
  shrink. JSON::DWIW/DS uses the deserialise function, while JSON::DWIW::FJ
  uses the from_json method). Higher is better:
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |  86302.551 | 102300.098 |
     JSON::DWIW/FJ |  86302.551 |  75983.768 |
     JSON::PP      |  15827.562 |   6638.658 |
     JSON::Syck    |  63358.066 |  47662.545 |
     JSON::XS      | 511500.488 | 511500.488 |
     JSON::XS/2    | 291271.111 | 388361.481 |
     JSON::XS/3    | 361577.931 | 361577.931 |
     Storable      |  66788.280 | 265462.278 |
     --------------+------------+------------+
  
  That is, JSON::XS is almost six times faster than JSON::DWIW on encoding,
  about five times faster on decoding, and over thirty to seventy times
  faster than JSON's pure perl implementation. It also compares favourably
  to Storable for small amounts of data.
  
  Using a longer test string (roughly 18KB, generated from Yahoo! Locals
  search API (L<http://dist.schmorp.de/misc/json/long.json>).
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |   1647.927 |   2673.916 |
     JSON::DWIW/FJ |   1630.249 |   2596.128 |
     JSON::PP      |    400.640 |     62.311 |
     JSON::Syck    |   1481.040 |   1524.869 |
     JSON::XS      |  20661.596 |   9541.183 |
     JSON::XS/2    |  10683.403 |   9416.938 |
     JSON::XS/3    |  20661.596 |   9400.054 |
     Storable      |  19765.806 |  10000.725 |
     --------------+------------+------------+
  
  Again, JSON::XS leads by far (except for Storable which non-surprisingly
  decodes a bit faster).
  
  On large strings containing lots of high Unicode characters, some modules
  (such as JSON::PC) seem to decode faster than JSON::XS, but the result
  will be broken due to missing (or wrong) Unicode handling. Others refuse
  to decode or encode properly, so it was impossible to prepare a fair
  comparison table for that case.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  When you are using JSON in a protocol, talking to untrusted potentially
  hostile creatures requires relatively few measures.
  
  First of all, your JSON decoder should be secure, that is, should not have
  any buffer overflows. Obviously, this module should ensure that and I am
  trying hard on making that true, but you never know.
  
  Second, you need to avoid resource-starving attacks. That means you should
  limit the size of JSON texts you accept, or make sure then when your
  resources run out, that's just fine (e.g. by using a separate process that
  can crash safely). The size of a JSON text in octets or characters is
  usually a good indication of the size of the resources required to decode
  it into a Perl structure. While JSON::XS can check the size of the JSON
  text, it might be too late when you already have it in memory, so you
  might want to check the size before you accept the string.
  
  Third, JSON::XS recurses using the C stack when decoding objects and
  arrays. The C stack is a limited resource: for instance, on my amd64
  machine with 8MB of stack size I can decode around 180k nested arrays but
  only 14k nested JSON objects (due to perl itself recursing deeply on croak
  to free the temporary). If that is exceeded, the program crashes. To be
  conservative, the default nesting limit is set to 512. If your process
  has a smaller stack, you should adjust this setting accordingly with the
  C<max_depth> method.
  
  Something else could bomb you, too, that I forgot to think of. In that
  case, you get to keep the pieces. I am always open for hints, though...
  
  Also keep in mind that JSON::XS might leak contents of your Perl data
  structures in its error messages, so when you serialise sensitive
  information you might want to make sure that exceptions thrown by JSON::XS
  will not end up in front of untrusted eyes.
  
  If you are using JSON::XS to return packets to consumption
  by JavaScript scripts in a browser you should have a look at
  L<http://blog.archive.jpsykes.com/47/practical-csrf-and-json-security/> to
  see whether you are vulnerable to some common attack vectors (which really
  are browser design bugs, but it is still you who will have to deal with
  it, as major browser developers care only for features, not about getting
  security right).
  
  
  =head1 INTEROPERABILITY WITH OTHER MODULES
  
  C<JSON::XS> uses the L<Types::Serialiser> module to provide boolean
  constants. That means that the JSON true and false values will be
  comaptible to true and false values of iother modules that do the same,
  such as L<JSON::PP> and L<CBOR::XS>.
  
  
  =head1 THREADS
  
  This module is I<not> guaranteed to be thread safe and there are no
  plans to change this until Perl gets thread support (as opposed to the
  horribly slow so-called "threads" which are simply slow and bloated
  process simulations - use fork, it's I<much> faster, cheaper, better).
  
  (It might actually work, but you have been warned).
  
  
  =head1 THE PERILS OF SETLOCALE
  
  Sometimes people avoid the Perl locale support and directly call the
  system's setlocale function with C<LC_ALL>.
  
  This breaks both perl and modules such as JSON::XS, as stringification of
  numbers no longer works correctly (e.g. C<$x = 0.1; print "$x"+1> might
  print C<1>, and JSON::XS might output illegal JSON as JSON::XS relies on
  perl to stringify numbers).
  
  The solution is simple: don't call C<setlocale>, or use it for only those
  categories you need, such as C<LC_MESSAGES> or C<LC_CTYPE>.
  
  If you need C<LC_NUMERIC>, you should enable it only around the code that
  actually needs it (avoiding stringification of numbers), and restore it
  afterwards.
  
  
  =head1 BUGS
  
  While the goal of this module is to be correct, that unfortunately does
  not mean it's bug-free, only that I think its design is bug-free. If you
  keep reporting bugs they will be fixed swiftly, though.
  
  Please refrain from using rt.cpan.org or any other bug reporting
  service. I put the contact address into my modules for a reason.
  
  =cut
  
  BEGIN {
     *true    = \$Types::Serialiser::true;
     *true    = \&Types::Serialiser::true;
     *false   = \$Types::Serialiser::false;
     *false   = \&Types::Serialiser::false;
     *is_bool = \&Types::Serialiser::is_bool;
  
     *JSON::XS::Boolean:: = *Types::Serialiser::Boolean::;
  }
  
  XSLoader::load "JSON::XS", $VERSION;
  
  =head1 SEE ALSO
  
  The F<json_xs> command line utility for quick experiments.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
X86_64-LINUX_JSON_XS

$fatpacked{"x86_64-linux/JSON/XS/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_JSON_XS_BOOLEAN';
  =head1 NAME
  
  JSON::XS::Boolean - dummy module providing JSON::XS::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules. It's only needed for compatibility with data serialised
  (by other modules such as Storable) that was decoded by JSON::XS versions
  before 3.0.
  
  Since 3.0, JSON::PP::Boolean has replaced it. Support for
  JSON::XS::Boolean will be removed in a future release.
  
  =cut
  
  use JSON::XS ();
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
X86_64-LINUX_JSON_XS_BOOLEAN

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.47";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.47";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/PerlIO/utf8_strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PERLIO_UTF8_STRICT';
  package PerlIO::utf8_strict;
  $PerlIO::utf8_strict::VERSION = '0.006';
  use strict;
  use warnings;
  
  use XSLoader;
  
  XSLoader::load(__PACKAGE__, __PACKAGE__->VERSION);
  
  1;
  
  #ABSTRACT: Fast and correct UTF-8 IO
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  PerlIO::utf8_strict - Fast and correct UTF-8 IO
  
  =head1 VERSION
  
  version 0.006
  
  =head1 SYNOPSIS
  
   open my $fh, '<:utf8_strict', $filename;
  
  =head1 DESCRIPTION
  
  This module provides a fast and correct UTF-8 PerlIO layer. Unlike perl's default C<:utf8> layer it checks the input for correctness.
  
  =head1 LAYER ARGUMENTS
  
  =over 4
  
  =item allow_noncharacters
  
  =item allow_surrogates
  
  =back
  
  =head1 EXPORT
  
  PerlIO::utf8_strict exports no subroutines or symbols, just a perl layer C<utf8_strict>
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Can't decode ill-formed UTF-8 octet sequence <%s>
  
  (F) Encountered an ill-formed UTF-8 octet sequence. <%s> contains a hexadecimal 
  representation of the maximal subpart of the ill-formed subsequence.
  
  =item Can't interchange noncharacter code point U+%.4X
  
  (F) Noncharacters is permanently reserved for internal use and that should 
  never be interchanged. Noncharacters consist of the values U+nFFFE and U+nFFFF 
  (where n is from 0 to 10^16) and the values U+FDD0..U+FDEF.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Leon Timmermans <leont@cpan.org>
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Leon Timmermans, Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX_PERLIO_UTF8_STRICT

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.73;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\xc0";
     # use strict, use utf8; use feature;
     $^H |= 0x1c820fc0;
     @^H{qw(feature_say feature_fc feature___SUB__ feature_evalbytes feature_switch feature_unicode feature_state)} = (1) x 7;
  }
  
  1
X86_64-LINUX_COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

# -*- cperl -*-

use Test::More;
use Git;
use LWP::Simple;
use File::Slurper qw(read_text);
use Net::Ping;
use Term::ANSIColor qw(:constants);
use JSON;

use v5.14; # For say

my $repo = Git->repository ( Directory => '.' );
my $diff = $repo->command('diff','HEAD^1','HEAD');
my $diff_regex = qr/a\/proyectos\/(\d)\.md/;
my $github;

SKIP: {
  my ($this_hito) = ($diff =~ $diff_regex);
  skip "No hay envío de proyecto", 5 unless defined $this_hito;
  my $diag=<<EOC;

"Failed test" indica que no se cumple la condición indicada
Hay que corregir el envío y volver a hacer el pull request,
aumentando en uno el número de la versión del hito en el
fichero correspondiente.

EOC
  diag $diag;
  my @files = split(/diff --git/,$diff);
  my ($diff_hito) = grep( /$diff_regex/, @files);
  say "Tratando diff\n\t$diff_hito";
  my @lines = split("\n",$diff_hito);
  my @adds = grep(/^\+[^+]/,@lines);
  is( $#adds, 0, "Añade sólo una línea");
  my $url_repo;
  if ( $adds[0] =~ /\(http/ ) {
    ($url_repo) = ($adds[0] =~ /\((http\S+)\)/);
  } else {
    ($url_repo) = ($adds[0] =~ /^\+.+(http\S+)\b/s);
  }
  diag(check( "Encontrado URL del repo $url_repo" ));
  say $url_repo;
  isnt($url_repo,"","El envío incluye un URL");
  like($url_repo,qr/github.com/,"El URL es de GitHub");
  my ($user,$name) = ($url_repo=~ /github.com\/(\S+)\/(.+)/);
  my $este_fichero = fichero_objetivos($user);
  ok( $este_fichero, "$user ha enviado objetivos" ); # Test 4

  # Comprobar que los ha actualizado
  my $objetivos_actualizados = objetivos_actualizados( $repo, $este_fichero );
  is( $objetivos_actualizados, "",
       "Fichero de objetivos $este_fichero está actualizado")
    or skip "Fichero de objetivos actualizados hace $objetivos_actualizados" ;
  
  my $repo_dir = "/tmp/$user-$name";
  if (!(-e $repo_dir) or  !(-d $repo_dir) ) {
    mkdir($repo_dir);
    `git clone $url_repo $repo_dir`;
  }
  my $student_repo =  Git->repository ( Directory => $repo_dir );
  my @repo_files = $student_repo->command("ls-files");
  say "Ficheros\n\t→", join( "\n\t→", @repo_files);
  isnt( grep(/proyectos\/0.md/, @repo_files), 1, "No es el repositorio de la asignatura");

  # Necesitamos el README a partir de ahora.
  my $README =  read_text( "$repo_dir/README.md");
  unlike( $README, qr/[hH]ito/, "El README no debe incluir la palabra hito");

  # Comprueba que se use el nombre correcto para los ficheros de requisitos si existen
  my $with_pip = grep(/req\w+\.txt/, @repo_files);
  if ($with_pip) {
     ok( grep( /requirements.txt/, @repo_files), "Fichero de requisitos de Python con nombre correcto" );
   }

  if ( $this_hito > 1 ) { # Integración continua
    doing("hito 2");
    isnt( grep( /.travis.yml/, @repo_files), 0, ".travis.yml presente" );
    my $travis_domain = travis_domain( $README, $user, $name );
    ok( $travis_domain =~ /(com|org)/ , "Está presente el badge de Travis con enlace al repo correcto");
    if ( $travis_domain =~ /(com|org)/ ) {
      is( travis_status($README), 'Passing', "Los tests deben pasar en Travis");
    }

    my ($buildtool) = ($README =~ m{(?:buildtool:)\s+(\S+)\s+});
    ok( $buildtool, "Encontrado nombre del fichero buildtool" );
    isnt( grep( /\b$buildtool\b/, @repo_files), 0, "$buildtool presente" );
  }

  if ( $this_hito > 2 ) { # Integración continua
    doing("hito 3");
    isnt( grep( /Dockerfile/, @repo_files), 0, "Dockerfile presente" );
    # Comprobaciones sobre el Dockerfile
    my $dockerfile_content =   read_text( "$repo_dir/Dockerfile");
    ok( $dockerfile_content !~ /COPY \.\s+/, "Se deben copiar sólo los ficheros necesarios para la construcción" );

    # Comprobación del registry
    my ($registry) = ($README =~ m{(?:Contenedor:)\s+(\S+)\s+});
    ok( $registry, "Encontrado despliegue en registro $registry" );
    if ( $registry =~ /hub.docker.com/ ) {
      my $dockerfile = get "$registry/dockerfile";
      ok( $dockerfile, "Se descarga correctamente el URL del Dockerfile $registry/dockerfile" );
    } elsif ( $registry =~ /github.com/ ) {
      my $dockerfile = get $registry;
      ok( $dockerfile, "Se descarga correctamente el URL $registry" );
    } else {
      fail("$registry no es la dirección de un registro conocido");
    }
  }

  if ( $this_hito > 3 ) { # Integración continua
    doing("hito 4");
    my ($m_tool) = ($README =~ m{(?:Prestaciones:)\s+(\S+)\s+});
    ok( $m_tool, "Encontrado nombre del fichero de prestaciones $m_tool" );
    isnt( grep( /\b$m_tool\b/, @repo_files), 0, "Fichero de prestaciones $m_tool presente" );
  }

};

done_testing();


# ------------------------------- Subs -----------------------------------
sub doing {
  my $what = shift;
  diag "\n\t✔ Comprobando $what\n";
}

sub fichero_objetivos {
  my $user = shift;
  my @ficheros_objetivos = glob "objetivos/*.md";
  my @enviados = map { lc } @ficheros_objetivos;
  my $lc_user = lc $user;
  return grep( /$lc_user/, @enviados);
}

sub check {
  return BOLD.GREEN ."✔ ".RESET.join(" ",@_);
}

sub fail_x {
  return BOLD.MAGENTA."✘".RESET.join(" ",@_);
}

sub travis_domain {
  my ($README, $user, $name) = @_;
  my ($domain) = ($README =~ /.Build Status..https:\/\/travis-ci.(\w+)\/$user\/$name\.svg.+$name\)/i);
  return $domain;
}

sub travis_status {
  my $README = shift;
  my ($build_status) = ($README =~ /Build Status..([^\)]+)\)/);
  my $status_svg = `curl -L -s $build_status`;
  return $status_svg =~ /passing/?"Passing":"Fail";
}

sub check_ip {
  my $ip = shift;
  if ( $ip ) {
    diag "\n\t".check( "Detectada dirección de despliegue $ip" )."\n";
  } else {
    diag "\n\t".fail_x( "Problemas detectando dirección de despliegue" )."\n";
  }
  my $pinger = Net::Ping->new();
  $pinger->port_number(22); # Puerto ssh
  isnt($pinger->ping($ip), 0, "$ip es alcanzable");
}

sub objetivos_actualizados {
  my $repo = shift;
  my $objective_file = shift;
  my $date = $repo->command('log', '-1', '--date=relative', '--', "$objective_file");
  my ($hace,$unidad)= $date =~ /Date:.+?(\d+)\s+(\w+)/;
  if ( $unidad =~ /(semana|week|minut)/ ) {
    return "";
  } elsif ( $unidad =~ /ho/ ) {
    return ($hace > 1 )?"":"Objetivos actualizados demasiado recientemente";
  } elsif ( $unidad =~ /d\w+/ ){
    return ($hace < 7)?"":"Los objetivos no han sido actualizados en la semana anterior";
  }

}
